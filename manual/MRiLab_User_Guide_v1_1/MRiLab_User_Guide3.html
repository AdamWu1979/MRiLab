<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>text</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- frames,html --> 
<meta name="src" content="MRiLab_User_Guide.tex"> 
<meta name="date" content="2014-01-28 15:03:00"> 
<link rel="stylesheet" type="text/css" href="MRiLab_User_Guide.css"> 
</head><body  background="../../images/background.jpg"
id="tex4ht-main">
<!--l. 9--><p class="noindent" ><a 
 id="tex4ht-body"></a>

   <div class="maketitle">




<h2 class="titleHead">MRiLab v1.1 User Guide</h2>
     <div class="author" ><span 
class="cmr-12">Fang Liu</span>
<br /><span 
class="cmr-12">(leoliuf@gmail.com)</span></div><br />
<div class="date" ><span 
class="cmr-12">January 28, 2014</span></div>

   </div>

   <h2 class="likechapterHead"><a 
 id="x3-1000"></a>Preface</h2>
<!--l. 58--><p class="noindent" >Numerical MRI simulation can dramatically speed the understanding and
development of new MR imaging methods. In this work, a new simulation package
named &#8217;MRiLab&#8217; has been invented for performing fast 3D parallel MRI numerical
simulation on regular desktop computer. This simulation package is aimed to provide
a fast, comprehensive and effective numerical MRI simulation solution with minimum
computing hardware requirement.
<!--l. 60--><p class="indent" >   This manual is aimed to provide a comprehensive introduction to various
functions included in MRiLab package, through demonstrating a workflow of
simulation, dedicated toolboxes and built-in libraries capable of customizing various
aspects of MR simulation experiment. You should become familiar and comfortable
with all the design functions available in MRiLab after reading this User
Guide.
<!--l. 62--><p class="indent" >   It&#8217;s my greatest pleasure to know that MRiLab can help you in your MR research
and/or education. Please don&#8217;t hesitate to leave me feedback about any aspect of
MRiLab and/or about this User Guide. All the effects for improving MRiLab will
hopefully help MR researchers including myself for better understanding and
improving future MR techniques.

<!--l. 64--><p class="indent" >


<!--l. 66--><p class="indent" >

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;1</span><br /><a 
 id="x3-20001"></a>Introduction</h2>
   <h3 class="sectionHead"><span class="titlemark">1.1   </span> <a 
 id="x3-30001.1"></a>What is MRiLab</h3>
<!--l. 68--><p class="noindent" >The MRiLab is a numerical MRI simulation package. It has been invented and
developed to simulate MR signal formation, K-Space acquisition and MR image
reconstruction. MRiLab provides several dedicated toolboxes for MR researchers to
analyze RF pulse, design MR sequence, configure multiple transmitting and receiving
coils, investigate field inhomogeneity and test real-time imaging technique
etc. The main MRiLab simulation platform combined with these toolboxes
can be applied for customizing various virtual MR experiments which can
serve as a prior stage for prototyping and testing new MR technique and
application.
<!--l. 70--><p class="indent" >   The MRiLab features highly interactive graphical user interface (GUI) for the
ease of fast experiment design and technique prototyping. A high simulation accuracy
is achieved by simulating discrete spin evolution at small time interval using the
Bloch-equation and appropriate spin model. In order to manipulate large
multidimensional spin array, MRiLab employs parallel computing by incorporating
latest GPU technique and multi-threading CPU technique. Benefit from the
accelerated computing, MRiLab can accomplish multidimensional multiple spin
species MR simulation with high simulation accuracy and time efficiency, and with
low computing hardware cost.
<!--l. 72--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">1.2   </span> <a 
 id="x3-40001.2"></a>Obtaining MRiLab</h3>
<!--l. 73--><p class="noindent" >The current MRiLab version (v1.1) is made available at SourceForge website.
MRiLab is released as a free software. This means that you are free to use and
modify this software as your needs, as long as you acknowledge the original author in
any future work. If you find MRiLab useful for the publication of any scientific
results, including a line in your acknowledgments section referencing to MRiLab and
this belowing address is requested.<br 
class="newline" /><br 
class="newline" />MRiLab downloading address:
<div class="center" 
>
<!--l. 76--><p class="noindent" >
<!--l. 77--><p class="noindent" ><a 
href="http://sourceforge.net/projects/mrilab/" target="_blank"><span 
class="cmtt-10">http://sourceforge.net/projects/mrilab/</span></a></div>
<!--l. 80--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">1.3   </span> <a 
 id="x3-50001.3"></a>Installing and Running MRiLab</h3>
<!--l. 82--><p class="noindent" >To run MRiLab, a Matlab installment is required. The current MRiLab version has
been tested under the following Matlab versions:

     <ul class="itemize1">
     <li class="itemize">Matlab R2011a 64-bit Windows
     </li>
     <li class="itemize">Matlab R2013a 64-bit Windows
     </li>
     <li class="itemize">Matlab R2012b 64-bit Unix</li></ul>
<!--l. 89--><p class="indent" >   Installing and running MRiLab is easy, you just need to download MRiLab source
code which is distributed as a compressed file, then extract the MRiLab root
folder, put the folder to any location in you computer. To run MRiLab, start
Matlab, then simply run the &#8216;MRiLab.m&#8217; script under the MRiLab root folder.
<br 
class="newline" />
<!--l. 91--><p class="indent" >   The graphical user interface in MRiLab is developed under Matlab GUIDE
environment. Most of the simulation configuration code is programmed using
pure Matlab language and Extensible Markup Language (XML), however,
the computation intensive functions are programmed and optimized using
MATLAB Executable (MEX) C code. These MEX binaries includes all the
computing kernels that interact with GPU device via NVIDIA CUDA and
with multi-core CPU via OpenMP. Some three-dimensional image rendering
functions are also programmed using Visualization Toolkit (VTK) and compiled
into MEX. These MEX binary library files have been built under 64-bit
Windows and Linux OS system and shipped with MRiLab source code, so
the user should be able to use these files under 64-bit Windows and Linux
without the need of recompiling. However, if these MEX files are incompatible
with your OS system for any reason or if you wish to modify these MEX
files for your own needs, you have to recompile them using the source code.
<br 
class="newline" />
<!--l. 93--><p class="indent" >   Before recompiling these MEX files, some dependent packages are required.
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-5002x1">CMake (required)<br 
class="newline" />The MRiLab uses CMake for cross platform building for these MEX files.<br 
class="newline" />
     <!--l. 99--><p class="noindent" >CMake : <a 
href="http://www.cmake.org/cmake/resources/software.html" class="url" ><span 
class="cmtt-10">http://www.cmake.org/cmake/resources/software.html</span></a> <br 
class="newline" />
     </li>
     <li 
  class="enumerate" id="x3-5004x2">IPP or Framewave (required)<br 
class="newline" />The current MRiLab version uses Intel IPP or AMD Framewave libraries
     for large scale matrix manipulation. Please notice that Intel IPP isn&#8217;t a
     free open source software, however if you are planning to use MRiLab
     IPP version (i), you can download Intel C Studio XE which includes IPP
     distribution and follow Intel&#8217;s non-commercial license for non-commercial

     usage. As an alternative, MRiLab provides Framewave version (f) which
     only uses Framewave libraries. The Framewave is released as a free open
     source library.<br 
class="newline" />
     <!--l. 104--><p class="noindent" >Intel IPP : <a 
href="http://software.intel.com/en-us/intel-ipp" class="url" ><span 
class="cmtt-10">http://software.intel.com/en-us/intel-ipp</span></a> <br 
class="newline" />AMD Framewave : <a 
href="http://framewave.sourceforge.net" class="url" ><span 
class="cmtt-10">http://framewave.sourceforge.net</span></a> <br 
class="newline" />
     </li>
     <li 
  class="enumerate" id="x3-5006x3">CUDA (optional)<br 
class="newline" />A properly installed NVIDIA GPU driver is required for running GPU
     devices and also for MRiLab to interact with GPU devices. The current
     MRiLab version only supports GPU cards which support NVIDIA CUDA
     technique. The libraries from CUDA 5.0 are compiled against for shipped
     MEX files in the MRiLab distribution. <br 
class="newline" />
     <!--l. 110--><p class="noindent" >NVIDIA : <a 
href="http://www.nvidia.com/page/home.html" class="url" ><span 
class="cmtt-10">http://www.nvidia.com/page/home.html</span></a> <br 
class="newline" />CUDA : <a 
href="http://www.nvidia.com/object/cuda_home_new.html" class="url" ><span 
class="cmtt-10">http://www.nvidia.com/object/cuda_home_new.html</span></a> <br 
class="newline" />
     <!--l. 113--><p class="noindent" >Although  the  GPU  acceleration  dramatically  improves  computational
     efficiency  for  MRiLab,  the  GPU  computing  mode  is  also  optional.
     Alternatively, MRiLab provides multi-threading CPU computing mode
     via OpenMP which requires no additional packages on most of today&#8217;s
     operating  system,  but  provides  comparable  computational  efficiency
     compared to GPU mode.
     </li>
     <li 
  class="enumerate" id="x3-5008x4">VTK (optional) <br 
class="newline" />The VTK library is used to effectively render 3D K-Space trajectory and
     complex image object in three-dimensional space. The current MRiLab
     version uses MEX built against VTK 5.10. However, VTK rendering is
     optional since native Matlab rendering is also provided. <br 
class="newline" />
     <!--l. 118--><p class="noindent" >VTK : <a 
href="http://www.vtk.org" class="url" ><span 
class="cmtt-10">http://www.vtk.org</span></a> <br 
class="newline" />
     </li>
     <li 
  class="enumerate" id="x3-5010x5">ISMRMRD (optional) <br 
class="newline" />MRiLab supports data conversion from Matlab variables to ISMRMRD
     which is used as a default data storage format by Gadgetron MRI image
     reconstruction framework. To enable Gadgetron function, the user needs
     to  install  ISMRMRD  dependency  packages  in  order  to  compile  data
     conversion MEX. <br 
class="newline" />
     <!--l. 123--><p class="noindent" >ISMRMRD                                                                                :
     <a 
href="http://ismrmrd.sourceforge.net/#obtaining-and-installing" class="url" ><span 
class="cmtt-10">http://ismrmrd.sourceforge.net/#obtaining-and-installing</span></a>

     </li></ol>
<!--l. 127--><p class="indent" >   After installing above mentioned necessary dependent packages, you also need to
set a few environment variables in your system :
     <ul class="itemize1">
     <li class="itemize">MATLAB_ROOT : Matlab root folder path
     </li>
     <li class="itemize">IPP_ROOT : IPP root folder path if IPP is used
     </li>
     <li class="itemize">FRAMEWAVE_ROOT : Framewave root folder path if Framewave is used</li></ul>
<!--l. 135--><p class="indent" >   Notice that the C source code for these MEX files is under /MRiLab/Lib/src
folder. To compile and install MEX files
<!--l. 137--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-5012x1">Linux Installation <br 
class="newline" />The command line that compiles the MEX files is

     <div class="verbatim" id="verbatim-1">
     mkdir&#x00A0;build
     &#x00A0;<br />cd&#x00A0;build
     &#x00A0;<br />cmake&#x00A0;MRiLab/Lib/src
     &#x00A0;<br />make
     &#x00A0;<br />sudo&#x00A0;make&#x00A0;install
</div>
     <!--l. 146--><p class="nopar" >
     <!--l. 148--><p class="noindent" >You can also use cmake-gui for configuration and other building tools (e.g.
     Eclipse) for building the binaries.
     </li>
     <li 
  class="enumerate" id="x3-5014x2">Windows Installation <br 
class="newline" />It is recommended to use cmake-gui for generating Visual Studio projects, then
     build the projects in Visual Studio.
         <ul class="itemize1">
         <li class="itemize">Step 1 : Locate source folder and build folder in cmake-gui (Figure
         <a 
href="#x3-50151">1.1<!--tex4ht:ref: fig:cmake-gui --></a>) <hr class="figure"><div class="figure" 
><a 
 id="x3-50151"></a>   <img 
src="Pictures/cmake-gui.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;1.1: </span><span  
class="content">The cmake-gui for locating source folder and build folder</span></div><!--tex4ht:label?: x3-50151 -->
         <!--l. 160--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">Step 2 : Configure and generate Visual Studio projects in cmake-gui
         (Figure <a 
href="#x3-50162">1.2<!--tex4ht:ref: fig:cmake-gui2 --></a>) <hr class="figure"><div class="figure" 
><a 
 id="x3-50162"></a>   <img 
src="Pictures/cmake-gui2.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;1.2: </span><span  
class="content">The cmake-gui for configuring and building Visual Studio projects</span></div><!--tex4ht:label?: x3-50162 -->
         <!--l. 167--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">Step 3 : Build the INSTALL project, compiled MEX binaries will
         be copied to MRiLab/Lib/bin folder by default (Figure <a 
href="#x3-50173">1.3<!--tex4ht:ref: fig:visualstudio --></a>) <hr class="figure"><div class="figure" 
><a 
 id="x3-50173"></a>   <img 
src="Pictures/visualstudio.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;1.3: </span><span  
class="content">Build INSTALL project using Visual Studio</span></div><!--tex4ht:label?: x3-50173 -->
         <!--l. 174--><p class="noindent" ></div><hr class="endfigure">
         </li></ul>
     </li></ol>
<!--l. 180--><p class="indent" >   If installation problems do occur to you, feel free to let me know and I may help
you out. For your information, I provide here my development environment (Table
<a 
href="#x3-50181">1.1<!--tex4ht:ref: tab:FangSComputerEnvironment --></a>) for the current MRiLab version.
   <div class="table">

<!--l. 182--><p class="indent" >   <a 
 id="x3-50181"></a><hr class="float"><div class="float" 
>

<div class="tabular"> <table id="TBL-2" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1"><col 
id="TBL-2-2"><col 
id="TBL-2-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-1"  
class="td11">Environment</td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-2"  
class="td11">Desktop                     </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-3"  
class="td11">Laptop                     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-1"  
class="td11">Machine       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-2"  
class="td11">Dell Precision T3500    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-3"  
class="td11">Lenovo Thinkpad R61 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-1"  
class="td11">CPU            </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-2"  
class="td11">Intel Xeon W3530        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-3"  
class="td11">Intel Core2 Duo T8100</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-1"  
class="td11">GPU </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-2"  
class="td11">NVIDIA Quadro 4000 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-3"  
class="td11">Null</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-1"  
class="td11">OS              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-2"  
class="td11">Windows 7 64-bit        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-3"  
class="td11">Linux Fedora 16 64-bit</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-1"  
class="td11">Matlab </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-2"  
class="td11">Matlab R2013a 64-bit </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-3"  
class="td11">Matlab R2012b 64-bit</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-1"  
class="td11">C Compiler   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-2"  
class="td11">Visual Studio 10 Win64</td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-3"  
class="td11">GCC 4.6.3                </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-8-1"  
class="td11">VTK           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-8-2"  
class="td11">VTK 5.10                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-8-3"  
class="td11">VTK 5.10                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-9-1"  
class="td11">CUDA         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-9-2"  
class="td11">CUDA 5.0                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-9-3"  
class="td11">Null                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-10-1"  
class="td11">IPP             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-10-2"  
class="td11">Intel IPP 7.0              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-10-3"  
class="td11">Intel IPP 7.0             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-11-1"  
class="td11">Framewave   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-11-2"  
class="td11">AMD Framewave 1.3    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-11-3"  
class="td11">AMD Framewave 1.3   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-12-1"  
class="td11">           </td></tr></table></div>
<br /> <div class="caption" 
><span class="id">Table&#x00A0;1.1: </span><span  
class="content">Fang&#8217;s Computer Environment</span></div><!--tex4ht:label?: x3-50181 -->

   </div><hr class="endfloat" />
   </div>

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;2</span><br /><a 
 id="x3-60002"></a>Platform Overview</h2>
   <h3 class="sectionHead"><span class="titlemark">2.1   </span> <a 
 id="x3-70002.1"></a>MRiLab Simulation Platform</h3>
<!--l. 207--><p class="noindent" >The MRiLab simulation platform consists of
<!--l. 209--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-7002x1">A Main Simulation Control Console <br 
class="newline" />The  main  simulation  control  console  (Figure  <a 
href="#x3-70031">2.1<!--tex4ht:ref: fig:MainSimulationControlConsole --></a>)  behaves  analogous
     to  a  MR  scanner  console  for  graphically  adjusting  imaging  setup  and
     conducting simulation control. Simulation feedback are instantly updated
     on corresponding information panels during the simulation process.
     <!--l. 213--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-70031"></a>   <img 
src="Pictures/MainSimulationControlConsole.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2.1: </span><span  
class="content">The MRiLab Main Simulation Control Console. This control console
functions like a MR scanner console for graphically adjusting imaging setup and
conducting simulation control.</span></div><!--tex4ht:label?: x3-70031 -->
     <!--l. 218--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-7005x2">Design Toolboxes <br 
class="newline" />The Design toolboxes (Figure <a 
href="#x3-70062">2.2<!--tex4ht:ref: fig:FunctionToolboxes --></a>) provide independent interfaces for designing
     RF pulse (e.g. SLR, non-adiabatic and adiabatic pulse etc.), for constructing
     arbitrary pulse sequence (e.g. SPGR, SSFP and FSE etc.), for configuring coil
     profile and main static magnet field (i.e. B1 and B0 field) and for designing
     imaging object moving track. Dedicated image display and analysis
     tools (SpinWatcher, MatrixUser and arrayShow) are also developed
     and tailored to work with MRiLab simulated high dimensional MR
     images.
     <!--l. 225--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-70062"></a>   <img 
src="Pictures/FunctionToolboxes.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2.2: </span><span  
class="content">The Shortcut for Function Toolbox on Simulation Control Console.
Each icon is associated with an individual toolbox with specific functions.</span></div><!--tex4ht:label?: x3-70062 -->
     <!--l. 230--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-7008x3">Discrete Bloch-equation Solving Kernels <br 
class="newline" />The Bloch-equation solving kernels manipulate tissue spin evolution at small
     discrete time interval in order to accurately simulate spin behavior given a
     desired spin model and MR sequences. These kernels are accelerated
     using Matlab MEX functions that are optimized for running GPU and
     multi-threading CPU parallel computing techniques. Moreover, these kernels
     are also capable of preprocessing acquired MR signal and K-Space locations
     prior to desirable image reconstruction. Further image reconstruction with
     stored K-Space data is accomplished in corresponding reconstruction
     module.

     </li>
     <li 
  class="enumerate" id="x3-7010x4">Macro Library <br 
class="newline" />MRiLab uses a concept of macros for simplifying experiment design. A macro
     in MRiLab is defined as a programming-free module that can be added,
     removed and modified in the process of constructing MR sequence, coil profile,
     magnet field and object moving track, etc. For instance, a Sinc RF pulse
     (rfSinc) is considered as a RF macro that can be used for constructing a
     gradient echo sequence, and the attributes of this macro include pulse starting
     time (tStart), pulse ending time (tEnd) and the time bandwidth product
     (TBP) etc. MRiLab provides a macro library (Figure <a 
href="#x3-70113">2.3<!--tex4ht:ref: fig:RFMacroLibrary --></a>) covering a wide
     range of macros. Using these predefined macros, you should be able to
     accomplish most of experimental design work. However, if special macros are
     needed, MRiLab also provides interfaces to work with user-defined
     macros. More detailed description for macros is provided in Chapter
     <a 
href="#x3-390005">5<!--tex4ht:ref: chap:MRiLabToolboxes --></a>.
     <!--l. 239--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-70113"></a>   <img 
src="Pictures/RFMacroLibrary.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2.3: </span><span  
class="content">The Macro Library Tree Structure in MRiLab. Individual tree nodes
under SeqElem root are functional macros that can be used for designing MR
sequences. Notice that only RF nodes are unfolded here for display purpose.</span></div><!--tex4ht:label?: x3-70113 -->
     <!--l. 244--><p class="noindent" ></div><hr class="endfigure">
     </li></ol>
<!--l. 248--><p class="indent" >   MRiLab applies XML files for storing simulation information, which simplifies
simulation experiment modification across different studies. MRiLab also supports
external plugins programmed using either Matlab or C language for creating
extendable simulation system.
<!--l. 250--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">2.2   </span> <a 
 id="x3-80002.2"></a>Simulation Workflow</h3>
<!--l. 252--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-80014"></a>


<!--l. 254--><p class="noindent" ><img 
src="Pictures/MRiLabWorkflow.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2.4: </span><span  
class="content">MRiLab Workflow Diagram</span></div><!--tex4ht:label?: x3-80014 -->

<!--l. 257--><p class="noindent" ></div><hr class="endfigure">
<!--l. 259--><p class="indent" >   The workflow diagram of MRiLab simulation is shown in Figure <a 
href="#x3-80014">2.4<!--tex4ht:ref: fig:MRiLabWorkflow --></a>. One typical
simulation requires input of :
     <ul class="itemize1">
     <li class="itemize">Virtual object (VObj) with specific tissue properties including Rho (spin
     density), T1 and T2 etc.
     </li>
     <li class="itemize">MR sequence that provides tissue contrast in reconstructed images
     </li>
     <li class="itemize">B1 field for RF transmitting and receiving
     </li>
     <li class="itemize">Gradient field for spatial encoding
     </li>
     <li class="itemize">Magnet field for describing main static field inhomogeneity (dB0)
     </li>
     <li class="itemize">Motion pattern for describing imaging object movement during real time
     simulation</li></ul>
<!--l. 270--><p class="indent" >   All the input information gets configured at the MRiLab main control console
where the user can customize any aspect of a simulation experiment. The main
console preprocesses the input information then translates them into kernel signal,
based on which the discrete solving kernel executes each voxel of imaging objects
with either GPU or multi-threading CPU acceleration. The acquired MR signal and
K-Space data from the kernel then passes to image reconstruction module where
either default recon code or external recon tool (e.g. Gadgetron) is applied. The
reconstructed image can be analyzed using MRiLab image display tools including
:
     <ul class="itemize1">
     <li class="itemize">MatrixUser  :  An  image  display  and  analysis  tool  for  manipulating
     multidimensional matrix
     </li>
     <li class="itemize">SpinWatcher  :  An  analysis  tool  for  analyzing  spin  evolution  behavior
     within a single voxel
     </li>
     <li class="itemize">SARWatcher : An analysis tool for analyzing local spatial SAR distribution
     </li>
     <li class="itemize">arrayShow : A Matlab image viewer for the evaluation of multidimensional
     complex images</li></ul>

   <h3 class="sectionHead"><span class="titlemark">2.3   </span> <a 
 id="x3-90002.3"></a>Gradient Echo: Start A Simple Scan</h3>
<!--l. 281--><p class="noindent" >Up to this point, you may wonder how I can start to use MRiLab for imaging
simulation. Below is a simple 3D Gradient Echo (GRE) simulation example for you
to gain some feelings of using MRiLab.
     <ul class="itemize1">
     <li class="itemize">Open MRiLab by running &#8216;MRiLab.m&#8217; under the root folder. MRiLab will
     try to detect current available CPU and GPU devices, and initialize the
     simulation environment. After initialization (typically in couple seconds),
     MRiLab  Main  Simulation  Control  Console  will  open.  Empty  Axial,
     Sagittal, Coronal and Preview views show up. Notice that on the console,
     several push buttons are disabled at this point, it means more inputs are
     needed for activating them.
     </li>
     <li class="itemize">To simulate images, the virtual object a.k.a. digital phantom is needed. Go
     to &#8216;Load&#8217;, &#8216;Load Phantom Example&#8217;, choose one of the predefined digital
     phantoms for the experiment. A few digital phantoms that are suitable
     for different experiment purposes are already provided. Here, let&#8217;s choose
     &#8216;Brain (Standard Resolution 108x90x90)&#8217;. After loading this phantom, you
     will notice the preview image showing up at the top right corner under
     &#8216;VObj Spin Map&#8217; and the property information of this phantom are also
     shown in &#8216;Virtual Object Property. Let&#8217;s choose T2 map from the pop-up
     menu, and click &#8216;Localizer&#8217; button to show more image details. Now Axial,
     Sagittal and Coronal axes are filled with this 3D digital phantom. <span 
class="cmbx-10">Click</span>
     <span 
class="cmbx-10">&#8216;Update&#8217; button to accept this phantom loading. </span>Notice that after
     updating, all push buttons become enabled.
     </li>
     <li class="itemize">Since we want to simulate 3D GRE experiment, we need to load 3D GRE
     sequence first. Click the &#8216;Sequence&#8217; button located at the center portion
     of the console. A SeqList will open where you can choose and load MR
     sequences.  Let&#8217;s  click  &#8216;Dimension&#8217;  pop-up  menu  and  choose  &#8216;3D&#8217;.  The
     Category list shows a full list of current available sequence type. Click
     &#8216;GradientEcho&#8217;, then click &#8216;PSD_GRE3D&#8217; from the Sequence list. Click
     &#8216;Accept&#8217; button to accept and load a 3D GRE sequence. Notice that the
     &#8216;Simulation Settings&#8217; tabs on the console update and change to the setting
     for the current GRE sequence. <span 
class="cmbx-10">Click &#8216;Update&#8217; button to accept this</span>
     <span 
class="cmbx-10">sequence loading.</span>
     </li>
     <li class="itemize">Under the &#8216;Imaging&#8217; tab, there are several parameters for imaging control,
     for instance, Field-of-View in the frequency encoding direction (FOVFreq).
     We can simply accept the default setting at this moment, however, if you
     do make any changes, <span 
class="cmbx-10">you need to click &#8216;Update&#8217; button to update</span>
     <span 
class="cmbx-10">those changes before proceeding to Scan.</span>

     </li>
     <li class="itemize">The final step is to click &#8216;Scan&#8217; button and wait for the simulation to
     be performed. Depending on imaging setting and computing hardware,
     typically  the  simulation  will  finish  in  a  short  period  of  time,  the
     reconstructed image will be shown in the &#8216;Preview&#8217; view.</li></ul>
<!--l. 291--><p class="indent" >   The final looks of this 3D GRE experiment should be somewhat similar to this
(Figure <a 
href="#x3-90015">2.5<!--tex4ht:ref: fig:3DGRESampleScan --></a>).
<!--l. 294--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-90015"></a>


<!--l. 296--><p class="noindent" ><img 
src="Pictures/3DGRESampleScan.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2.5: </span><span  
class="content">The Final Simulation Result for A 3D GRE Experiment</span></div><!--tex4ht:label?: x3-90015 -->

<!--l. 299--><p class="indent" >   </div><hr class="endfigure">
<!--l. 301--><p class="indent" >   If you managed to simulate this gradient echo image, congratulations! You have
successfully performed your first MRiLab experiment. So you should be prepared for
deeper understanding of MRiLab simulation platform by following the rest of this
user guide.

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;3</span><br /><a 
 id="x3-100003"></a>Simulation Settings</h2>
   <h3 class="sectionHead"><span class="titlemark">3.1   </span> <a 
 id="x3-110003.1"></a>Loading Virtual Object</h3>
<!--l. 308--><p class="noindent" >Prior to perform any type of simulation in MRiLab, a virtual object has to be
loaded first. To load virtual object, go to menu &#8216;Load&#8217; and &#8216;Load Phantom&#8217;
to load a user customized phantom or &#8216;Load Phantom Example&#8217; to load
MRiLab default phantoms. MRiLab provides a few digital phantoms with MR
properties mimicking several human tissue types (e.g. Brain, Cartilage, Fat,
etc.). After a virtual object being successfully loaded, the geometry of this
phantom will show as a preview thumbnail at the top right corner of the
console (Figure <a 
href="#x3-110011">3.1<!--tex4ht:ref: fig:VirtualObjectChecking --></a>). The user can inspect phantom property maps of T1,
T2 and Rho etc. using the pop-up menu above the thumbnail. If multiple
spin species exist in the phantom, the user can also inspect different spin
type by using &#8216;Spin Type&#8217; pop-up menu below the thumbnail. Moreover, a
complete list of phantom property of the virtual object is provided at the
&#8216;Virtual Object Property&#8217; list, the user can check any of them by clicking the
corresponding item. A complete property list of one virtual object typically
include:
     <ul class="itemize1">
     <li class="itemize">Gyro (rad/s/T) : The gyromagnetic ratio of the spin
     </li>
     <li class="itemize">ChemShift (Hz/T) : The chemical shift of the spin
     </li>
     <li class="itemize">XDim : The number of voxels in X direction
     </li>
     <li class="itemize">YDim : The number of voxels in Y direction
     </li>
     <li class="itemize">ZDim : The number of voxels in Z direction
     </li>
     <li class="itemize">XDimRes (m) : The voxel size in X direction
     </li>
     <li class="itemize">YDimRes (m) : The voxel size in Y direction
     </li>
     <li class="itemize">ZDimRes (m) : The voxel size in Z direction
     </li>
     <li class="itemize">Type : A description of the type of the spin
     </li>
     <li class="itemize">TypeNum : The number of spin species

     </li>
     <li class="itemize">Rho : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum </span>for
     describing spin density
     </li>
     <li class="itemize">T1 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum</span>
     for describing T1 relaxation time
     </li>
     <li class="itemize">T2 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum</span>
     for describing T2 relaxation time
     </li>
     <li class="itemize">T2Star (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
     for describing T2* relaxation time</li></ul>
<!--l. 327--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-110011"></a>


<!--l. 329--><p class="noindent" ><img 
src="Pictures/VirtualObjectChecking.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3.1: </span><span  
class="content">A Virtual Object Preview</span></div><!--tex4ht:label?: x3-110011 -->

<!--l. 332--><p class="indent" >   </div><hr class="endfigure">
<!--l. 334--><p class="indent" >   To inspect more details of the digital phantom, press the &#8216;Localizer&#8217; button to
populate the thumbnail to the main image display panel. MRiLab provides three
image axes to display axial, sagittal and coronal view section of the three dimensional
virtual object, respectively. A scroll bar beside each axes allows to change image slice
along the corresponding direction, which serves as an anatomical reference for
prescribing simulation parameters. For instance, the location of a green box in each
axes indicating current field of view can be adjusted via free hand dragging, and the
field of view location is instantly updated at &#8216;Field of View&#8217; panel upon
dragging.
   <h3 class="sectionHead"><span class="titlemark">3.2   </span> <a 
 id="x3-120003.2"></a>Loading Sequence</h3>
<!--l. 337--><p class="noindent" >One of the key features of MRiLab is allowing simulating a wide range of
MR sequences and facilitating investigation and optimization of desirable
MR contrast among different tissues. MRiLab provides a sequence loading
interface allowing users to choose predefined sequences from default MRiLab
sequence library, or choose other user customized sequences. MRiLab parses a
selected MR sequence and translates the sequence waveform into specific signal
which triggers simulation kernel execution. The sequence loading interface
provides functions to load MR sequence. A MR sequence design toolbox is
separate from loading interface and will be explained in detail in Chapter
<a 
href="#x3-390005">5<!--tex4ht:ref: chap:MRiLabToolboxes --></a>.
<!--l. 339--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.2.1   </span> <a 
 id="x3-130003.2.1"></a>Loading Predefined Sequence</h4>
<!--l. 341--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-130012"></a>


<!--l. 343--><p class="noindent" ><img 
src="Pictures/SequenceLoading.png" alt="pict"  
>
<br />               <div class="caption" 
><span class="id">Figure&#x00A0;3.2:                        </span><span  
class="content">The                        Sequence
Loading Interface. A sequence named PSD_FIESTA3D from 3D GradientEcho
Category is chosen, and DummyPulse special technique is checked by default.</span></div><!--tex4ht:label?: x3-130012 -->

<!--l. 346--><p class="noindent" ></div><hr class="endfigure">
<!--l. 348--><p class="indent" >   To open a sequence loading interface (Figure <a 
href="#x3-130012">3.2<!--tex4ht:ref: fig:SequenceLoading --></a>), click the &#8216;Sequence&#8217; button
located at the center portion of the main control console. Once the interface is open,
the &#8216;Dimension&#8217; specifies the sequence spatial encoding scheme (2D or 3D). The
&#8216;Category&#8217; provides a list of sequence classes including Gradient Echo, Spin Echo,
Inversion Recovery, Fast Spin Echo, Others and User. Upon clicking one sequence
category, a few sequences belonging to the selected category become available in the
sequence list on the right. Click a sequence, then press &#8216;Accept&#8217; to load the selected
sequence. pressing &#8216;Cancel&#8217; button will close the interface without loading any
sequence. <br 
class="newline" />
<!--l. 350--><p class="indent" >   Notice there is a &#8216;Special Technique (SpecialTech)&#8217; panel below the sequence list.
If a sequence using any of special techniques is selected, the corresponding
checkboxes beside the special techniques will be chosen. For example, by default
PSD_FIESTA3D uses the special techniques called DummyPulse, therefore, by
clicking PSD_FIESTA3D, the DummyPulse will be chosen accordingly. However, you
can uncheck the checkbox for avoiding the DummyPulse module, but this may cause
incomplete simulation for PSD_FIESTA3D. It is recommended to keep default
selection of special techniques therefore a complete sequence control is preserved for
those default sequences. On the other hand, for the sequences that have no special
techniques, you can also add special technique module by checking corresponding
checkbox. This will load parameter tabs of special techniques on the simulation
control console for configuration purpose. The special technique strategy
enables the ability for reusing &#8216;capsulized&#8217; module for different sequences.
<br 
class="newline" />
<!--l. 352--><p class="indent" >   MRiLab provides a few default sequences under the folder /PSD, notice the /PSD
folder uses the same hierarchic structure scheme as that of the loading interface.
Typically a new sequence can be located anywhere in the computer, however it is
recommended to save the sequence under those predefined categories under /PSD
therefore they are visible to the loading interface. However, if a customized sequence
is not directly visible to the loading interface, it can also be loaded using the PSD
loading button marked as &#8216;o&#8217; at the bottom of the loading interface. If the
PSD loading button is used, loading interface will ignore regular sequence
selection.
   <h4 class="subsectionHead"><span class="titlemark">3.2.2   </span> <a 
 id="x3-140003.2.2"></a>Predefined Sequences</h4>
<!--l. 355--><p class="noindent" >MRiLab provides a few predefined MR sequences including
<!--l. 357--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-14002x1">Fast Spin Echo
         <ul class="itemize1">

         <li class="itemize">PSD_FSE3D <br 
class="newline" />Three  dimensional  multishot  Fast  Spin  Echo  (FSE)  sequence
         with  interleaved  K-Space  sampling  in  Kx-Ky  and  conventional
         phase-encoding along Kz.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-14004x2">Gradient Echo
         <ul class="itemize1">
         <li class="itemize">PSD_FIESTA3D <br 
class="newline" />Three dimensional balanced Steady State Free Precession (bSSFP)
         sequence.
         </li>
         <li class="itemize">PSD_SPGR3D <br 
class="newline" />Three dimensional Spoiled Gradient Echo (SPGR) sequence.
         </li>
         <li class="itemize">PSD_GRE3D <br 
class="newline" />Three dimensional gradient echo sequence with Cartesian readout.
         </li>
         <li class="itemize">PSD_GRE3DEPI <br 
class="newline" />Three  dimensional  gradient  echo  sequence  with  multishot  Echo
         Planar Imaging (EPI) readout using interleaved K-Space sampling in
         Kx-Ky and conventional phase-encoding along Kz.
         </li>
         <li class="itemize">PSD_GRE3DRadial <br 
class="newline" />Three  dimensional  gradient  echo  sequence  with  radial  readout  in
         Kx-Ky and conventional phase-encoding along Kz, usually referred
         to as stack-of-stars sequence.
         </li>
         <li class="itemize">PSD_GRE3DSpiral <br 
class="newline" />Three  dimensional  gradient  echo  sequence  with  multishot  spiral
         readout in Kx-Ky and conventional phase-encoding along Kz, referred
         to as stack-of-spiral sequence.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-14006x3">Inversion Recovery
         <ul class="itemize1">
         <li class="itemize">PSD_IR3D <br 
class="newline" />Three dimensional Inversion Recovery (IR) sequence with Cartesian
         readout.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-14008x4">SpinEcho

         <ul class="itemize1">
         <li class="itemize">PSD_SE3D <br 
class="newline" />Three dimensional Spin Echo (SE) sequence with Cartesian readout.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-14010x5">User
         <ul class="itemize1">
         <li class="itemize">PSD_SPGR3DMT <br 
class="newline" />Three  dimensional  SPGR  sequence  with  Magnetization  Transfer
         (MT) saturation. Note that MT phantom is needed for running this
         sequence.
         </li>
         <li class="itemize">PSD_SPGR3DME <br 
class="newline" />Three dimensional SPGR sequence for Multiple spin pool exchange
         (ME)  model.  Note  that  ME  phantom  is  needed  for  running  this
         sequence.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-14012x6">Others
         <ul class="itemize1">
         <li class="itemize">PSD_AFI <br 
class="newline" />Three dimensional SPGR sequence for performing flip angle mapping
         using Actual Flip Angle Imaging (AFI) technique <span class="cite">[<a 
href="#XYarnykh2007">1</a>]</span>.</li></ul>
     </li></ol>
<!--l. 411--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.3   </span> <a 
 id="x3-150003.3"></a>Loading Coil</h3>
<!--l. 412--><p class="noindent" >To simulate multi-transmitting and receiving coil, MRiLab provides a coil loading
interface allowing to choose different coil configurations for Tx (i.e. Transmitting)
and/or Rx (i.e. Receiving). MRiLab translates the coil configuration and
computes a B1+/B1- field accordingly. For multi-transmitting coil, each coil
element could be treated separately and receives individual RF signal source.
This allows to investigate B1 shimming and multiple RF excitation etc. For
multi-receiving coil, each coil element also connects to an individual signal channel
and produces signal according to its specific coil sensitivity. This allows to
investigate coil encoding methods such as parallel imaging. The coil loading
interface provides functions to load coil configuration. A coil design toolbox is
separate from loading interface and will be explained in detail in Chapter
<a 
href="#x3-390005">5<!--tex4ht:ref: chap:MRiLabToolboxes --></a>.

<!--l. 414--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.3.1   </span> <a 
 id="x3-160003.3.1"></a>Loading Predefined Coil</h4>
<!--l. 416--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-160013"></a>


<!--l. 418--><p class="noindent" ><img 
src="Pictures/CoilLoading.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3.3: </span><span  
class="content">The Coil Loading Interface. An eight channel coil configuration
named Coil_8ChHead from Head Category is chosen, preview image shows the
total coil sensitivity with the same spatial resolution as that of the chosen digital
phantom.</span></div><!--tex4ht:label?: x3-160013 -->

<!--l. 421--><p class="noindent" ></div><hr class="endfigure">
<!--l. 423--><p class="indent" >   To open a coil loading interface (Figure <a 
href="#x3-160013">3.3<!--tex4ht:ref: fig:CoilLoading --></a>), click the &#8216;Coil&#8217; button located at the
center portion of the console. The &#8216;Category&#8217; list specifies different coil configuration
category based on anatomical structure. The &#8216;Coils&#8217; list beside the &#8216;Category&#8217; list
provides coil configuration belonging to the selected category. Upon clicking a coil
configuration, the interface will calculate the coil sensitivity map and display it in the
preview axes. The user can specify displaying spatial resolution using the &#8216;Precision&#8217;
with a highest spatial resolution defined as the same resolution of digital phantom.
Moreover, the user can specify color map from &#8216;Jet&#8217;,&#8216;Gray&#8217; or &#8216;Hot&#8217;. Pressing &#8216;Accept&#8217;
will load the selected coil configuration. However, pressing &#8216;Cancel&#8217; button will
close the interface without loading any coil configuration. If an uniform unit
coil sensitivity is desired, press &#8216;Uniform&#8217; button to load that. By default,
MRiLab uses an uniform unit coil sensitivity for both RF transmitting and
receiving. To indicate an usage of the selected coil configuration, the user has
to specify &#8216;Coil Type&#8217; as either Tx for transmitting or Rx for receiving.
<br 
class="newline" />
<!--l. 425--><p class="indent" >   MRiLab provides a few default coil configuration under the folder /Coil, notice
the /Coil folder uses the same hierarchic structure scheme as that of the loading
interface. Typically a new coil configuration can be located anywhere in the
computer, however it is recommended to save the coil configuration folder under
those predefined categories under /Coil therefore they are visible to the loading
interface. However, if a customized coil configuration is not directly visible to the
loading interface, it can also be loaded using the Coil loading button marked as &#8216;o&#8217; at
the bottom of the loading interface. If the Coil loading button is used, loading
interface will ignore regular coil selection.
   <h4 class="subsectionHead"><span class="titlemark">3.3.2   </span> <a 
 id="x3-170003.3.2"></a>Predefined Coil</h4>
<!--l. 429--><p class="noindent" >MRiLab provides a few predefined coil configuration including
<!--l. 431--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-17002x1">Head
         <ul class="itemize1">
         <li class="itemize">Coil_1ChHead <br 
class="newline" />A coil configuration consists of one single Biot-Savart circle, primarily
         used for testing purpose.
         </li>
         <li class="itemize">Coil_8ChHead <br 
class="newline" />A coil configuration consists of 8 Biot-Savart circles, which produces
         relative flat B1 field in X-Y plane along X direction.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-17004x2">Chest

         <ul class="itemize1">
         <li class="itemize">Coil_9ChSurfChest <br 
class="newline" />A coil configuration consists of 9 Biot-Savart circles, which produces
         relative flat B1 field in X-Y plane along Y direction at the surface
         region.</li></ul>
     </li></ol>
<!--l. 448--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.4   </span> <a 
 id="x3-180003.4"></a>Loading Magnet</h3>
<!--l. 450--><p class="noindent" >MR simulation studies may need to use non-uniform magnetic field. Those
studies include the ones for investigating susceptibility artifact, and developing
less field inhomogeneity sensitive sequences. MRiLab provides the magnet
loading interface allowing to load customized B0 field inhomogeneity map (i.e.
dB0 map, a map for indicating main field variation). The magnet loading
interface provides functions to load dB0 map. A magnet design toolbox is
separate from loading interface and will be explained in detail in Chapter
<a 
href="#x3-390005">5<!--tex4ht:ref: chap:MRiLabToolboxes --></a>.
<!--l. 452--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.4.1   </span> <a 
 id="x3-190003.4.1"></a>Loading Predefined Magnet</h4>
<!--l. 454--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-190014"></a>


<!--l. 456--><p class="noindent" ><img 
src="Pictures/MagnetLoading.png" alt="pict"  
>
<br />                <div class="caption" 
><span class="id">Figure&#x00A0;3.4:                         </span><span  
class="content">The                         Magnet
Loading Interface. A magnet named Mag_GaussianHead from Head Category
is chosen, preview image shows the dB0 map in the X-Y plane with the same
spatial resolution as that of the chosen digital phantom.</span></div><!--tex4ht:label?: x3-190014 -->

<!--l. 459--><p class="noindent" ></div><hr class="endfigure">
<!--l. 461--><p class="indent" >   To open a magnet loading interface (Figure <a 
href="#x3-190014">3.4<!--tex4ht:ref: fig:MagnetLoading --></a>), click the &#8216;Magnet&#8217; button
located at the center portion of the console. The &#8216;Category&#8217; list specifies different
magnet category based on anatomical structure. The &#8216;Magnet&#8217; list beside the
&#8216;Category&#8217; list provides magnet belonging to the selected category. Upon clicking a
magnet file, the interface will compute a dB0 map and display it in the preview axes.
Pressing &#8216;Accept&#8217; will load the chosen magnet profile. However, pressing
&#8216;Cancel&#8217; button will close the interface without loading any profile. If an
uniform B0 field (i.e. zero dB0) is desired, press &#8216;Uniform&#8217; button to load
that. By default, MRiLab uses an uniform B0 field for simulation. That
is to say there is no field inhomogeneity across the entire virtual object.
<br 
class="newline" />
<!--l. 463--><p class="indent" >   MRiLab provides a few default magnet profile under the folder /Mag, notice the
/Mag folder uses the same hierarchic structure scheme as that of the loading
interface. Typically a new magnet profile can be located anywhere in the computer,
however it is recommended to save the magnet profile folder under those predefined
categories under /Mag therefore they are visible to the loading interface. However, if
a customized magnet is not directly visible to the loading interface, it can also be
loaded using the Magnet loading button marked as &#8216;o&#8217; at the bottom of the loading
interface. If the loading button is used, loading interface will ignore regular magnet
selection.
   <h4 class="subsectionHead"><span class="titlemark">3.4.2   </span> <a 
 id="x3-200003.4.2"></a>Predefined Magnet</h4>
<!--l. 467--><p class="noindent" >MRiLab provides two predefined magnet configuration including
<!--l. 469--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-20002x1">Head
         <ul class="itemize1">
         <li class="itemize">Mag_GaussianHead <br 
class="newline" />A magnet profile produces a Gaussian dB0 field in three dimensional
         space.
         </li>
         <li class="itemize">Mag_LinearHead <br 
class="newline" />A magnet profile produces a linear dB0 field in three dimensional
         space.</li></ul>
     </li></ol>
<!--l. 480--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.5   </span> <a 
 id="x3-210003.5"></a>Loading Gradient</h3>

<!--l. 481--><p class="noindent" >Regular MR spatial encoding is performed in a linear (flat) fashion. However
encoding in a nonlinear (curved) fashion may serve particular purposes in some MR
studies. MRiLab provides a gradient loading interface to load customized 3D
nonlinear gradient field. This function can help investigate arbitrary curved gradient
field for imaging simulation. Benefit from MRiLab&#8217;s powerful functionality of MR
sequence design, nonlinear gradient encoding techniques such as PatLoc can be
simulated with minimal efforts in MRiLab. The gradient loading interface
provides functions to load nonlinear gradient. A gradient design toolbox is
separate from the loading interface and will be explained in detail in Chapter
<a 
href="#x3-390005">5<!--tex4ht:ref: chap:MRiLabToolboxes --></a>.
<!--l. 483--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.5.1   </span> <a 
 id="x3-220003.5.1"></a>Loading Predefined Gradient</h4>
<!--l. 485--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-220015"></a>


<!--l. 487--><p class="noindent" ><img 
src="Pictures/GradientLoading.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3.5:  </span><span  
class="content">The  Gradient  Loading  Interface.  A  gradient  profile  named
Grad_LinearHead from Head Category is chosen.</span></div><!--tex4ht:label?: x3-220015 -->

<!--l. 490--><p class="noindent" ></div><hr class="endfigure">
<!--l. 492--><p class="indent" >   To open a gradient loading interface (Figure <a 
href="#x3-220015">3.5<!--tex4ht:ref: fig:GradientLoading --></a>), click the &#8216;Gradient&#8217; button
located at the center portion of the console. The &#8216;Category&#8217; list specifies different
gradient category based on the anatomical structure. The &#8216;Gradient&#8217; list beside the
&#8216;Category&#8217; list provides gradient profile belonging to the selected category. Upon
clicking a gradient configuration, pressing &#8216;Accept&#8217; will load the selected gradient
profile. However, pressing &#8216;Cancel&#8217; button will close the interface without loading
any gradient profile. If a constant unit gradient is desired, press &#8216;Constant
Unit&#8217; button to load that. By default, MRiLab uses a constant unit gradient
profile in the X, Y and Z direction for a typical gradient simulation. This will
maintain a conventional linear spatial encoding in all three spatial dimensions.
<br 
class="newline" />
<!--l. 494--><p class="indent" >   MRiLab provides gradient profiles under the folder /Grad, notice the /Grad
folder uses the same hierarchic structure scheme as that of the loading interface.
Typically a new gradient profile can be located anywhere in the computer, however it
is recommended to save the gradient profile under those predefined categories under
/Grad therefore they are visible to the loading interface. However, if a customized
gradient is not directly visible to the loading interface, it can also be loaded using the
Gradient loading button marked as &#8216;o&#8217; at the bottom of the loading interface. If the
Gradient loading button is used, loading interface will ignore regular gradient
selection.
   <h4 class="subsectionHead"><span class="titlemark">3.5.2   </span> <a 
 id="x3-230003.5.2"></a>Predefined Gradient</h4>
<!--l. 498--><p class="noindent" >MRiLab provides one predefined example of gradient profile
<!--l. 500--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-23002x1">Head
         <ul class="itemize1">
         <li class="itemize">Grad_LinearHead <br 
class="newline" />A  gradient  profile  produces  constant  gradient  field  with  varying
         gradient   value   in   three   dimensions,   which   can   cause   image
         contraction, expansion or shearing etc.</li></ul>
     </li></ol>
<!--l. 509--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.6   </span> <a 
 id="x3-240003.6"></a>Loading Motion</h3>
<!--l. 510--><p class="noindent" >MRiLab provides a motion simulation mechanism which implements simulating
imaging object movement in three dimensional space. MRiLab&#8217;s Motion simulation
introduces an approach for simulating four dimensional imaging (3D space + time)

techniques such as k-t blast and enables developing real time image reconstruction
algorithms. It also helps investigate motion insensitive sequence and test motion
artifact in various types of sequences and conditions. The motion loading interface
provides functions to load motion trajectory. A motion design toolbox is separate
from the loading interface and will be used for designing motion pattern in three
dimensional space.
<!--l. 513--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.6.1   </span> <a 
 id="x3-250003.6.1"></a>Loading Predefined Motion</h4>
<!--l. 515--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-250016"></a>


<!--l. 517--><p class="noindent" ><img 
src="Pictures/MotionLoading.png" alt="pict"  
>
<br />  <div class="caption" 
><span class="id">Figure&#x00A0;3.6:   </span><span  
class="content">The   Motion   Loading   Interface.   A   motion   profile   named
Mot_RotateHead  from  Head  Category  is  chosen.  This  motion  profile  create
object rotation in three dimensions along any user defined axis.</span></div><!--tex4ht:label?: x3-250016 -->

<!--l. 520--><p class="noindent" ></div><hr class="endfigure">
<!--l. 522--><p class="indent" >   To open a motion loading interface (Figure <a 
href="#x3-250016">3.6<!--tex4ht:ref: fig:MotionLoading --></a>), click the &#8216;Motion&#8217; button located
at the center portion of the console. The &#8216;Category&#8217; list specifies different motion
category based on the anatomical structure. The &#8216;Motion&#8217; list beside the &#8216;Category&#8217;
list provides motion profile belonging to the selected category. Upon clicking a
motion pattern, pressing &#8216;Accept&#8217; will load the chosen motion profile. However,
pressing &#8216;Cancel&#8217; button will close the interface without loading any motion profile. If
motion isn&#8217;t desirable, press &#8216;Stationary&#8217; button. By default, no motion is used in
MRiLab simulation. <br 
class="newline" />
<!--l. 524--><p class="indent" >   MRiLab provides motion profiles under the folder /Mot, notice the /Mot folder
uses the same hierarchic structure scheme as that of the loading interface. Typically a
new motion profile can be located anywhere in the computer, however it is
recommended to save the motion profile under those predefined categories under
/Mot therefore they are visible to the loading interface. However, if a customized
motion is not directly visible to the loading interface, it can also be loaded using the
Motion loading button marked as &#8216;o&#8217; at the bottom of the loading interface. If the
Motion loading button is used, loading interface will ignore regular motion
selection.
   <h4 class="subsectionHead"><span class="titlemark">3.6.2   </span> <a 
 id="x3-260003.6.2"></a>Predefined Motion</h4>
<!--l. 528--><p class="noindent" >MRiLab provides two predefined examples of motion profile
<!--l. 530--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-26002x1">Head
         <ul class="itemize1">
         <li class="itemize">Mot_RotateHead <br 
class="newline" />A motion profile produces object rotation in three dimensional space
         along any user defined axis.
         </li>
         <li class="itemize">Mot_ShiftHead <br 
class="newline" />A  motion  profile  produces  object  translation  in  any  user  defined
         direction.</li></ul>
     </li></ol>
<!--l. 540--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.7   </span> <a 
 id="x3-270003.7"></a>Prescribing Scan Parameters</h3>
<!--l. 542--><p class="noindent" >Those loading interfaces offer a mechanism to interpret and convert configuration file
into MRiLab parameters. With a successful loading, the &#8216;Coil Selection&#8217;,
&#8216;Magnet Selection&#8217;,&#8216;Gradient Selection&#8217; and &#8216;Motion Selection&#8217; fields indicate

the current selected configuration. The user can change the configuration
by reloading a new configuration file with above mentioned steps. If any
of these fields are empty, a default setting will be used. Similar to a real
scanner system, MRiLab categorizes scanning parameters into different groups
and present them under different tabs in the &#8216;Simulation Settings&#8217; panel
(Figure <a 
href="#x3-270017">3.7<!--tex4ht:ref: fig:SimulationSettings --></a>). There are five tabs which are included in all MR sequences,
including Imaging, Advanced, Hardware, Recon and CVs. Additional tabs
for special techniques will also become valid if those techniques are loaded
from sequence selection. Below are detailed explanation for each of those
parameters.
<!--l. 544--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-270017"></a>


<!--l. 546--><p class="noindent" ><img 
src="Pictures/SimulationSettings.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3.7:  </span><span  
class="content">The  Simulation  Settings  Panel.  The  panel  contains  Imaging,
Advanced, Hardware, Recon and CVs tabs, two additional special technique
DummyPulse and MT are also added for this sequence.</span></div><!--tex4ht:label?: x3-270017 -->

<!--l. 549--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">3.8   </span> <a 
 id="x3-280003.8"></a>Parameter List</h3>
<!--l. 553--><p class="noindent" >Below are a full list of supported simulation parameters in current MRiLab version.
Notice that unless otherwise specified, MRiLab uses International System of Units
(i.e. SI units) for all the parameters.
<!--l. 555--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.8.1   </span> <a 
 id="x3-290003.8.1"></a>Imaging</h4>
<!--l. 556--><p class="noindent" >The &#8216;Imaging&#8217; tab contains parameters relevant to image resolution, field of view and
timing setting etc.
     <ul class="itemize1">
     <li class="itemize">BandWidth (Hz) : Full receiver bandwidth
     </li>
     <li class="itemize">FOVFreq (m) : Field of view in the frequency encoding direction
     </li>
     <li class="itemize">FOVPhase (m) : Field of view in the first phase encoding direction
     </li>
     <li class="itemize">FlipAng (Degree) : Flip angle of excitation pulse
     </li>
     <li class="itemize">FreqDir : Frequency encoding direction
     </li>
     <li class="itemize">ResFreq : Number of voxels in frequency encoding direction
     </li>
     <li class="itemize">ResPhase : Number of voxels in the first phase encoding direction
     </li>
     <li class="itemize">ScanPlane : The scanning plane
     </li>
     <li class="itemize">SliceNum : The number of encoding slice
     </li>
     <li class="itemize">SliceThick (m) : The thickness of one slice
     </li>
     <li class="itemize">TE (s) : The time of echo
     </li>
     <li class="itemize">TEPerTR : The number of echoes in multiple echo mode, using a number
     above one requires &#8216;MultiEcho&#8217; tab to be loaded

     </li>
     <li class="itemize">TR (s) : The time of repetition</li></ul>
<!--l. 573--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.8.2   </span> <a 
 id="x3-300003.8.2"></a>Advanced</h4>
<!--l. 574--><p class="noindent" >The &#8216;Advanced&#8217; tab contains other imaging parameters.
     <ul class="itemize1">
     <li class="itemize">MasterTxCoil : The master transmitting coil in multi RF transmitting
     mode
     </li>
     <li class="itemize">MultiTransmit : The flag for turning on and off multi RF transmitting
     mode, default mode is &#8216;off&#8217; for single RF transmitting
     </li>
     <li class="itemize">NEX : The number of excitation
     </li>
     <li class="itemize">NoFreqAlias  :  The  flag  for  avoiding  aliasing  in  frequency  encoding
     direction, default &#8216;on&#8217; truncates object outside field of view in frequency
     encoding direction
     </li>
     <li class="itemize">NoPhaseAlias : The flag for avoiding aliasing in the first phase encoding
     direction, default &#8216;on&#8217; truncates object outside field of view in the first
     phase encoding direction
     </li>
     <li class="itemize">NoSliceAlias : The flag for avoiding aliasing in the second phase encoding
     (i.e. slice encoding) direction, default &#8216;on&#8217; truncates object outside field of
     view in slice encoding direction
     </li>
     <li class="itemize">Shim : The flag for choosing shimming mode
     </li>
     <li class="itemize">TEAnchor : The flag for choosing TE time offset regarding the RF pulse
     width</li></ul>
<!--l. 586--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.8.3   </span> <a 
 id="x3-310003.8.3"></a>Hardware</h4>
<!--l. 587--><p class="noindent" >The &#8216;Hardware&#8217; tab contains parameters relevant to system hardware setup.
     <ul class="itemize1">
     <li class="itemize">B0 (T) : Main static magnetic field strength

     </li>
     <li class="itemize">B1Level  (T)  :  A  reference  B1  field  strength  which  produces  nominal
     prescribed flip angle
     </li>
     <li class="itemize">MaxGrad (T/m) : Maximum allowable gradient strength
     </li>
     <li class="itemize">MaxSlewRate (T/m/s) : Maximum allowable gradient slew rate
     </li>
     <li class="itemize">MinUpdRate (s) : Minimum update time on generating sequence waveform
     </li>
     <li class="itemize">Model : A real scanner system with the possibly most similar hardware
     setting
     </li>
     <li class="itemize">NoiseLevel : The level of adjustable noise, the higher the number, the more
     noise
     </li>
     <li class="itemize">SpinPerVoxel : The number of spins in each voxel, default one spin per
     voxel will treat T2* equal to T2, use a number above one for simulating
     T2* effect (time consuming)</li></ul>
<!--l. 599--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.8.4   </span> <a 
 id="x3-320003.8.4"></a>Recon</h4>
<!--l. 600--><p class="noindent" >The &#8216;Recon&#8217; tab contains parameters relevant to image reconstruction.
     <ul class="itemize1">
     <li class="itemize">AutoRecon   :   The   flag   for   turning   on   and   off   automatic   image
     reconstruction after MR signal acquisition
     </li>
     <li class="itemize">ExternalEng : The name of a user defined script for image reconstruction
     </li>
     <li class="itemize">OutputType : The type of output data including both simulated image
     and signal, options include &#8216;MAT&#8217; and &#8216;ISMRMRD&#8217;, the latter requires
     ISMRMRD dependency packages to be installed
     </li>
     <li class="itemize">ReconEng  :  The  image  reconstruction  engine,  choosing  &#8216;Default&#8217;  uses
     MRiLab  default  reconstruction  code,  choosing  &#8216;External&#8217;  uses  external
     engine which requires ExternalEng to be provided

     </li>
     <li class="itemize">ReconType : The type of image reconstruction</li></ul>
<!--l. 609--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.8.5   </span> <a 
 id="x3-330003.8.5"></a>CVs</h4>
<!--l. 610--><p class="noindent" >The &#8216;CVs&#8217; tab contains Controllable Variables (CV) which exist in the global scope
of sequence design. They are designed for conveniently transferring values
among multiple MR sequence modules. The user can use them for customized
purpose.
     <ul class="itemize1">
     <li class="itemize">CV1 : Controllable variable 1
     </li>
     <li class="itemize">CV2 : Controllable variable 2
     </li>
     <li class="itemize">CV3 : Controllable variable 3
     </li>
     <li class="itemize">CV4 : Controllable variable 4
     </li>
     <li class="itemize">CV5 : Controllable variable 5
     </li>
     <li class="itemize">CV6 : Controllable variable 6
     </li>
     <li class="itemize">CV7 : Controllable variable 7
     </li>
     <li class="itemize">CV8 : Controllable variable 8
     </li>
     <li class="itemize">CV9 : Controllable variable 9
     </li>
     <li class="itemize">CV10 : Controllable variable 10
     </li>
     <li class="itemize">CV11 : Controllable variable 11
     </li>
     <li class="itemize">CV12 : Controllable variable 12
     </li>
     <li class="itemize">CV13 : Controllable variable 13

     </li>
     <li class="itemize">CV14 : Controllable variable 14</li></ul>
<!--l. 628--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.8.6   </span> <a 
 id="x3-340003.8.6"></a>SpecialTech</h4>
<!--l. 630--><p class="noindent" >The Special Technique (SpecialTech) contains multiple tabs from which one or more
are loaded based on sequence configuration and user choice.
<!--l. 632--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-34002x1">DummyPulse <br 
class="newline" />The &#8216;DummyPulse&#8217; tab are designed for adding dummy pulse section before
     image acquisition section. It can be used for skipping transient steady state
     signal.
         <ul class="itemize1">
         <li class="itemize">DP_Flag : The flag for turning on and off dummy pulse
         </li>
         <li class="itemize">DP_FlipAng (Degree) : The flip angle of excitation pulse for dummy
         pulse
         </li>
         <li class="itemize">DP_Num : The number of TRs for dummy pulse
         </li>
         <li class="itemize">DP_TR (s) : The time of repetition for dummy pulse</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34004x2">EPI <br 
class="newline" />The &#8216;EPI&#8217; tab contains parameters for performing multi shot interleaved EPI
     readout.
         <ul class="itemize1">
         <li class="itemize">EPI_ESP (s) : The echo spacing for EPI
         </li>
         <li class="itemize">EPI_ETL : The echo train length for EPI
         </li>
         <li class="itemize">EPI_EchoShifting : The flag for turning on and off echo shifting
         </li>
         <li class="itemize">EPI_ShotNum  :  The  number  of  EPI  shots,  multi  shot  EPI  uses
         interleave mode</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34006x3">FSE <br 
class="newline" />The &#8216;FSE&#8217; tab contains parameters for performing multi shot interleaved FSE
     readout.

         <ul class="itemize1">
         <li class="itemize">FSE_ESP (s) : The echo spacing for FSE
         </li>
         <li class="itemize">FSE_ETL : The echo train length for FSE
         </li>
         <li class="itemize">FSE_ShotNum : The number of FSE shots, multi shot FSE uses
         interleave mode</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34008x4">GRAPPA (:TODO) <br 
class="newline" />The &#8216;GRAPPA&#8217; tab contains parameters for performing parallel imaging using
     GRAPPA.
     </li>
     <li 
  class="enumerate" id="x3-34010x5">Gridding <br 
class="newline" />The &#8216;Gridding&#8217; tab contains parameters for controlling gridding process in
     default Non-Cartesian reconstruction. MRiLab uses Voronoi diagram for
     K-Space density compensation, and uses Kaiser-Bessel kernel for gridding.
     Detailed explanation is beyond the scope of this manual, users who are
     interested are referred to <span class="cite">[<a 
href="#XJackson1991">2</a>,&#x00A0;<a 
href="#XVRasche1999">3</a>,&#x00A0;<a 
href="#XBeatty2005">4</a>]</span>.
         <ul class="itemize1">
         <li class="itemize">G_Deapodization   :   The   flag   for   turning   on   and   off   kernel
         deapodization (i.e. dividing reconstructed image with the iFFT of
         the gridding kernel)
         </li>
         <li class="itemize">G_KernelSample  :  The  number  of  kernel  sample  point,  the  more
         sample points, the better kernel approximation
         </li>
         <li class="itemize">G_KernelWidth : The full width of kernel in the unit of gridding grid
         </li>
         <li class="itemize">G_OverGrid : The over gridding factor
         </li>
         <li class="itemize">G_Truncation : The flag for turning on and off image truncation for
         reconstructed image</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34012x6">IRPrep <br 
class="newline" />The &#8216;IRPrep&#8217; tab contains parameters for inversion recovery sequence.
         <ul class="itemize1">
         <li class="itemize">TI (s) : The time of inversion recovery</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34014x7">MT <br 
class="newline" />The &#8216;MT&#8217; tab contains parameters for activating MR sequences running
     Magnetization Transfer model (MT). In order to perform MT experiment, MT
     phantom is required.

         <ul class="itemize1">
         <li class="itemize">MT_Flag : The flag for turning on and off MT simulation</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34016x8">ME <br 
class="newline" />The &#8216;ME&#8217; tab contains parameters for activating MR sequences running
     Multiple pool spin Exchange model (ME). In order to perform ME experiment,
     ME phantom is required.
         <ul class="itemize1">
         <li class="itemize">ME_Flag : The flag for turning on and off ME simulation</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34018x9">RTRecon <br 
class="newline" />The &#8216;RTRecon&#8217; tab contains parameters for performing real time image
     reconstruction. Notice that adding RTRecon tab is not guaranteed to perform
     real time reconstruction, the user also needs to use the extended real time
     process to trigger real time image reconstruction at the Ext sequence line. See
     Section <a 
href="#x3-940005.2.7">5.2.7<!--tex4ht:ref: subs:ExtMacroLibrary --></a> for more details.
         <ul class="itemize1">
         <li class="itemize">RTR_Flag : The flag for turning on and off real time reconstruction
         </li>
         <li class="itemize">PlotK_Flag  :  The  flag  for  turning  on  and  off  real  time  K-Space
         plotting
         </li>
         <li class="itemize">DelayTime : The delay time for refreshing graphics</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34020x10">MultiEcho <br 
class="newline" />The &#8216;MultiEcho&#8217; tab contains parameters for performing multi echo experiment,
     the number of echoes much match TEPerTR.
         <ul class="itemize1">
         <li class="itemize">ME_TEs (s) : An array of multiple echo values</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34022x11">PartialEcho (:TODO) <br 
class="newline" />The &#8216;PartialEcho&#8217; tab contains parameters for performing partial echo in
     readout.
     </li>
     <li 
  class="enumerate" id="x3-34024x12">Radial <br 
class="newline" />The &#8216;Radial&#8217; tab contains parameters for performing 2D radial readout
     sampling.
         <ul class="itemize1">
         <li class="itemize">R_AngPattern : The pattern for sampling the angle in K-Space

         </li>
         <li class="itemize">R_AngRange : The range of sampling angle
         </li>
         <li class="itemize">R_SampPerSpoke : The number of sampling points in each spoke
         </li>
         <li class="itemize">R_SpokeNum : The number of sampling spokes</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34026x13">SENSE (:TODO) <br 
class="newline" />The &#8216;SENSE&#8217; tab contains parameters for performing parallel imaging using
     SENSE.
     </li>
     <li 
  class="enumerate" id="x3-34028x14">Shim <br 
class="newline" />The &#8216;Shim&#8217; tab contains parameters for performing manual B0 shimming.
         <ul class="itemize1">
         <li class="itemize">Sh_X : The constant for X term
         </li>
         <li class="itemize">Sh_Y : The constant for Y term
         </li>
         <li class="itemize">Sh_Z : The constant for Z term
         </li>
         <li class="itemize">Sh_ZX : The constant for ZX term
         </li>
         <li class="itemize">Sh_ZY : The constant for ZY term
         </li>
         <li class="itemize">Sh_Z2 : The constant for Z<sup class="textsuperscript"><span 
class="cmr-9">2</span></sup> term
         </li>
         <li class="itemize">Sh_XYZ : The constant for XYZ term
         </li>
         <li class="itemize">Sh_X2_Y2 : The constant for X<sup class="textsuperscript"><span 
class="cmr-9">2</span></sup>Y<sup class="textsuperscript"><span 
class="cmr-9">2</span></sup> term</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34030x15">Spiral <br 
class="newline" />The &#8216;Spiral&#8217; tab contains parameters for performing multi shot spiral readout.
     The 2D spiral design uses a method described in <span class="cite">[<a 
href="#XGlover2005">5</a>]</span>.
         <ul class="itemize1">
         <li class="itemize">S_Gradient (T/m) : The desired gradient amplitude
         </li>
         <li class="itemize">S_Lamda (1/m/rad) : A constant affecting radial sampling interval
         in the spiral trajectory
         </li>
         <li class="itemize">S_ShotNum : The number of spiral interleaves

         </li>
         <li class="itemize">S_SlewRate (T/m/s) : The desired slew rate. Notice that in this
         approximation, slew rate overshoots the desired value for part of the
         slew-rate-limited region
         </li>
         <li class="itemize">S_SlewRate0 (T/m/s) : The slew rate at the beginning</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-34032x16">T2Prep (:TODO) <br 
class="newline" />The &#8216;T2Prep&#8217; tab contains parameters for T2 preparation sequence.
     </li>
     <li 
  class="enumerate" id="x3-34034x17">VIPR (:TODO) <br 
class="newline" />The &#8216;VIPR&#8217; tab contains parameters for performing Vastly Undersampled
     Isotropic Projection Reconstruction (VIPR) sequence.
     </li>
     <li 
  class="enumerate" id="x3-34036x18">ZeroFilling <br 
class="newline" />The &#8216;ZeroFilling&#8217; tab contains parameters for performing image interpolation in
     the K-Space using zero filling.
         <ul class="itemize1">
         <li class="itemize">ZF_Kz : The zero filling factor in Kz
         </li>
         <li class="itemize">ZF_Ky : The number of point in Ky after zero filling
         </li>
         <li class="itemize">ZF_Kx : The number of point in Kx after zero filling</li></ul>
     </li></ol>
<!--l. 758--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3.9   </span> <a 
 id="x3-350003.9"></a>Parallel Computing</h3>
<!--l. 760--><p class="noindent" >The current MRiLab version supports two types of parallel computing mechanisms:
GPU based parallel computing using CUDA and multi-threading CPU based parallel
computing using OpenMP. As mentioned before, the GPU support requires NVIDIA
GPU with CUDA capability (shader model 2.0) along with properly installed GPU
driver. The OpenMP is, on the other hand, supported by most of modern multi core
CPU. If both GPU and CPU are available in user&#8217;s system, the user can choose to
use any of these two methods. To switch parallel computing methods, go to
&#8216;Parallel&#8217; menu and &#8216;Select Processing Unit&#8217; and choose available GPU or CPU
devices.

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;4</span><br /><a 
 id="x3-360004"></a>Simulation</h2>
   <h3 class="sectionHead"><span class="titlemark">4.1   </span> <a 
 id="x3-370004.1"></a>Running Simulation</h3>
<!--l. 766--><p class="noindent" >The MRiLab converts simulation parameters from configuration files into temporary
configuration structures during loading process, and uses these structures to organize
simulation workflow. The user can check the default value of each parameter by
moving a mouse cursor on top of selected parameters. The use can adjust
loaded simulation parameters to satisfy a simulation design, to make changing
parameters effective, the user has to press &#8216;Update&#8217; button located below
&#8216;Simulation Settings&#8217; panel. The &#8216;Update&#8217; button not only updates these
structures, but also performs a series of pre-scan processes including checking
incompatibility error and initializing other necessary simulation variables.
<br 
class="newline" />
<!--l. 768--><p class="indent" >   On the left of &#8216;Update&#8217; button, there is a &#8216;Save&#8217; button which saves updated
configuration structure back into corresponding configuration files for later use. One
particular case is that &#8216;CVs&#8217; need to be updated and then saved in order to make
changes effective. This is because &#8216;CVs&#8217; is one part of the sequence file which needs to
be interpreted at the sequence waveform generation module. The sequence memo is
also provided at the &#8216;PSD Memo&#8217; panel. It&#8217;s editable and can be saved using &#8216;Save&#8217;
button. <br 
class="newline" />
<!--l. 770--><p class="indent" >   On the right of &#8216;Update&#8217; button, there is a &#8216;Scan&#8217; button which activates sequence
waveform generation, actual scan process and post-scan process including
image reconstruction and data saving. The MRiLab automatically detects
any parameter changes and set &#8216;Scan&#8217; button disabled. To enable &#8216;Scan&#8217;
button, simply press &#8216;Update&#8217; button. Notice that the update process may
take some time if a large number of initialization is needed, so be patient
and wait it to finish before proceeding. The &#8216;Simulation Info Log&#8217; is helpful
for checking log information about each simulation step. Once simulation
setting gets configured properly, the user can press &#8216;Scan&#8217; button to start
scanning.
<!--l. 772--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">4.2   </span> <a 
 id="x3-380004.2"></a>Image, SNR and SAR</h3>
<!--l. 774--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-380011"></a>


<!--l. 776--><p class="noindent" ><img 
src="Pictures/SimulationImage.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.1:  </span><span  
class="content">A  Preview  of  A  Simulated  Image.  The  preview  is  one  slice
of  simulated  image  using  gradient  echo  sequence  with  radial  readout  and
reconstructed without deapodization.</span></div><!--tex4ht:label?: x3-380011 -->

<!--l. 779--><p class="noindent" ></div><hr class="endfigure">
<!--l. 781--><p class="indent" >   Figure <a 
href="#x3-380011">4.1<!--tex4ht:ref: fig:SimulationImage --></a> demonstrates an example of a series of simulation operated with
different sequences. Each sequence is labeled with an unique series number, and
shows in the list at &#8216;Scan Series&#8217; panel. This series number is also a reference for the
saved image and data in the output database which will be explained in Chapter <a 
href="#x3-390005">5<!--tex4ht:ref: chap:MRiLabToolboxes --></a>.
There is also a status label on the left of each sequence name. The status labels
include:
     <ul class="itemize1">
     <li class="itemize">Dx : parameter setting and sequence loading
     </li>
     <li class="itemize">... : scanning
     </li>
     <li class="itemize">V : scan complete successfully
     </li>
     <li class="itemize">X : scan incomplete or fail</li></ul>
<!--l. 790--><p class="indent" >   The example shows a series of successful simulation by using PSD_GRE3D,
PSD_GRE3DRadial and PSD_FIESTA3D sequences, but incomplete simulation
using PSD_FIESTA3D at the second time. The preview axes displays an image
preview for the series 2 simulated using PSD_GRE3DRadial sequence. The user can
switch previews for successful simulation by clicking scan series item. Moreover, the
series name is also editable although in this example the series name is kept the same
as the name of the sequence, which is not absolutely necessary. If the multiple
channel coil for multiple receiving is performed (Figure <a 
href="#x3-380022">4.2<!--tex4ht:ref: fig:SimulationImage2 --></a>), the user can specify
display image to any channel with &#8216;Channel #&#8217; pop-up menu, or choose
&#8216;SumofMagn&#8217; for summation of image magnitude of all channels or &#8216;SumofCplx&#8217; for
summation of complex image of all channels. If multiple echo is enabled in the
sequence, the user can also specify display image to any echo with &#8216;Echo
#&#8217; pop-up menu. Default value of 1 is used for single echo. The preview
image provides a quick overview of the simulated images, a further image
analysis can be performed with image display and analysis tools in Chapter
<a 
href="#x3-1320006">6<!--tex4ht:ref: chap:ImageDisplayAndAnalysis --></a>.
<!--l. 792--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-380022"></a>


<!--l. 794--><p class="noindent" ><img 
src="Pictures/SimulationImage2.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.2: </span><span  
class="content">A Preview of A Simulated Image with Multiple Receiving. The
preview is one slice of simulated image using FIESTA sequence with 8 channel
head coil. The image is from the fifth coil channel.</span></div><!--tex4ht:label?: x3-380022 -->

<!--l. 797--><p class="indent" >   </div><hr class="endfigure">
<!--l. 799--><p class="indent" >   At the bottom of the preview axes, there are information for the name of
currently running sequence, estimated remaining scan time in real time and a scan
progress bar. A global relative SNR and SAR (:TODO) are also provided and
automatic updated in real time. The relative SNR is defined as the ratio of current
SNR to the initial SNR calculated upon loading the sequence. The SNR value is
calculated using Equation <a 
href="#x3-38003r1">4.1<!--tex4ht:ref: eq:SNR --></a>.
   <table 
class="equation"><tr><td><a 
 id="x3-38003r1"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide0x.png" alt="                                  &#x221A;-------------------------------------
                                  -ResF-req&#x00D7;-ResP-hase&#x00D7;-SliceN-um-&#x00D7;-N-EX--
SN R = B0&#x00D7;RF  req&#x00D7;RP  hase&#x00D7;RSlice&#x00D7;        N oiseLevel&#x00D7; &#x221A;BandW--idth-
" class="math-display" ></center></td><td class="equation-label">(4.1)</td></tr></table>
<!--l. 804--><p class="nopar" >
<!--l. 806--><p class="indent" >   where
   <table 
class="equation"><tr><td><a 
 id="x3-38004r2"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide1x.png" alt="          F OV Freq
  RF req =---------;
           ResF req
RPhase = F-OV-Phase;
          ResPhase
  RSlice = SliceT hick.
" class="math-display" ></center></td><td class="equation-label">(4.2)</td></tr></table>
<!--l. 815--><p class="nopar" >

<!--l. 817--><p class="indent" >   In order to simulate image noise, MRiLab performs a noise adding process in
K-Space after signal acquisition. The Gaussian noise with zero mean and user-defined
standard deviation is added to the complex signal. The standard deviation is
determined using Equation <a 
href="#x3-38005r3">4.3<!--tex4ht:ref: eq:Noise --></a>. If no noise is desired, the user can set &#8216;NoiseLevel&#8217; to
zero to get infinite SNR.
   <table 
class="equation"><tr><td><a 
 id="x3-38005r3"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide2x.png" alt="                                      &#x2218; ---------
                            NoNioseisLeeRvefel &#x00D7;   BaBnWdWRiedtfh-
N oise = -------RF-req&#x00D7;RPhase&#x00D7;RSlice--&#x2218;-----------ResFreq&#x00D7;ResPhase&#x00D7;SliceNum--
        BB00Ref &#x00D7;------V-olRef------&#x00D7;   NNEEXXRef-&#x00D7;  --------ADCRef---------
" class="math-display" ></center></td><td class="equation-label">(4.3)</td></tr></table>
<!--l. 823--><p class="nopar" >
<!--l. 825--><p class="indent" >   where these reference values are given as:
   <table 
class="equation"><tr><td><a 
 id="x3-38006r4"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide3x.png" alt="  BW  Ref = 1e3;
  N oiseRef  = 1;
    B0Ref = 1.5;

V olRef = 1e - 9;
   NEXRef   = 1;
 ADCRef   = 1e4.
" class="math-display" ></center></td><td class="equation-label">(4.4)</td></tr></table>
<!--l. 837--><p class="nopar" >

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;5</span><br /><a 
 id="x3-390005"></a>MRiLab Toolboxes</h2>
<!--l. 841--><p class="noindent" >MRiLab toolboxes consists of several individual graphical user interfaces for
conducting RF pulse design, MR sequence design and Coil design etc. These
toolboxes allow users to fast and effectively build and customize their own specific
MR simulation experiment. This chapter covers the introduction to each toolbox and
corresponding macro libraries.
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x3-400005.1"></a>RF Pulse Design</h3>
<!--l. 845--><p class="noindent" >The RF pulse design toolbox can be activated by pressing &#8216;RF Design Panel&#8217; toolbar
icon located at the top of the main simulation console.
<!--l. 847--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-400011"></a>


<!--l. 849--><p class="noindent" ><img 
src="Pictures/RFDesignPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.1: </span><span  
class="content">RF Design Panel Toolbar Icon</span></div><!--tex4ht:label?: x3-400011 -->

<!--l. 852--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
 id="x3-410005.1.1"></a>RF Design GUI</h4>
<!--l. 856--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-410012"></a>


<!--l. 858--><p class="noindent" ><img 
src="Pictures/RFDesignGUI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.2: </span><span  
class="content">RF Design Panel. An example of simulating the slice profile of a
linear phase Shinnar-Le Roux RF pulse.</span></div><!--tex4ht:label?: x3-410012 -->

<!--l. 861--><p class="noindent" ></div><hr class="endfigure">
<!--l. 863--><p class="indent" >   Figure <a 
href="#x3-410012">5.2<!--tex4ht:ref: fig:RFDesignGUI --></a> demonstrates an overview of the RF Pulse Design interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-41003x1">RF and Gradient Pulse Macro Library <br 
class="newline" />
     <!--l. 869--><p class="noindent" >The user can use this interface to analyze tissue spin response regarding
     a selected RF and gradient pulse. To select a RF pulse macro, the user
     needs to click the macro library tree to unfold the tree structure, and then
     click a desired RF macro. The properties of the chosen RF macro will
     show on the left panel under &#8216;rf:rf name&#8217; tab. The RF memo information is
     also shown at the &#8216;rf Memo&#8217; panel below the tree structure. The user can
     press &#8216;Execute&#8217; button to start analysis process. MRiLab supports three
     analysis modes for analyzing 1D spatial RF pulse, 2D spatial RF pulse
     and Spatial-Spectral RF pulse:
         <ul class="itemize1">
         <li class="itemize">1D Spatial Mode
         <!--l. 874--><p class="noindent" >MRiLab assumes a gradient is applied in the Z direction, therefore a
         constant gradient will be applied if &#8216;Gz&#8217; tab is empty (Figure <a 
href="#x3-410043">5.3<!--tex4ht:ref: fig:ConstantGradient --></a>). To
         select a &#8216;Gz&#8217; gradient, the user needs to choose a gradient macro under
         &#8216;GzSS&#8217;. For example, the &#8216;GzSelective&#8217; is a recommended gradient
         macro typically used for performing slice selection in MRiLab. Once
         the user selected a gradient macro, the &#8216;Gz:gradient name&#8217; tab will
         become activated and the properties of this gradient macro become
         accessible and editable. The user can modify macro attributes to meet
         design goals. To make any modification effective, the user must press
         &#8216;Update&#8217; button before executing the slice profile analysis. Although
         the library tree contains macros for another gradient line (e.g. GyPE,
         GxR), they are typically ignored in this mode.
         </li>
         <li class="itemize">2D Spatial Mode
         <!--l. 877--><p class="noindent" >MRiLab assumes a gradient is applied in both the X and Y directions,
         a constant gradient will be applied if &#8216;Gx&#8217; tab or &#8216;Gy&#8217; tab is empty.
         The user can choose any Gx and Gy gradient macros for these two
         tabs and modify macro attributes to satisfy 2D rf pulse design. To
         activate 2D pulse analysis, the &#8216;Spat_Flag&#8217; under &#8216;XSpatial&#8217; tab has
         to be turned on (<a 
href="#x3-410203">4c<!--tex4ht:ref: it:XSpatial --></a>). The Gz gradient is typically ignored under this
         mode.
         </li>
         <li class="itemize">Spatial-Spectral Mode
         <!--l. 881--><p class="noindent" >MRiLab assumes a gradient is applied in the Z direction, a constant
         gradient will be applied if &#8216;Gz&#8217; tab is empty. The user can choose
         any Gz gradient macros for this tab and modify macro attributes to

         satisfy Spatial-Spectral pulse design. The user can also modify the
         frequency range and resolution under &#8216;Spectral&#8217; tab (<a 
href="#x3-410245">4e<!--tex4ht:ref: it:Spectral --></a>). To activate
         Spatial-Spectral pulse analysis, the &#8216;Freq_Flag&#8217; has to be turned on
         (<a 
href="#x3-410245">4e<!--tex4ht:ref: it:Spectral --></a>). The Gx and Gy gradient are typically ignored under this mode.
         </li></ul>
     <!--l. 885--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410043"></a>   <img 
src="Pictures/ConstantGradient.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.3: </span><span  
class="content">A Warning Window for Using Constant Gradient</span></div><!--tex4ht:label?: x3-410043 -->
     <!--l. 890--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-41006x2">Spin Response <br 
class="newline" />
     <!--l. 894--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410074"></a>   <img 
src="Pictures/SliceProfile.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.4: </span><span  
class="content">A Slice Profile Analysis of A linear phase SLR Pulse</span></div><!--tex4ht:label?: x3-410074 -->
     <!--l. 899--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 901--><p class="noindent" >Under 1D Spatial Mode, MRiLab provides three slice profile figures (Figure <a 
href="#x3-410074">5.4<!--tex4ht:ref: fig:SliceProfile --></a>)
     on the &#8216;Spin Response&#8217; panel under different tabs. These figures include slice
     profile regarding
         <ul class="itemize1">
         <li class="itemize">Mx My Mz : three independent spin component
         </li>
         <li class="itemize"><span 
class="cmsy-10">|</span>Mxy<span 
class="cmsy-10">| </span>Mz : transverse and longitudinal component
         </li>
         <li class="itemize">Mg Pe : transverse component magnitude and phase</li></ul>
     <!--l. 909--><p class="noindent" >The horizontal axis is the spin position in units of meters, and the vertical axis
     is the value of the components in normalized units.
     <!--l. 911--><p class="noindent" >Under 2D Spatial or Spatial-Spectral Mode, MRiLab provides another five spin
     response figures on the &#8216;Spin Response&#8217; panel under different tabs. These
     figures include
         <ul class="itemize1">
         <li class="itemize">Mx : spin X component
         </li>
         <li class="itemize">My : spin Y component
         </li>
         <li class="itemize">Mz : spin Z component
         </li>
         <li class="itemize">Mag : transverse component magnitude
         </li>
         <li class="itemize">Ph : transverse component phase</li></ul>

     <!--l. 921--><p class="noindent" >The horizontal axis is the spin position for 2D Spatial mode and the frequency
     range for Spatial-Spectral mode, and the vertical axis is the spin location in
     both mode. Notice the units of both axes use spin index for either spatial
     position or frequency position according to spin property and environment (<a 
href="#x3-410203">4c<!--tex4ht:ref: it:XSpatial --></a>,
     <a 
href="#x3-410224">4d<!--tex4ht:ref: it:YSpatial --></a> and <a 
href="#x3-410245">4e<!--tex4ht:ref: it:Spectral --></a>).
     <!--l. 923--><p class="noindent" >MRiLab also plots the RF and gradient waveform. In MRiLab, the
     property of a RF pulse contains RF amplitude (T), RF phase (rad) and
     RF frequency (Hz). The RF frequency is defined as the spin Larmor
     frequency minus the laboratory frequency of the RF pulse. Notice
     that in those figures, for display purpose, the gradient amplitude is in
     units of G/cm and RF amplitude is in units of G. Both time axes are
     in units of milliseconds. At the bottom of this interface, there is a
     group of pushbuttons (Figure <a 
href="#x3-410085">5.5<!--tex4ht:ref: fig:PlaybackButtonGroup --></a>) allowing the user to investigate
     intermediate spin response during a applied RF and gradient (Figure
     <a 
href="#x3-410096">5.6<!--tex4ht:ref: fig:SliceProfileAtMiddle --></a>).
     <!--l. 925--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410085"></a>   <img 
src="Pictures/PlaybackButtonGroup.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.5: </span><span  
class="content">The Playback Control Group for Spin Response</span></div><!--tex4ht:label?: x3-410085 -->
     <!--l. 930--><p class="noindent" ></div><hr class="endfigure">
         <ul class="itemize1">
         <li class="itemize">Scroll  Bar  :  Drag  the  scroll  bar  to  any  intermediate  time  point
         between beginning and end
         </li>
         <li class="itemize"><span 
class="cmsy-10">| </span><span 
class="cmmi-10">&#x003C; </span>: Move to the beginning
         </li>
         <li class="itemize">X : Pause animation, notice that the interface can only be closed
         while animation is paused
         </li>
         <li class="itemize">O : Resume animation
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E; </span>: Play at normal speed
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E;&#x003E; </span>: Play at double normal speed
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E; </span><span 
class="cmsy-10">| </span>: Move to the end</li></ul>
     <!--l. 942--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410096"></a>   <img 
src="Pictures/SliceProfileAtMiddle.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.6: </span><span  
class="content">An Intermediate Slice Profile in The Middle of RF Pulse</span></div><!--tex4ht:label?: x3-410096 -->
     <!--l. 947--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-41011x3">3D Spin Response <br 
class="newline" />

     <!--l. 951--><p class="noindent" >MRiLab renders three-dimensional spin response in &#8216;3D Spin Response&#8217; panel
     based on different modes. The user can inspect the behavior of spins at specific
     location under a chosen RF pulse and gradient. The user can use Matlab
     default graphical tools for interactively changing display view and size (Figure
     <a 
href="#x3-410138">5.8<!--tex4ht:ref: fig:MatlabDefaultTools --></a>). To change three-dimensional spin response content reflecting different tabs
     in 2D spatial mode or Spatial-Spectral model (Figure <a 
href="#x3-410127">5.7<!--tex4ht:ref: fig:SpatialSpectral --></a>), the trick is to simply
     activate any item of the playback control group (e.g. click the scroll
     bar).
     <!--l. 953--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410127"></a>   <img 
src="Pictures/SpatialSpectral.png" alt="pict"  
>
<br />  <div class="caption" 
><span class="id">Figure&#x00A0;5.7:   </span><span  
class="content">The   Magnitude   of   Spin   Transverse   Component   from   A
Spatial-Spectral Analysis of An Inversion Adiabatic rf Pulse</span></div><!--tex4ht:label?: x3-410127 -->
     <!--l. 958--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 960--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410138"></a>   <img 
src="Pictures/MatlabDefaultTools.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.8: </span><span  
class="content">Matlab Default Graphical Tools</span></div><!--tex4ht:label?: x3-410138 -->
     <!--l. 965--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-41015x4">Spin Property and Environment <br 
class="newline" />
     <!--l. 969--><p class="noindent" >The user can modify the spin properties and environment to satisfy their
     experiment design. The editable properties provided in this interface
     include:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x3-41017x1">Spin
             <ul class="itemize1">
             <li class="itemize">ChemShift (Hz/T): The chemical shift of the spin
             </li>
             <li class="itemize">Gyro (rad/s/T): The gyromagnetic ratio of the spin
             </li>
             <li class="itemize">Rho : The spin density of the spin
             </li>
             <li class="itemize">T1 (s): The longitudinal relaxation time
             </li>
             <li class="itemize">T2 (s): The transverse relaxation time
             </li>
             <li class="itemize">TypeNum : The number of spin species</li></ul>
         </li>
         <li 
  class="enumerate" id="x3-41019x2">ZSpatial <a 
 id="x3-410182"></a>
             <ul class="itemize1">
             <li class="itemize">ZCenter : The index of the centeral spin in Z direction
             </li>
             <li class="itemize">ZSpin : The number of the spins in Z direction

             </li>
             <li class="itemize">ZSpinGap  (m):  The  distance  between  adjacent  spins  in  Z
             direction</li></ul>
         </li>
         <li 
  class="enumerate" id="x3-41021x3">XSpatial <a 
 id="x3-410203"></a>
             <ul class="itemize1">
             <li class="itemize">XCenter : The index of the centeral spin in X direction
             </li>
             <li class="itemize">XSpin : The number of the spins in X direction
             </li>
             <li class="itemize">XSpinGap  (m):  The  distance  between  adjacent  spins  in  X
             direction
             </li>
             <li class="itemize">Spat_Flag: The flag to turn on and off 2D spatial rf analysis</li></ul>
         </li>
         <li 
  class="enumerate" id="x3-41023x4">YSpatial <a 
 id="x3-410224"></a>
             <ul class="itemize1">
             <li class="itemize">YCenter : The index of the centeral spin in Y direction
             </li>
             <li class="itemize">YSpin : The number of the spins in Y direction
             </li>
             <li class="itemize">YSpinGap  (m):  The  distance  between  adjacent  spins  in  Y
             direction</li></ul>
         </li>
         <li 
  class="enumerate" id="x3-41025x5">Spectral <a 
 id="x3-410245"></a>
             <ul class="itemize1">
             <li class="itemize">FreqRes : The number of linear frequency sample points
             </li>
             <li class="itemize">FreqUpLimit : The upper limit of frequency range
             </li>
             <li class="itemize">FreqDownLimit : The lower limit of frequency range
             </li>
             <li class="itemize">Freq_Flag: The flag to turn on and off Spatial-Spectral rf analysis</li></ul>
         </li>
         <li 
  class="enumerate" id="x3-41027x6">Gradient
             <ul class="itemize1">
             <li class="itemize">ConstantGrad  (T/m):  The  constant  gradient  applied  when
             gradient tab is empty</li></ul>
         </li>
         <li 
  class="enumerate" id="x3-41029x7">Magnet
             <ul class="itemize1">
             <li class="itemize">dB0 (T): The main magnetic field offset</li></ul>

         </li></ol>
     <!--l. 1030--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-410309"></a>   <img 
src="Pictures/SliceProfileTwoSpecies.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.9: </span><span  
class="content">A Slice Profile Analysis of Two Spin Species</span></div><!--tex4ht:label?: x3-410309 -->
     <!--l. 1035--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 1037--><p class="noindent" >Figure <a 
href="#x3-410309">5.9<!--tex4ht:ref: fig:SliceProfileTwoSpecies --></a> demonstrates a slice profile for two different spin species under the
     same RF pulse and gradient in 1D spatial mode. To enable slice profile
     analysis for multiple spin species, the user needs to provide multiple
     values for T1, T2, Rho and ChemShift in an array, and give the correct
     number of spin species. The values must be separated with space. For
     example
         <ul class="itemize1">
         <li class="itemize">ChemShift = 0 -210
         </li>
         <li class="itemize">Rho = 1.0 0.5
         </li>
         <li class="itemize">T1 = 1.2 1.0
         </li>
         <li class="itemize">T2 = 0.02 0.03
         </li>
         <li class="itemize">TypeNum = 2</li></ul>
     </li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
 id="x3-420005.1.2"></a>RF Macro Library</h4>
<!--l. 1051--><p class="noindent" >MRiLab uses a concept of macros for simplifying experiment design. A RF macro is a
predefined module for a RF pulse with the features of programming-free and
flexible of modification for specific experimental design using the RF Design
interface. MRiLab RF macro library is a collection of RF macros covering
from simple RF pulses such as hard pulse, to complex RF pulses such as
adiabatic pulses. A specific RF macro to interact with external RF pulse
file is also provided to create more extensible pulse design environment.
This section will give an introduction to each of the RF macros provided in
MRiLab.
<!--l. 1053--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-430005.1.2"></a>rfSinc</h5>
<!--l. 1055--><p class="noindent" >A RF macro that creates a Sinc type RF pulse. This macro contains attributes
including:

     <ul class="itemize1">
     <li class="itemize">Apod : Apodization methods including &#8216;Non&#8217;, &#8216;Hamming&#8217; and &#8216;Hanning&#8217;
     </li>
     <li class="itemize">FA (Degree) : Prescribed flip angle
     </li>
     <li class="itemize">TBP : The time bandwidth product
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">rfFreq (Hz) : RF pulse frequency
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1074--><p class="indent" >   The time dependence of the Sinc RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>:
   <table 
class="equation"><tr><td><a 
 id="x3-43001r1"></a>

   <center class="math-display" >
<img 
src="MRiLab_User_Guide4x.png" alt="       {       &#x03C0;t
         At0sin(&#x03C0;t0t)- - NLt0 &#x2264; t &#x2264; NRt0
B1(t) =   0         elsewhere
" class="math-display" ></center></td><td class="equation-label">(5.1)</td></tr></table>
<!--l. 1083--><p class="nopar" >
<!--l. 1085--><p class="indent" >   where <span 
class="cmmi-10">A </span>is the peak RF amplitude automatically calculated and scaled according
to flip angle, <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">0</span></sub> is one-half the width of the central lobe, and the <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">L</span></sub> and <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">R</span></sub> are the
number of zero-crossings to the left and right of the central peak, respectively. In
MRiLab, the <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">L</span></sub> <span 
class="cmsy-10">&#x2261; </span><span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">R</span></sub>, thus the Sinc RF pulse is always symmetric. Notice that the
The time bandwidth product of a Sinc pulse equals the number of zero-crossings
including the start and end. In order to address the discontinuity at the start and
end, apodization can be applied using &#8216;Hamming&#8217; or &#8216;Hanning&#8217; window as described
by:
   <table 
class="equation"><tr><td><a 
 id="x3-43002r2"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide5x.png" alt="               {
                 (1 - &#x03B1;)+ &#x03B1;cos( &#x03C0;t-) - NLt0 &#x2264; t &#x2264; NRt0
Apodization(t) =   0            Nt0  elsewhere
" class="math-display" ></center></td><td class="equation-label">(5.2)</td></tr></table>
<!--l. 1094--><p class="nopar" >
<!--l. 1096--><p class="indent" >   where <span 
class="cmmi-10">N </span>equals <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">L</span></sub> and <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">R</span></sub>. Hamming window uses <span 
class="cmmi-10">&#x03B1; </span>= 0<span 
class="cmmi-10">.</span>46, and Hanning
window uses <span 
class="cmmi-10">&#x03B1; </span>= 0<span 
class="cmmi-10">.</span>5. If &#8216;Non&#8217; is used, apodization is disabled.
<!--l. 1098--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-440005.1.2"></a>rfRect</h5>
<!--l. 1100--><p class="noindent" >A RF macro that creates a hard RF pulse. This macro contains attributes
including:

     <ul class="itemize1">
     <li class="itemize">FA (Degree) : Prescribed flip angle
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">rfFreq (Hz) : RF pulse frequency
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1118--><p class="indent" >   The time dependence of the hard RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>:
   <table 
class="equation"><tr><td><a 
 id="x3-44001r3"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide6x.png" alt="        {
         A   |t| &#x2264; T2
B1 (t) =  0   |t| &#x003E; T
                 2
" class="math-display" ></center></td><td class="equation-label">(5.3)</td></tr></table>
<!--l. 1127--><p class="nopar" >
<!--l. 1129--><p class="indent" >   where <span 
class="cmmi-10">A </span>is the peak RF amplitude automatically calculated and scaled according
to flip angle, <span 
class="cmmi-10">T </span>is the width of RF pulse that equals tEnd-tStart.
<!--l. 1131--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-450005.1.2"></a>rfGaussian</h5>
<!--l. 1133--><p class="noindent" >A RF macro that creates a Gaussian type RF pulse. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">FA (Degree) : Prescribed flip angle
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">rfFreq (Hz) : RF pulse frequency
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates

     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1150--><p class="indent" >   The time dependence of the Gaussian RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>:
   <table 
class="equation"><tr><td><a 
 id="x3-45001r4"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide7x.png" alt="         - t2-
B1(t) = Ae 2&#x03C3;2  pulse centered at t = 0
" class="math-display" ></center></td><td class="equation-label">(5.4)</td></tr></table>
<!--l. 1155--><p class="nopar" >
<!--l. 1157--><p class="indent" >   where <span 
class="cmmi-10">A </span>is the peak RF amplitude automatically calculated and scaled according
to flip angle, <span 
class="cmmi-10">&#x03C3; </span>is linearly proportional to the pulse width. Also the Gaussian RF
pulse is terminated with a 60-dB attenuation.
<!--l. 1159--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-460005.1.2"></a>rfFermi</h5>
<!--l. 1161--><p class="noindent" >A RF macro that creates a Fermi RF pulse. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">PW : The measure of the pulse width
     </li>
     <li class="itemize">FA (Degree) : Prescribed flip angle
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">rfFreq (Hz) : RF pulse frequency

     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1179--><p class="indent" >   The time dependence of the Fermi RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>:
   <table 
class="equation"><tr><td><a 
 id="x3-46001r5"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide8x.png" alt="B (t) = ---A----- pulse centered at t = 0
 1     1+ e|t|-&#x03B1;t0
" class="math-display" ></center></td><td class="equation-label">(5.5)</td></tr></table>
<!--l. 1184--><p class="nopar" >
<!--l. 1186--><p class="indent" >   where <span 
class="cmmi-10">A </span>is the peak RF amplitude automatically calculated and scaled according
to flip angle, <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">0</span></sub> is a measure of the pulse width that corresponds to PW, <span 
class="cmmi-10">&#x03B1; </span>is a
measure of the transition width. The Fermi pulse approximates more to a rectangle
pulse with larger <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">0</span></sub> value. Also the Fermi RF pulse is terminated with a 60-dB
attenuation.

<!--l. 1188--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-470005.1.2"></a>rfSLR</h5>
<!--l. 1190--><p class="noindent" >A RF macro that creates a RF pulse using Shinnar-Le Roux algorithm. This macro
contains attributes including:
     <ul class="itemize1">
     <li class="itemize">PulseType : The type of this SLR pulse, including &#8216;st&#8217; (small tip angle
     pulse),  &#8216;ex&#8217;  (excitation  pulse),  &#8216;se&#8217;  (spin-echo  pulse),  &#8216;sat&#8217;  (saturation
     pulse) and &#8216;inv&#8217; (inversion pulse)
     </li>
     <li class="itemize">FilterType : The type of the applied filter design method, including &#8216;ls&#8217;
     (least squares), &#8216;min&#8217; (minimum phase), &#8216;max&#8217; (maximum phase), &#8216;pm&#8217;
     (Parks-McClellan equal ripple), and &#8216;ms&#8217; (Hamming windowed sinc)
     </li>
     <li class="itemize">PRipple : The ripple factor at passband
     </li>
     <li class="itemize">SRipple : The ripple factor at stopband
     </li>
     <li class="itemize">FA (Degree) : Prescribed flip angle
     </li>
     <li class="itemize">TBP : The time bandwidth product
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">rfFreq (Hz) : RF pulse frequency
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on

     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1212--><p class="indent" >   MRiLab implements a library of Matlab SLR pulse design routines
that is originally developed by Prof. John Pauly and published online at
<a 
href="http://rsl.stanford.edu/research/software.html" class="url" ><span 
class="cmtt-10">http://rsl.stanford.edu/research/software.html</span></a>. Thorough explanation of the
algorithm is beyond the scope of this manual, users who are interested in the SLR
algorithm are referred to <span class="cite">[<a 
href="#XHandbook2004">6</a>,&#x00A0;<a 
href="#XPauly1991">7</a>]</span>.
<!--l. 1215--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-480005.1.2"></a>rfHyperbolicSecant</h5>
<!--l. 1217--><p class="noindent" >A RF macro that creates an adiabatic inversion RF pulse based on hyperbolic secant
modulation. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">Adiab : The adiabatic factor
     </li>
     <li class="itemize">MaxB1 (T) : The maximum B1 field
     </li>
     <li class="itemize">TBP : The time bandwidth product
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line

     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1235--><p class="indent" >   The time dependence of the hyperbolic secant RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>:
   <table 
class="equation"><tr><td><a 
 id="x3-48001r6"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide9x.png" alt="  A(t) = A0sech(&#x03B2;t) amplitude modulation
F(t) = --&#x03BC;&#x03B2;tanh(&#x03B2;t) frequency modulation
       2&#x03C0;
" class="math-display" ></center></td><td class="equation-label">(5.6)</td></tr></table>
<!--l. 1243--><p class="nopar" >
<!--l. 1245--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">&#x03BC; </span>is a dimensionless
adiabatic factor corresponding to Adiab, <span 
class="cmmi-10">&#x03B2; </span>is an modulation angular frequency. It can
be shown that TBP has the relationship with <span 
class="cmmi-10">&#x03B2; </span>and <span 
class="cmmi-10">&#x03BC; </span>as
   <table 
class="equation"><tr><td><a 
 id="x3-48002r7"></a>
   <center class="math-display" >

<img 
src="MRiLab_User_Guide10x.png" alt="T BP =  T&#x03BC;&#x03B2;-
         &#x03C0;
" class="math-display" ></center></td><td class="equation-label">(5.7)</td></tr></table>
<!--l. 1250--><p class="nopar" >
<!--l. 1252--><p class="indent" >   where <span 
class="cmmi-10">T </span>is the pulse width.
<!--l. 1254--><p class="indent" >   To satisfy the Adiabatic Condition, the parameter setting has to meet
   <table 
class="equation"><tr><td><a 
 id="x3-48003r8"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide11x.png" alt="      &#x221A;--
A0 &#x226B;  -&#x03BC;&#x03B2;-
       &#x03B3;
" class="math-display" ></center></td><td class="equation-label">(5.8)</td></tr></table>
<!--l. 1259--><p class="nopar" >
<!--l. 1261--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-490005.1.2"></a>rfTanhTan</h5>
<!--l. 1263--><p class="noindent" >A RF macro that creates an adiabatic inversion RF pulse based on tanh/tan
modulation. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">MaxB1 (T) : The maximum B1 field
     </li>
     <li class="itemize">TBP : The time bandwidth product
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time

     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1280--><p class="indent" >   The tanh/tan RF pulse is constructed from an adiabatic half passage and its
time-reversed adiabatic half passage. The time dependence of the first adiabatic half
passage is given by <span class="cite">[<a 
href="#XHwang1998">8</a>]</span>:
   <table 
class="equation"><tr><td><a 
 id="x3-49001r9"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide12x.png" alt="                 2&#x03BE;t          T
  A (t) = &#x03B3;A0tanh (-)  0 &#x2264; t &#x2264;-- amplitude modulation
                 T2t          2
F (t) = Atan(&#x03BA;(1--T-))  0 &#x2264; t &#x2264; T  frequency modulation
          2&#x03C0;tan(&#x03BA;)           2
" class="math-display" ></center></td><td class="equation-label">(5.9)</td></tr></table>
<!--l. 1288--><p class="nopar" >
<!--l. 1290--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">&#x03BE; </span>= 10, <span 
class="cmmi-10">tan</span>(<span 
class="cmmi-10">&#x03BA;</span>) = 20,
<span 
class="cmmi-10">T </span>is the pulse width. The TBP can be estimated using
   <table 
class="equation"><tr><td><a 
 id="x3-49002r10"></a>

   <center class="math-display" >
<img 
src="MRiLab_User_Guide13x.png" alt="       A &#x22C5;T
T BP = --&#x03C0;--
" class="math-display" ></center></td><td class="equation-label">(5.10)</td></tr></table>
<!--l. 1295--><p class="nopar" >
<!--l. 1298--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-500005.1.2"></a>rfBIR</h5>
<!--l. 1300--><p class="noindent" >A RF macro that creates an adiabatic B1 Independent Rotation (BIR) RF pulse.
This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">MaxB1 (T) : The maximum B1 field
     </li>
     <li class="itemize">MaxFreq (Hz) : The maximum RF frequency
     </li>
     <li class="itemize">Lambda : The <span 
class="cmmi-10">&#x03BB; </span>adiabatic factor
     </li>
     <li class="itemize">Beta : The <span 
class="cmmi-10">&#x03B2; </span>adiabatic factor
     </li>
     <li class="itemize">BIRFlag : The type of BIR pulse, including &#8216;BIR-1&#8217;, &#8216;BIR-2&#8217; and &#8216;BIR-4&#8217;
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on

     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1319--><p class="indent" >   The time dependence of the BIR-1 RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>: <br 
class="newline" />Amplitude modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-50001r11"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide14x.png" alt="      {                  T
A(t) =   &#x02C6;xA0cos(&#x03BE;t)  0 &#x2264; t &#x003C;-2
        &#x02C6;yA0cos(&#x03BE;t)  T2-&#x2264; t &#x2264; T
" class="math-display" ></center></td><td class="equation-label">(5.11)</td></tr></table>
<!--l. 1328--><p class="nopar" >
<br 
class="newline" />Frequency modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-50002r12"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide15x.png" alt="       {                   T
F (t) =  F0sin(&#x03BE;t)   0 &#x2264; t &#x003C; 2
        - F0sin(&#x03BE;t)  T2-&#x2264; t &#x2264; T
" class="math-display" ></center></td><td class="equation-label">(5.12)</td></tr></table>

<!--l. 1338--><p class="nopar" >
<!--l. 1340--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">F</span><sub><span 
class="cmr-7">0</span></sub> is the maximum
RF frequency corresponding to MaxFreq. The RF pulse width is <span 
class="cmmi-10">T </span>= <img 
src="MRiLab_User_Guide16x.png" alt="&#x03C0;&#x03BE;"  class="frac" align="middle">, and <img 
src="MRiLab_User_Guide17x.png" alt="x&#x02C6;"  class="circ" > and <span 
class="cmmi-10">&#x0177;</span>
are unit vectors for indicating RF phase. <br 
class="newline" />
<!--l. 1342--><p class="indent" >   The time dependence of the BIR-2 RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>: <br 
class="newline" />Amplitude modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-50003r13"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide18x.png" alt="      (
      |{ &#x02C6;x|A0cos(&#x03BE;t)|  0 &#x2264; t &#x003C; T2
A(t) =  &#x02C6;y|A0cos(&#x03BE;t)|   T2-&#x2264; t &#x003C; T
      |( -y&#x02C6;|A cos(&#x03BE;t)| T &#x2264; t &#x2264; 2T
            0
" class="math-display" ></center></td><td class="equation-label">(5.13)</td></tr></table>
<!--l. 1352--><p class="nopar" >
<br 
class="newline" />Frequency modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-50004r14"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide19x.png" alt="F (t) = |F sin (&#x03BE;t)|
        0
" class="math-display" ></center></td><td class="equation-label">(5.14)</td></tr></table>
<!--l. 1358--><p class="nopar" >
<!--l. 1360--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">F</span><sub><span 
class="cmr-7">0</span></sub> is the maximum
RF frequency corresponding to MaxFreq. The RF pulse width is <span 
class="cmmi-10">T </span>= <img 
src="MRiLab_User_Guide20x.png" alt="&#x03C0;&#x03BE;"  class="frac" align="middle">, and <img 
src="MRiLab_User_Guide21x.png" alt="x&#x02C6;"  class="circ" > and <span 
class="cmmi-10">&#x0177;</span>
are unit vectors for indicating RF phase. <br 
class="newline" />

<!--l. 1362--><p class="indent" >   The time dependence of the BIR-4 RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>: <br 
class="newline" />Amplitude modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-50005r15"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide22x.png" alt="      (| A tanh[&#x03BB;(1- 4t)] 0 &#x2264; t &#x003C; T
      ||{   0      4t T    T-     4T-
A(t) =  A0tanh[&#x03BB;(T -41t)] 4T &#x2264; t &#x003C; 23T
      |||( A0tanh[&#x03BB;(3- T-)] 2-&#x2264; t &#x003C; 4-
        A0tanh[&#x03BB;(4Tt- 3)] 3T4 &#x2264; t &#x2264; T
" class="math-display" ></center></td><td class="equation-label">(5.15)</td></tr></table>
<!--l. 1373--><p class="nopar" >
<br 
class="newline" />Frequency modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-50006r16"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide23x.png" alt="      (| tan(4&#x03B2;Tt)           T-
      ||||  tan(&#x03B2;)4t-    0 &#x2264; t &#x003C; 4
      { tant[&#x03B2;a(nT(&#x03B2; -)2)] T4 &#x2264; t &#x003C; T2
F(t) = || tan[&#x03B2;(4tT -2)] T&#x2264; t &#x003C; 3T
      |||( tatna[&#x03B2;n((&#x03B2;4t)-4)]  23T      4
        --tanT(&#x03B2;)--   4-&#x2264; t &#x2264; T
" class="math-display" ></center></td><td class="equation-label">(5.16)</td></tr></table>
<!--l. 1385--><p class="nopar" >
<!--l. 1387--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1. The RF pulse width
is <span 
class="cmmi-10">T</span>. The <span 
class="cmmi-10">&#x03BB; </span>and <span 
class="cmmi-10">&#x03B2; </span>are dimensionless constants that describe the degree to which
extent the RF pulse satisfies the adiabatic condition.

<!--l. 1390--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-510005.1.2"></a>rfBIREF</h5>
<!--l. 1392--><p class="noindent" >A RF macro that creates an adiabatic B1 Independent Refocusing (BIREF) RF
pulse. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">MaxB1 (T) : The maximum B1 field
     </li>
     <li class="itemize">MaxFreq (Hz) : The maximum RF frequency
     </li>
     <li class="itemize">BIREFFlag : The type of BIREF pulse, including &#8216;BIREF-1&#8217;, &#8216;BIREF-2a&#8217;
     and &#8216;BIREF-2b&#8217;
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time
     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1409--><p class="indent" >   The time dependence of the BIREF-1 RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>: <br 
class="newline" />Amplitude modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-51001r17"></a>

   <center class="math-display" >
<img 
src="MRiLab_User_Guide24x.png" alt="      {
        &#x02C6;xA0sin(&#x03BE;t)   0 &#x2264; t &#x003C; T2
A(t) =  - &#x02C6;xA0sin(&#x03BE;t) T&#x2264; t &#x2264; T
                     2
" class="math-display" ></center></td><td class="equation-label">(5.17)</td></tr></table>
<!--l. 1418--><p class="nopar" >
<br 
class="newline" />Frequency modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-51002r18"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide25x.png" alt="F (t) = F |cos(&#x03BE;t)|
        0
" class="math-display" ></center></td><td class="equation-label">(5.18)</td></tr></table>
<!--l. 1424--><p class="nopar" >
<!--l. 1426--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">F</span><sub><span 
class="cmr-7">0</span></sub> is the
maximum RF frequency corresponding to MaxFreq. The RF pulse width is
<span 
class="cmmi-10">T </span>= <img 
src="MRiLab_User_Guide26x.png" alt="&#x03C0;
&#x03BE;"  class="frac" align="middle">, and <img 
src="MRiLab_User_Guide27x.png" alt="&#x02C6;x"  class="circ" > is an unit vector for indicating RF phase along the <span 
class="cmmi-10">x </span>axis.
<br 
class="newline" />
<!--l. 1428--><p class="indent" >   The time dependence of the BIREF-2a RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>: <br 
class="newline" />Amplitude modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-51003r19"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide28x.png" alt="A (t) = &#x02C6;xA0|cos(&#x03BE;t)|
" class="math-display" ></center></td><td class="equation-label">(5.19)</td></tr></table>
<!--l. 1433--><p class="nopar" >
<br 
class="newline" />Frequency modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-51004r20"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide29x.png" alt="       {
        F0sin(&#x03BE;t)   0 &#x2264; t &#x003C; T2
F (t) =  - F0sin(&#x03BE;t)  T-&#x2264; t &#x2264; T
                    2
" class="math-display" ></center></td><td class="equation-label">(5.20)</td></tr></table>
<!--l. 1443--><p class="nopar" >
<!--l. 1445--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">F</span><sub><span 
class="cmr-7">0</span></sub> is the
maximum RF frequency corresponding to MaxFreq. The RF pulse width is
<span 
class="cmmi-10">T </span>= <img 
src="MRiLab_User_Guide30x.png" alt="&#x03C0;
&#x03BE;"  class="frac" align="middle">, and <img 
src="MRiLab_User_Guide31x.png" alt="&#x02C6;x"  class="circ" > is an unit vector for indicating RF phase along the <span 
class="cmmi-10">x </span>axis.
<br 
class="newline" />
<!--l. 1447--><p class="indent" >   The time dependence of the BIREF-2b RF pulse is given by <span class="cite">[<a 
href="#XHandbook2004">6</a>]</span>: <br 
class="newline" />Amplitude modulation:
   <table 
class="equation"><tr><td><a 
 id="x3-51005r21"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide32x.png" alt="      {                    T
A(t) =  &#x02C6;xA0|cos(&#x03BE;t)|  0 &#x2264; t &#x003C; 2
        - &#x02C6;xA0cos(&#x03BE;t) T2 &#x2264; t &#x2264; T
" class="math-display" ></center></td><td class="equation-label">(5.21)</td></tr></table>
<!--l. 1456--><p class="nopar" >
<br 
class="newline" />Frequency modulation:

   <table 
class="equation"><tr><td><a 
 id="x3-51006r22"></a>
   <center class="math-display" >
<img 
src="MRiLab_User_Guide33x.png" alt="      (
      |{ F0sin(&#x03BE;t)   0 &#x2264; t &#x003C; T4
F(t) =  - F0sin(&#x03BE;t) T4 &#x2264; t &#x003C; 34T
      |( F0sin(&#x03BE;t)   3T &#x2264; t &#x2264; T
                    4
" class="math-display" ></center></td><td class="equation-label">(5.22)</td></tr></table>
<!--l. 1467--><p class="nopar" >
<!--l. 1469--><p class="indent" >   where <span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">0</span></sub> is the maximum B1 field corresponding to MaxB1, <span 
class="cmmi-10">F</span><sub><span 
class="cmr-7">0</span></sub> is the
maximum RF frequency corresponding to MaxFreq. The RF pulse width is
<span 
class="cmmi-10">T </span>= <img 
src="MRiLab_User_Guide34x.png" alt="2&#x03C0;-
&#x03BE;"  class="frac" align="middle">, and <img 
src="MRiLab_User_Guide35x.png" alt="x&#x02C6;"  class="circ" > is an unit vector for indicating RF phase along the <span 
class="cmmi-10">x </span>axis.
<br 
class="newline" />
<!--l. 1471--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-520005.1.2"></a>rfRandom</h5>
<!--l. 1473--><p class="noindent" >A RF macro that creates a RF pulse with normally distributed pseudo-random
amplitude. This macro is used for program testing purpose, however it shows that
almost any arbitrary RF pulse could potentially be supported by MRiLab. This
macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">rfGain : The standard deviation of the normal distribution
     </li>
     <li class="itemize">dt (s) : The time interval of RF pulse sample points
     </li>
     <li class="itemize">rfPhase (rad) : RF pulse phase
     </li>
     <li class="itemize">rfFreq (Hz) : RF pulse frequency
     </li>
     <li class="itemize">tStart (s) : RF pulse starting time

     </li>
     <li class="itemize">tEnd (s) : RF pulse ending time
     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1490--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-530005.1.2"></a>rfUser</h5>
<!--l. 1492--><p class="noindent" >If the user has the RF pulse waveform data saved in a MAT file, the user can easily
import the RF file into MRiLab pulse design interface by using &#8216;rfUser&#8217; macro. The
RF pulse MAT file needs to contain four matrices including &#8216;rfTime&#8217; (i.e. RF time
points) , &#8216;rfAmp&#8217; (i.e. RF amplitude), &#8216;rfPhase&#8217; (i.e. RF phase) and &#8216;rfFreq&#8217; (i.e. RF
frequency). All four matrices must have the same size of m-by-n, where m is the
number of TR sections and n is the number of RF waveform points. In typical MR
sequence, the entire sequence is composed of multiple TR sections. The
<span 
class="cmmi-10">i</span>th TR section uses the <span 
class="cmmi-10">i</span>th RF pulse stored in the <span 
class="cmmi-10">i</span>th row of these four
matrices. If the number of row is less than the number of TR sections, the
last RF pulse will be used for all the remaining TR sections. Notice that
if &#8216;rfPhase&#8217; and/or &#8216;rfFreq&#8217; are not provided, MRiLab initializes them as
a value of 0. However, &#8216;rfTime&#8217; and &#8216;rfAmp&#8217; must be provided. Also note
that MRiLab only uses the first RF pulse in the MAT file for pulse analysis
in the RF pulse design interface. The &#8216;rfUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">rfFile : The path to the file that stores the RF pulse data, quoted using
     single quotes

     </li>
     <li class="itemize">Switch : The flag for turning on and off RF pulse in the RF sequence line
     </li>
     <li class="itemize">AnchorTE : The flag for turning on and off TE reference, TE is calculated
     from this RF pulse if this flag is turned on
     </li>
     <li class="itemize">Duplicates : The number of the RF pulse duplicates, used for creating
     multiple RF pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between RF pulse duplicates
     </li>
     <li class="itemize">CoilID : The ID of the coil element used with this RF pulse, applied for
     multiple RF transmitting
     </li>
     <li class="itemize">Notes : The notes of the RF pulse</li></ul>
<!--l. 1504--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
 id="x3-540005.1.3"></a>Make New RF Macro</h4>
<!--l. 1506--><p class="noindent" >The RF pulse macro library covers several common types of RF pulse waveform.
However, comprehensive coverage of existing and under developed RF pulses is nearly
impossible for almost any pulse sequence design tools. To address this problem in
MRiLab, the user can use the &#8216;rfUser&#8217; to import RF pulses from files that are
generated by other programs. Another way to import RF pulse is to simply write a
RF macro. To create a RF macro, the user should follow the following steps
:
<!--l. 1508--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-54002x1">Write RF macro code <br 
class="newline" />
     <!--l. 1512--><p class="noindent" >It is strongly recommended to write your own RF macro code based on the
     closest RF macros in the MRiLab macro library, for example, the &#8216;rfRect&#8217;
     macro is coded as:

     <div class="verbatim" id="verbatim-2">
     function&#x00A0;[rfAmp,rfPhase,rfFreq,rfCoil,rfTime]=rfRect(p)
     &#x00A0;<br />%Create&#x00A0;a&#x00A0;hard&#x00A0;RF&#x00A0;pulse&#x00A0;starting&#x00A0;from&#x00A0;tStart&#x00A0;and&#x00A0;ending&#x00A0;at&#x00A0;tEnd
     &#x00A0;<br />%tStart&#x00A0;RF&#x00A0;start&#x00A0;time
     &#x00A0;<br />%tEnd&#x00A0;RF&#x00A0;end&#x00A0;time
     &#x00A0;<br />%FA&#x00A0;RF&#x00A0;actual&#x00A0;flip&#x00A0;angle
     &#x00A0;<br />%dt&#x00A0;RF&#x00A0;sample&#x00A0;time
     &#x00A0;<br />%rfPhase&#x00A0;RF&#x00A0;phase
     &#x00A0;<br />%rfFreq&#x00A0;RF&#x00A0;off-res&#x00A0;freq
     &#x00A0;<br />
     &#x00A0;<br />tStart=p.tStart;
     &#x00A0;<br />tEnd=p.tEnd;
     &#x00A0;<br />FA=p.FA;
     &#x00A0;<br />dt=p.dt;
     &#x00A0;<br />rfPhase=p.rfPhase;
     &#x00A0;<br />rfFreq=p.rfFreq;
     &#x00A0;<br />rfCoil=p.CoilID;
     &#x00A0;<br />Duplicates=max(1,p.Duplicates);
     &#x00A0;<br />DupSpacing=max(0,p.DupSpacing);
     &#x00A0;<br />
     &#x00A0;<br />rfTime=linspace(tStart,tEnd,ceil((tEnd-tStart)/dt)+1);
     &#x00A0;<br />rfAmp=ones(size(rfTime));&#x00A0;%&#x00A0;Rectangle
     &#x00A0;<br />rfAmp(1)=0;
     &#x00A0;<br />rfAmp(end)=0;
     &#x00A0;<br />rfAmp=DoB1Scaling(rfAmp,dt,FA)*rfAmp;&#x00A0;%B1&#x00A0;Scaling
     &#x00A0;<br />
     &#x00A0;<br />rfPhase=(rfPhase)*ones(size(rfTime));
     &#x00A0;<br />rfFreq=(rfFreq)*ones(size(rfTime));
     &#x00A0;<br />rfCoil=(rfCoil)*ones(size(rfTime));
     &#x00A0;<br />rfPhase(1)=0;
     &#x00A0;<br />rfPhase(end)=0;
     &#x00A0;<br />rfFreq(1)=0;
     &#x00A0;<br />rfFreq(end)=0;
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;Create&#x00A0;Duplicates
     &#x00A0;<br />if&#x00A0;Duplicates~=1&#x00A0;&amp;&#x00A0;DupSpacing&#x00A0;~=0
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfAmp=repmat(rfAmp,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfFreq=repmat(rfFreq,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfPhase=repmat(rfPhase,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfCoil=repmat(rfCoil,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;TimeOffset&#x00A0;=&#x00A0;repmat(0:DupSpacing:(Duplicates-1)*DupSpacing,&#x00A0;...
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[length(rfTime)&#x00A0;1]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfTime=repmat(rfTime,[1&#x00A0;Duplicates])&#x00A0;+&#x00A0;(TimeOffset(:))&#8217;;

     &#x00A0;<br />end
     &#x00A0;<br />
     &#x00A0;<br />end
</div>
     <!--l. 1560--><p class="nopar" >
     <!--l. 1562--><p class="noindent" >Your macro must start from a function declaration at the beginning, then
     followed by attribute input section. The &#8216;tStart&#8217; and &#8216;tEnd&#8217; need to be added
     for indicating the time scale. It&#8217;s also strongly recommended to add attribute
     input &#8216;rfCoil&#8217;,&#8216;Duplicates&#8217; and &#8216;DupSpacing&#8217; for multi-transmitting and
     multi-echo support.

     <div class="verbatim" id="verbatim-3">
     function&#x00A0;[rfAmp,rfPhase,rfFreq,rfCoil,rfTime]=rfMacroName(p)
     &#x00A0;<br />%Create&#x00A0;a&#x00A0;RF&#x00A0;pulse&#x00A0;based&#x00A0;on&#x00A0;user&#x00A0;code
     &#x00A0;<br />
     &#x00A0;<br />tStart=p.tStart;
     &#x00A0;<br />tEnd=p.tEnd;
     &#x00A0;<br />rfCoil=p.CoilID;
     &#x00A0;<br />Duplicates=max(1,p.Duplicates);
     &#x00A0;<br />DupSpacing=max(0,p.DupSpacing);
     &#x00A0;<br />...
     &#x00A0;<br />attribute1=p.attribute1;
     &#x00A0;<br />attribute2=p.attribute2;
     &#x00A0;<br />attribute3=p.attribute3;
     &#x00A0;<br />...
</div>
     <!--l. 1578--><p class="nopar" >
     <!--l. 1580--><p class="noindent" >The main code should deal with calculation for &#8216;rfAmp&#8217;, &#8216;rfPhase&#8217;, &#8216;rfFreq&#8217; and
     &#8216;rfTime&#8217;. Notice that they should have the same size as 1-by-m where m is the
     number of RF waveform points.

     <div class="verbatim" id="verbatim-4">
     %&#x00A0;The&#x00A0;main&#x00A0;code&#x00A0;for&#x00A0;user&#x00A0;macro
     &#x00A0;<br />...
     &#x00A0;<br />rfTime&#x00A0;=&#x00A0;...;
     &#x00A0;<br />rfAmp&#x00A0;=&#x00A0;...;
     &#x00A0;<br />rfPhase&#x00A0;=&#x00A0;...;
     &#x00A0;<br />rfFreq&#x00A0;=&#x00A0;...;
     &#x00A0;<br />...
</div>
     <!--l. 1590--><p class="nopar" >
     <!--l. 1593--><p class="noindent" >Then you should add several lines to end your macro,

     <div class="verbatim" id="verbatim-5">
     %&#x00A0;Avoid&#x00A0;baseline&#x00A0;offset
     &#x00A0;<br />rfAmp(1)=0;
     &#x00A0;<br />rfAmp(end)=0;
     &#x00A0;<br />rfPhase(1)=0;
     &#x00A0;<br />rfPhase(end)=0;
     &#x00A0;<br />rfFreq(1)=0;
     &#x00A0;<br />rfFreq(end)=0;
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;Assign&#x00A0;coil&#x00A0;element&#x00A0;index&#x00A0;number
     &#x00A0;<br />rfCoil=(rfCoil)*ones(size(rfTime));
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;Create&#x00A0;Duplicates
     &#x00A0;<br />if&#x00A0;Duplicates~=1&#x00A0;&amp;&#x00A0;DupSpacing&#x00A0;~=0
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfAmp=repmat(rfAmp,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfFreq=repmat(rfFreq,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfPhase=repmat(rfPhase,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfCoil=repmat(rfCoil,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;TimeOffset=repmat(0:DupSpacing:(Duplicates-1)*DupSpacing,&#x00A0;...
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[length(rfTime)&#x00A0;1]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;rfTime=repmat(rfTime,[1&#x00A0;Duplicates])&#x00A0;+&#x00A0;(TimeOffset(:))&#8217;;
     &#x00A0;<br />end
     &#x00A0;<br />
</div>
     <!--l. 1618--><p class="nopar" >
     </li>
     <li 
  class="enumerate" id="x3-54004x2">Register RF macro <br 
class="newline" />
     <!--l. 1622--><p class="noindent" >The RF macro file can be located anywhere in the computer as long as the
     file is included in Matlab searching path, however it is recommended
     to save the file under /SeqElem/rf for consistent file organization.
     Besides a RF macro file that performs pulse generation, MRiLab also
     requires a memo .txt file that accompanies the RF macro with the name
     &#8216;rfMacroName_Memo&#8217;. This file contains information about RF pulse
     description if necessary.
     <!--l. 1624--><p class="noindent" >The customized RF macro needs to be registered in the macro library before
     using. To register a macro, open file &#8216;SeqElem.xml&#8217; under /SeqElem, then add
     one entry under <span 
class="cmmi-10">&#x003C;</span>rf<span 
class="cmmi-10">&#x003E; </span>category with the proper attribute list. One example
     could be

     <div class="verbatim" id="verbatim-6">
     &#x003C;rfMacroName
     &#x00A0;<br />AnchorTE="$2&#8217;on&#8217;,&#8217;off&#8217;"
     &#x00A0;<br />CoilID="1"
     &#x00A0;<br />DupSpacing="0"
     &#x00A0;<br />Duplicates="1"
     &#x00A0;<br />Switch="$1&#8217;on&#8217;,&#8217;off&#8217;"
     &#x00A0;<br />tEnd="1e-3"
     &#x00A0;<br />tStart="0"
     &#x00A0;<br />Notes="A&#x00A0;new&#x00A0;RF&#x00A0;macro"
     &#x00A0;<br />attribute1="0"
     &#x00A0;<br />attribute2="0"
     &#x00A0;<br />attribute3="0"&#x00A0;/&#x003E;
</div>
     <!--l. 1639--><p class="nopar" >
     <!--l. 1641--><p class="noindent" >Notice that in the above example, the first 7 attributes are required
     for MRiLab, The remaining attributes are optional based on user&#8217;s
     choice.
     </li></ol>
<!--l. 1645--><p class="indent" >   Once the RF macro is coded and registered to the library, the user can use this
customized RF macro just like those default RF macros in the library.
<!--l. 1647--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.2   </span> <a 
 id="x3-550005.2"></a>MR Sequence Design</h3>
<!--l. 1649--><p class="noindent" >The MR Sequence Design toolbox can be activated by pressing &#8216;Sequence Design
Panel&#8217; toolbar icon located at the top of the main simulation console. The current
loaded sequence will show in the MR Sequence Design interface.
<!--l. 1651--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-5500110"></a>


<!--l. 1653--><p class="noindent" ><img 
src="Pictures/SequenceDesignPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.10: </span><span  
class="content">Sequence Design Panel Toolbar Icon</span></div><!--tex4ht:label?: x3-5500110 -->

<!--l. 1656--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.2.1   </span> <a 
 id="x3-560005.2.1"></a>Sequence Design GUI</h4>
<!--l. 1660--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-5600111"></a>


<!--l. 1662--><p class="noindent" ><img 
src="Pictures/SequenceDesignGUI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.11: </span><span  
class="content">Sequence Design Panel. A bSSFP sequence is shown.</span></div><!--tex4ht:label?: x3-5600111 -->

<!--l. 1665--><p class="noindent" ></div><hr class="endfigure">
<!--l. 1667--><p class="indent" >   Figure <a 
href="#x3-5600111">5.11<!--tex4ht:ref: fig:SequenceDesignGUI --></a> demonstrates an overview of the MR Sequence Design interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-56003x1">Macro Library <br 
class="newline" />
     <!--l. 1672--><p class="noindent" >The Macro Library contains a full set of pulse macros for constructing MR
     sequence in MRiLab. It covers not only RF macro library as described
     in above section, but also GzSS, GyPE and GxR gradient macro library,
     ADC macro library and Ext macro library. The user needs to click the
     &#8216;SeqElem&#8217; root as well as the subsequent nodes to unfold those macros.
     </li>
     <li 
  class="enumerate" id="x3-56005x2">Sequence Structure <br 
class="newline" />
     <!--l. 1676--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5600612"></a>   <img 
src="Pictures/SequenceStructure.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.12: </span><span  
class="content">An Example of A Typical MR Sequence Structure in MRiLab</span></div><!--tex4ht:label?: x3-5600612 -->
     <!--l. 1681--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 1684--><p class="noindent" >In MRiLab, a MR sequence consists of the following parts :
         <ul class="itemize1">
         <li class="itemize">CVs : The controllable variables, linked to the &#8216;CVs&#8217; tab on the main
         control console
         </li>
         <li class="itemize">Specials : The applied special techniques by default
         </li>
         <li class="itemize">SE : The starting (tS) and ending (tE) time, determining time scale
         for each TR section, support varying TR value
         </li>
         <li class="itemize">Pulse
             <ul class="itemize2">
             <li class="itemize">RF : RF sequence line
             </li>
             <li class="itemize">GzSS : GzSS sequence line
             </li>
             <li class="itemize">GyPE : GyPE sequence line
             </li>
             <li class="itemize">GxR : GxR sequence line
             </li>
             <li class="itemize">ADC : Signal acquisition sequence line
             </li>
             <li class="itemize">Ext : Extended process sequence line</li></ul>

         </li></ul>
     <!--l. 1701--><p class="noindent" >The user can construct desired MR sequence by changing the content of the
     MR sequence structure. To add a macro into the sequence structure, click one
     macro in the macro library, then click on the sequence line root (e.g. rf) to
     which this macro is inserted, then click &#8216;+&#8217; macro operation button. To delete
     a macro from the sequence structure, click the unwanted macro at
     the sequence line, then click &#8216;-&#8217; macro operation button. To duplicate
     an existing macro, first click the source macro, then click &#8216;C&#8217; macro
     operation button for copying, click on the sequence line root, then
     click &#8216;P&#8217; macro operation button for pasting. MRiLab requires the
     pulse macro being operated within its belonging category (e.g. RF
     pulse can&#8217;t be added to gradient line). Also empty sequence line is
     prohibited.
     <!--l. 1703--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5600713"></a>   <img 
src="Pictures/MacroOperationButton.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.13: </span><span  
class="content">Macro Operation Buttons</span></div><!--tex4ht:label?: x3-5600713 -->
     <!--l. 1708--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-56009x3">Pulse Attribute <br 
class="newline" />
     <!--l. 1712--><p class="noindent" >Upon clicking on a pulse macro within a MR sequence structure, the
     corresponding macro attributes will be shown at the pulse attribute panel down
     below the sequence structure. The user can edit those attributes to modify the
     sequence waveform. To make any modification effective, the user must press
     &#8216;Update&#8217; button to update the associated sequence XML file. Pressing &#8216;Execute&#8217;
     button will update and redraw the MR sequence waveform plotting on this
     interface.
     </li>
     <li 
  class="enumerate" id="x3-56011x4">Sequence Waveform <br 
class="newline" />
     <!--l. 1716--><p class="noindent" >The sequence waveform associated with the sequence structure is displayed on
     the &#8216;Sequence Diagram&#8217; panel on the right side of this interface. The user can
     use the waveform diagram to inspect sequence details and layout. The sequence
     diagram consists of individual sequence lines corresponding to RF, GzSS,
     GyPE, GxR, ADC and Ext, respectively. To accommodate multiple RF
     transmitting, MRiLab provides separate RF sequence lines for each RF source.
     When &#8216;MultiTransmit&#8217; flag is turned on in the main control console and the
     chosen sequence structure contains multiple RF pulses for different RF sources
     (i.e. assign RF pulses to different coil channels by using &#8216;CoilID&#8217; attribute),
     the multi-tab will be activated on the &#8216;rf Source&#8217; panel (Figure <a 
href="#x3-5601214">5.14<!--tex4ht:ref: fig:RFSource --></a>).
     The user can switch between these tabs for checking individual RF
     source.
     <!--l. 1718--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5601214"></a>   <img 
src="Pictures/RFSource.png" alt="pict"  
>

<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.14: </span><span  
class="content">An Example of Multiple RF Source. The &#8216;MultiTransmit&#8217; is turned
on and this sequence contains total 4 RF sources. The RF source 2 is chosen
and the corresponding RF pulse waveform for coil channel 2 is shown.</span></div><!--tex4ht:label?: x3-5601214 -->
     <!--l. 1723--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 1725--><p class="noindent" >Notice that the vertical axes for all sequence lines are normalized and the
     horizontal axes are in units of milliseconds. MRiLab provides a group of
     sequence display button (Figure <a 
href="#x3-5601315">5.15<!--tex4ht:ref: fig:SequenceDisplayButton --></a>) to help inspect the sequence waveform
     details.
     <!--l. 1727--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5601315"></a>   <img 
src="Pictures/SequenceDisplayButton.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.15: </span><span  
class="content">The Sequence Display Button.</span></div><!--tex4ht:label?: x3-5601315 -->
     <!--l. 1732--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 1734--><p class="noindent" >The sequence display button group consists of :
         <ul class="itemize1">
         <li class="itemize">Checker : The time checker toggle button
         </li>
         <li class="itemize">Time Ruler : Display current time point according to the time checker
         </li>
         <li class="itemize"><span 
class="cmsy-10">| </span><span 
class="cmmi-10">&#x003C;&#x003C;</span>: Move sequence waveform to the beginning
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003C;&#x003C;&#x003C; </span>: Move sequence waveform backwards
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E; </span><span 
class="cmsy-10">|| </span><span 
class="cmmi-10">&#x003C; </span>: Zoom out
         </li>
         <li class="itemize">TR : Display a sequence waveform section with a time interval of TR
         </li>
         <li class="itemize">ALL : Display all sequence waveform
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003C; </span><span 
class="cmsy-10">|| </span><span 
class="cmmi-10">&#x003E; </span>: Zoom in
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E;&#x003E;&#x003E;</span>: Move sequence waveform forwards
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E;&#x003E; </span><span 
class="cmsy-10">| </span>: Move sequence waveform to the end</li></ul>
     <!--l. 1749--><p class="noindent" >The user can use the &#8216;Checker&#8217; toggle button to display a sequence waveform at
     any arbitrary time interval (Figure <a 
href="#x3-5601416">5.16<!--tex4ht:ref: fig:AllSequence --></a>). First press the &#8216;Checker&#8217; button,
     move the mouse cursor into the axes. Notice that the mouse cursor
     changes to a cross-hair. Move the cross-hair in the axes, the amplitude
     value for each sequence line will be displayed accordingly on right
     side of each line with their default units. The user can click on the
     axes to choose one side of the time slot, then click on the another
     side. MRiLab will change the sequence view between the chosen time

     points, and also save time point information in the list at the bottom of
     this interface. To disable &#8216;Checker&#8217; function, simple press this button
     again.
     <!--l. 1751--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5601416"></a>   <img 
src="Pictures/AllSequence.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.16: </span><span  
class="content">A Sequence View with Multiple TRs.</span></div><!--tex4ht:label?: x3-5601416 -->
     <!--l. 1756--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-56016x5">Display Control
     <!--l. 1760--><p class="noindent" >The &#8216;Display&#8217; tab on the &#8216;Sequence Display&#8217; contains parameters for controlling
     sequence display and K-Space rendering.
         <ul class="itemize1">
         <li class="itemize">TRStart : The first TR to be displayed
         </li>
         <li class="itemize">TREnd : The last TR to be displayed
         </li>
         <li class="itemize">Moments  (:TODO)  :  The  flag  for  turning  on  and  off  the  zeroth
         moment display for the gradient
         </li>
         <li class="itemize">RenderMode  :  The  K-Space  rendering  mode,  including  &#8216;Matlab&#8217;
         (Figure <a 
href="#x3-5601717">5.17<!--tex4ht:ref: fig:MatlabSpiral --></a>) and &#8216;VTK&#8217; (Figure <a 
href="#x3-5601818">5.18<!--tex4ht:ref: fig:VTK --></a>)
         </li>
         <li class="itemize">RenderPoint : The flag for turning on and off K-Space point rendering</li></ul>
     <!--l. 1770--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5601717"></a>   <img 
src="Pictures/MatlabSpiral.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.17: </span><span  
class="content">Matlab Rendered K-Space Trajectory for A Spiral Readout with 5
Interleaves. The left figure is without K-Space point rendering. The right figure
is with K-Space point rendering with the arrows indicating K-Space traversing
direction.</span></div><!--tex4ht:label?: x3-5601717 -->
     <!--l. 1775--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 1777--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-5601818"></a>   <img 
src="Pictures/VTK.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.18: </span><span  
class="content">VTK Rendered K-Space Trajectory Examples. The top left figure
shows a typical single slice Cartesian readout. The top right figure shows a
single slice multishot EPI readout. The bottom left figure shows a single slice
multishot spiral readout. The bottom right figure shows a 3D Stack-of-Stars
radial readout.</span></div><!--tex4ht:label?: x3-5601818 -->
     <!--l. 1782--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 1784--><p class="noindent" >Notice that in VTK rendering, the K-Space line color starts from green
     and ends to red. If the user uses VTK for K-Space rendering, please
     press keyboard &#8216;q&#8217; to quit the VTK window before any subsequent
     simulation. Pressing the quit button on the VTK window under Linux
     system will force the entire Matlab to close, this is &#8216;believed&#8217; to be

     a compatibility bug between Matlab and OpenGL which is used by
     VTK.
     </li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.2.2   </span> <a 
 id="x3-570005.2.2"></a>Virtual Structure</h4>
<!--l. 1789--><p class="noindent" >For the convenience of transferring data and configuration information across
different modules, MRiLab defined several Matlab structure variables in the global
scope. These structures start with &#8216;V&#8217; standing for &#8216;Virtual Structure&#8217;. Understanding
what these structures are and how they are working is important to work with
MRiLab and to customize specific experiment design. There are at least two virtual
structures that are useful for designing MR sequences.
     <ul class="itemize1">
     <li class="itemize">VCtl : Virtual Control <br 
class="newline" />VCtl encapsules all the simulation setting parameters in the main control
     console. For example, the user can use &#8216;VCtl.TE&#8217; to reference &#8216;TE&#8217; value
     in the main control console; use &#8216;VCtl.FlipAng&#8217; to reference &#8216;FlipAng&#8217;
     value in the main control console. VCtl also allows the user to reference
     parameters  in  special  techniques  if  loaded.  Another  example  is  that
     MRiLab uses &#8216;VCtl.TR&#8217; in the &#8216;SE&#8217; for determining time interval for each
     TR section. The user can use any legal Matlab syntax combined with VCtl
     to create desired effect, such as use &#8216;2 * VCtl.TR&#8217; to indicate twice of &#8216;TR&#8217;
     value.
     </li>
     <li class="itemize">VVar : Virtual Variable <br 
class="newline" />VVar encapsules the loop index variables that MRiLab uses for generating
     MR sequence waveform. A section of code for generating MR sequence is
     shown:

     <div class="verbatim" id="verbatim-7">
     %&#x00A0;MR&#x00A0;Sequence&#x00A0;Generating&#x00A0;Loop
     &#x00A0;<br />VVar.SliceCount=0;
     &#x00A0;<br />VVar.PhaseCount=0;
     &#x00A0;<br />VVar.TRCount=0;
     &#x00A0;<br />s=1;
     &#x00A0;<br />j=1;
     &#x00A0;<br />
     &#x00A0;<br />while&#x00A0;s&#x003C;=VCtl.SecondPhNum
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;VVar.SliceCount=s;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;while&#x00A0;j&#x003C;=VCtl.FirstPhNum
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;VVar.PhaseCount=j;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;VVar.TRCount=VVar.TRCount+1;
     &#x00A0;<br />
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;...
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%Sequence&#x00A0;Generating&#x00A0;Code
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;...
     &#x00A0;<br />
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;j=j+1;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;end
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;j=1;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;s=s+1;
     &#x00A0;<br />end
</div>
     <!--l. 1820--><p class="nopar" >
     <!--l. 1822--><p class="noindent" >The user can use the loop index variables in VVar
         <ul class="itemize2">
         <li class="itemize">VVar.TRCount : The TR section index
         </li>
         <li class="itemize">VVar.PhaseCount : The first phase encoding index
         </li>
         <li class="itemize">VVar.SliceCount : The second (i.e. slice) phase encoding index
         </li>
         <li class="itemize">VCtl.FirstPhNum : The total number of first phase encoding steps
         </li>
         <li class="itemize">VCtl.SecondPhNum : The total number of second phase encoding
         steps</li></ul>
     <!--l. 1832--><p class="noindent" >For example, to create 180<sup><span 
class="cmsy-7">&#x2218;</span></sup> RF phase cycling in bSSFP sequence, the user can
     set the attributes for the excitation RF pulse as

         <ul class="itemize2">
         <li class="itemize">CV3 : 2*pi/2
         </li>
         <li class="itemize">CV4 : 2
         </li>
         <li class="itemize">rfPhase : rem(VVar.TRCount-1,CV4)*CV3</li></ul>
     </li></ul>
<!--l. 1843--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.3   </span> <a 
 id="x3-580005.2.3"></a>GzSS Macro Library</h4>
<!--l. 1845--><p class="noindent" >A GzSS macro is a predefined module for a gradient pulse on the GzSS sequence line.
MRiLab GzSS macro library is a collection of GzSS macros covering different
gradient pulse types including slice selection and slice phase encoding pulses.
Notice that by default the area under the gradient ramp is ignored. This
section will give an introduction to each of the GzSS macros provided in
MRiLab.
<!--l. 1847--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-590005.2.3"></a>GzSelective</h5>
<!--l. 1849--><p class="noindent" >A GzSS macro that creates a typical slice selective gradient pulse (Figure <a 
href="#x3-5900119">5.19<!--tex4ht:ref: fig:GzSelective --></a>). This
macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t2Start (s) : Slice selection gradient pulse starting time
     </li>
     <li class="itemize">t2End (s) : Slice selection gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">GzAmp (T) : The amplitude of the gradient
     </li>
     <li class="itemize">Gz1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gz2Sign : The polarity of the slice selection gradient, set 0 for nulling

     </li>
     <li class="itemize">Gz3Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 1865--><p class="indent" >   Notice that both the prephasing gradient and rephasing gradient have half of the
area of the slice selection gradient.
<!--l. 1867--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-5900119"></a>


<!--l. 1869--><p class="noindent" ><img 
src="Pictures/GzSelective.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.19: </span><span  
class="content">GzSelective Waveform</span></div><!--tex4ht:label?: x3-5900119 -->

<!--l. 1872--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-600005.2.3"></a>GzSelective2</h5>
<!--l. 1877--><p class="noindent" >A GzSS macro that creates a slice selective gradient pulse straddled with crusher
gradient (Figure <a 
href="#x3-6000120">5.20<!--tex4ht:ref: fig:GzSelective2 --></a>). This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t2Start (s) : Slice selection gradient pulse starting time
     </li>
     <li class="itemize">t2End (s) : Slice selection gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">tGz1 (s) : The duration of the left crusher
     </li>
     <li class="itemize">tGz3 (s) : The duration of the right crusher
     </li>
     <li class="itemize">Gz1Amp (T) : The amplitude of the left crusher
     </li>
     <li class="itemize">Gz2Amp (T) : The amplitude of the slice selective gradient
     </li>
     <li class="itemize">Gz3Amp (T) : The amplitude of the right crusher
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 1894--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-6000120"></a>


<!--l. 1896--><p class="noindent" ><img 
src="Pictures/GzSelective2.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.20: </span><span  
class="content">GzSelective2 Waveform</span></div><!--tex4ht:label?: x3-6000120 -->

<!--l. 1899--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-610005.2.3"></a>GzTrapezoid</h5>
<!--l. 1904--><p class="noindent" >A GzSS macro that creates a trapezoid gradient pulse (Figure <a 
href="#x3-6100121">5.21<!--tex4ht:ref: fig:GzTrapezoid --></a>) on GzSS
sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">tEnd (s) : The trapezoid gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : The trapezoid pulse ramp time, assume symmetric ramp on
     both side
     </li>
     <li class="itemize">sRamp : The sample points on the ramp, use the value of 2 for ignoring
     the area under the ramp, use above 2 for counting the ramp area
     </li>
     <li class="itemize">GzAmp (T) : The amplitude of the gradient
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 1918--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-6100121"></a>


<!--l. 1920--><p class="noindent" ><img 
src="Pictures/GzTrapezoid.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.21: </span><span  
class="content">GzTrapezoid Waveform</span></div><!--tex4ht:label?: x3-6100121 -->

<!--l. 1923--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-620005.2.3"></a>GzAreaTrapezoid</h5>
<!--l. 1928--><p class="noindent" >A GzSS macro that creates a trapezoid gradient pulse of specified area (Figure <a 
href="#x3-6200122">5.22<!--tex4ht:ref: fig:GzAreaTrapezoid --></a>)
on GzSS sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">tEnd (s) : The trapezoid gradient pulse ending time
     </li>
     <li class="itemize">Area (1/m) : The area under this gradient pulse
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 1940--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-6200122"></a>


<!--l. 1942--><p class="noindent" ><img 
src="Pictures/GzAreaTrapezoid.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.22: </span><span  
class="content">GzAreaTrapezoid Waveform</span></div><!--tex4ht:label?: x3-6200122 -->

<!--l. 1945--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-630005.2.3"></a>GzAreaTrapezoid2</h5>
<!--l. 1949--><p class="noindent" >A GzSS macro that creates a trapezoid gradient pulse of specified area with highest
system performance (Figure <a 
href="#x3-6300123">5.23<!--tex4ht:ref: fig:GzAreaTrapezoid2 --></a>) on GzSS sequence line. This macro creates a
gradient pulse with nearly shortest pulse width for the given system hardware
constraint. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">Area (1/m) : The area under this gradient pulse
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 1960--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-6300123"></a>


<!--l. 1962--><p class="noindent" ><img 
src="Pictures/GzAreaTrapezoid2.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.23: </span><span  
class="content">GzAreaTrapezoid2 Waveform</span></div><!--tex4ht:label?: x3-6300123 -->

<!--l. 1965--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-640005.2.3"></a>GzCartesian</h5>
<!--l. 1969--><p class="noindent" >A GzSS macro that creates a Cartesian phase encoding gradient pulse (Figure <a 
href="#x3-6400124">5.24<!--tex4ht:ref: fig:GzCartesian --></a>)
along the slice direction. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t1Start (s) : The phase encoding gradient pulse starting time
     </li>
     <li class="itemize">t1End (s) : The phase encoding gradient pulse ending time
     </li>
     <li class="itemize">t2Start (s) : The rephasing gradient pulse starting time
     </li>
     <li class="itemize">t2End (s) : The rephasing gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">Gz1Sign : The polarity of the phase encoding gradient, set 0 for nulling
     </li>
     <li class="itemize">Gz2Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 1985--><p class="indent" >   Notice that the phase encoding gradient and the rephasing gradient have the
same area that is automatically calculated based on the imaging parameters in the
main control console.
<!--l. 1987--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-6400124"></a>


<!--l. 1989--><p class="noindent" ><img 
src="Pictures/GzCartesian.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.24: </span><span  
class="content">GzCartesian Waveform</span></div><!--tex4ht:label?: x3-6400124 -->

<!--l. 1992--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-650005.2.3"></a>GzUser</h5>
<!--l. 1996--><p class="noindent" >If the user has the gradient pulse data saved in a MAT file, the user can easily import
the gradient file into MRiLab by using &#8216;GzUser&#8217; macro. The gradient pulse MAT file
needs to contain two matrices including &#8216;GTime&#8217; (i.e. gradient time points) and
&#8216;GAmp&#8217; (i.e. gradient amplitude). Both matrices must have the same size
of m-by-n, where m is the number of TR sections and n is the number of
gradient waveform points. In typical MR sequence, the entire sequence is
composed of multiple TR sections. The <span 
class="cmmi-10">i</span>th TR section uses the <span 
class="cmmi-10">i</span>th gradient
pulse stored in the <span 
class="cmmi-10">i</span>th row of these two matrices. If the number of row is
less than the number of TR sections, the last gradient pulse will be used
for all the remaining TR sections. The &#8216;GzUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">GzFile : The path to the file that stores the gradient pulse data, quoted
     using single quotes
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2007--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.4   </span> <a 
 id="x3-660005.2.4"></a>GyPE Macro Library</h4>
<!--l. 2009--><p class="noindent" >A GyPE macro is a predefined module for a gradient pulse on the GyPE sequence
line. MRiLab GyPE macro library is a collection of GyPE macros covering different
gradient pulse types for performing phase encoding. Notice that by default the area
under the gradient ramp is ignored. This section will give an introduction to each of
the GyPE macros provided in MRiLab.

<!--l. 2011--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-670005.2.4"></a>GyTrapezoid</h5>
<!--l. 2013--><p class="noindent" >Similar to GzTrapezoid (Figure <a 
href="#x3-6100121">5.21<!--tex4ht:ref: fig:GzTrapezoid --></a>), GyTrapezoid creates a trapezoid gradient pulse
on GyPE sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">tEnd (s) : The trapezoid gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : The trapezoid pulse ramp time, assume symmetric ramp on
     both side
     </li>
     <li class="itemize">sRamp : The sample points on the ramp, use the value of 2 for ignoring
     the area under the ramp, use above 2 for counting the ramp area
     </li>
     <li class="itemize">GyAmp (T) : The amplitude of the gradient
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2028--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-680005.2.4"></a>GyAreaTrapezoid</h5>
<!--l. 2030--><p class="noindent" >Similar to GzAreaTrapezoid (Figure <a 
href="#x3-6200122">5.22<!--tex4ht:ref: fig:GzAreaTrapezoid --></a>), GyAreaTrapezoid creates a trapezoid
gradient pulse of specified area on GyPE sequence line. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">tEnd (s) : The trapezoid gradient pulse ending time

     </li>
     <li class="itemize">Area (1/m) : The area under this gradient pulse
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2043--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-690005.2.4"></a>GyAreaTrapezoid2</h5>
<!--l. 2045--><p class="noindent" >Similar to GzAreaTrapezoid2 (Figure <a 
href="#x3-6300123">5.23<!--tex4ht:ref: fig:GzAreaTrapezoid2 --></a>), GyAreaTrapezoid2 creates a trapezoid
gradient pulse of specified area with highest system performance on GyPE sequence
line. This macro creates a gradient pulse with nearly shortest pulse width
for the given system hardware constraint. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">Area (1/m) : The area under this gradient pulse
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>

<!--l. 2057--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-700005.2.4"></a>GyCartesian</h5>
<!--l. 2059--><p class="noindent" >Similar to GzCartesian (Figure <a 
href="#x3-6400124">5.24<!--tex4ht:ref: fig:GzCartesian --></a>), GyCartesian creates a Cartesian phase
encoding gradient pulse on GyPE sequence line. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">t1Start (s) : The phase encoding gradient pulse starting time
     </li>
     <li class="itemize">t1End (s) : The phase encoding gradient pulse ending time
     </li>
     <li class="itemize">t2Start (s) : The rephasing gradient pulse starting time
     </li>
     <li class="itemize">t2End (s) : The rephasing gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">Gy1Sign : The polarity of the phase encoding gradient, set 0 for nulling
     </li>
     <li class="itemize">Gy2Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2075--><p class="indent" >   Notice that the phase encoding gradient and the rephasing gradient have the
same area that is automatically calculated based on the imaging parameters in the
main control console.

<!--l. 2078--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-710005.2.4"></a>GyRadial</h5>
<!--l. 2080--><p class="noindent" >A GyPE macro that creates a phase encoding gradient pulse for radial K-Space
trajectory (Figure <a 
href="#x3-7100125">5.25<!--tex4ht:ref: fig:GyRadial --></a>) on GyPE sequence line. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">t1Start (s) : The prephasing gradient pulse starting time
     </li>
     <li class="itemize">t2Middle (s) : The phase encoding gradient pulse middle time
     </li>
     <li class="itemize">t3Start (s) : The rephasing gradient pulse starting time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">Gy1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gy2Sign : The polarity of the phase encoding gradient, set 0 for nulling
     </li>
     <li class="itemize">Gy3Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2094--><p class="indent" >   Notice that both the prephasing gradient and rephasing gradient have half of the
area of the phase encoding gradient that is automatically calculated based on the
imaging parameters in the main control console. MRiLab requires the &#8216;Radial&#8217; special
technique tab to be loaded for properly configuring the &#8216;GyRadial&#8217;, &#8216;GxRadial&#8217; and
&#8216;ADCRadial&#8217; macro. The user can set t2Middle value as &#8216;VCtl.TE&#8217; to acquire the
echo signal.
<!--l. 2096--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-7100125"></a>


<!--l. 2098--><p class="noindent" ><img 
src="Pictures/GyRadial.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.25: </span><span  
class="content">GyRadial Waveform</span></div><!--tex4ht:label?: x3-7100125 -->

<!--l. 2101--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-720005.2.4"></a>GySpiral</h5>
<!--l. 2105--><p class="noindent" >A GyPE macro that creates a phase encoding gradient pulse for spiral K-Space
trajectory (Figure <a 
href="#x3-7200126">5.26<!--tex4ht:ref: fig:GySpiral --></a>) on GyPE sequence line. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The phase encoding gradient pulse starting time
     </li>
     <li class="itemize">dt (s) : The time interval of gradient pulse sample points
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2114--><p class="indent" >   Notice that the area of the phase encoding gradient is automatically calculated
based on the imaging parameters in the main control console. MRiLab requires the
&#8216;Spiral&#8217; special technique tab to be loaded for properly configuring the &#8216;GySpiral&#8217;,
&#8216;GxSpiral&#8217; and &#8216;ADCSpiral&#8217; macro. The user can set tStart value as &#8216;VCtl.TE&#8217; to
acquire the echo signal.
<!--l. 2116--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-7200126"></a>


<!--l. 2118--><p class="noindent" ><img 
src="Pictures/GySpiral.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.26: </span><span  
class="content">GySpiral Waveform</span></div><!--tex4ht:label?: x3-7200126 -->

<!--l. 2121--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-730005.2.4"></a>GyFSE</h5>
<!--l. 2126--><p class="noindent" >A GyPE macro that creates a FSE phase encoding gradient pulse train (Figure <a 
href="#x3-7300127">5.27<!--tex4ht:ref: fig:GyFSE --></a>)
on GyPE sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tMiddle (s) : The middle time of the gradient pulse train
     </li>
     <li class="itemize">tOffset (s) : The time offset of the gradient pulse
     </li>
     <li class="itemize">tGy1 (s) : The duration of the phase encoding gradient
     </li>
     <li class="itemize">tGy2 (s) : The duration of the rephasing gradient
     </li>
     <li class="itemize">Gy1Sign : The polarity of the phase encoding gradient, set 0 for nulling
     </li>
     <li class="itemize">Gy2Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2139--><p class="indent" >   Notice that the phase encoding gradient and the rephasing gradient have the
same area that is automatically calculated based on the imaging parameters in the
main control console. MRiLab requires the &#8216;FSE&#8217; special technique tab to be loaded
for properly configuring the &#8216;GyFSE&#8217;, &#8216;GxFSE&#8217; and &#8216;ADCFSE&#8217; macro. To satisfy
Carr Purcell Meiboom Gill (CPMG) condition and acquire echo signal at the center
between two consecutive refocusing RF pulse, the effective TE value must equal
(floor(FSE_ETL/2)+1)*FSE_ESP. The user can set tMiddle value as &#8216;VCtl.TE&#8217;
to acquire the echo signal, where the &#8216;VCtl.TE&#8217; becomes the effective TE
value.
<!--l. 2141--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-7300127"></a>


<!--l. 2143--><p class="noindent" ><img 
src="Pictures/GyFSE.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.27: </span><span  
class="content">GyFSE Waveform</span></div><!--tex4ht:label?: x3-7300127 -->

<!--l. 2146--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-740005.2.4"></a>GyEPI</h5>
<!--l. 2150--><p class="noindent" >A GyPE macro that creates an EPI phase encoding gradient pulse train (Figure <a 
href="#x3-7400128">5.28<!--tex4ht:ref: fig:GyEPI --></a>)
on GyPE sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t2Middle (s) : The middle time of the blip gradient pulse train
     </li>
     <li class="itemize">t1Start (s) : The prephasing gradient starting time
     </li>
     <li class="itemize">Gy1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gy2Sign : The polarity of the blip gradient train, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2161--><p class="indent" >   Notice that the area of the prephasing gradient and the blip gradient are
automatically calculated based on the imaging parameters in the main control
console. MRiLab requires the &#8216;EPI&#8217; special technique tab to be loaded for properly
configuring the &#8216;GyEPI&#8217;, &#8216;GxEPI&#8217; and &#8216;ADCEPI&#8217; macro. The user can set t2Middle
value as &#8216;VCtl.TE&#8217; to acquire the echo signal, where the &#8216;VCtl.TE&#8217; becomes the
effective TE value.
<!--l. 2163--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-7400128"></a>


<!--l. 2165--><p class="noindent" ><img 
src="Pictures/GyEPI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.28: </span><span  
class="content">GyEPI Waveform</span></div><!--tex4ht:label?: x3-7400128 -->

<!--l. 2168--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-750005.2.4"></a>GyUser</h5>
<!--l. 2173--><p class="noindent" >If the user has the gradient pulse data saved in a MAT file, the user can easily import
the gradient file into MRiLab by using &#8216;GyUser&#8217; macro. The gradient pulse MAT file
needs to contain two matrices including &#8216;GTime&#8217; (i.e. gradient time points) and
&#8216;GAmp&#8217; (i.e. gradient amplitude). Both matrices must have the same size
of m-by-n, where m is the number of TR sections and n is the number of
gradient waveform points. In typical MR sequence, the entire sequence is
composed of multiple TR sections. The <span 
class="cmmi-10">i</span>th TR section uses the <span 
class="cmmi-10">i</span>th gradient
pulse stored in the <span 
class="cmmi-10">i</span>th row of these two matrices. If the number of row is
less than the number of TR sections, the last gradient pulse will be used
for all the remaining TR sections. The &#8216;GyUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">GyFile : The path to the file that stores the gradient pulse data, quoted
     using single quotes
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2184--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.5   </span> <a 
 id="x3-760005.2.5"></a>GxR Macro Library</h4>
<!--l. 2186--><p class="noindent" >A GxR macro is a predefined module for a gradient pulse on the GxR sequence line.
MRiLab GxR macro library is a collection of GxR macros covering different gradient
pulse types for performing frequency encoding. Notice that by default the area under
the gradient ramp is ignored. This section will give an introduction to each of the
GxR macros provided in MRiLab.

<!--l. 2188--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-770005.2.5"></a>GxTrapezoid</h5>
<!--l. 2190--><p class="noindent" >Similar to GzTrapezoid (Figure <a 
href="#x3-6100121">5.21<!--tex4ht:ref: fig:GzTrapezoid --></a>), GxTrapezoid creates a trapezoid gradient pulse
on GxR sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">tEnd (s) : The trapezoid gradient pulse ending time
     </li>
     <li class="itemize">tRamp (s) : The trapezoid pulse ramp time, assume symmetric ramp on
     both side
     </li>
     <li class="itemize">sRamp : The sample points on the ramp, use the value of 2 for ignoring
     the area under the ramp, use above 2 for counting the ramp area
     </li>
     <li class="itemize">GxAmp (T) : The amplitude of the gradient
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2205--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-780005.2.5"></a>GxAreaTrapezoid</h5>
<!--l. 2207--><p class="noindent" >Similar to GzAreaTrapezoid (Figure <a 
href="#x3-6200122">5.22<!--tex4ht:ref: fig:GzAreaTrapezoid --></a>), GxAreaTrapezoid creates a trapezoid
gradient pulse of specified area on GxR sequence line. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">tEnd (s) : The trapezoid gradient pulse ending time

     </li>
     <li class="itemize">Area (1/m) : The area under this gradient pulse
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2219--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-790005.2.5"></a>GxAreaTrapezoid2</h5>
<!--l. 2221--><p class="noindent" >Similar to GzAreaTrapezoid2 (Figure <a 
href="#x3-6300123">5.23<!--tex4ht:ref: fig:GzAreaTrapezoid2 --></a>), GxAreaTrapezoid2 creates a trapezoid
gradient pulse of specified area with highest system performance on GxR sequence
line. This macro creates a gradient pulse with nearly shortest pulse width
for the given system hardware constraint. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The trapezoid gradient pulse starting time
     </li>
     <li class="itemize">Area (1/m) : The area under this gradient pulse
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>

<!--l. 2232--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-800005.2.5"></a>GxCartesian</h5>
<!--l. 2234--><p class="noindent" >A GxR macro that creates a Cartesian frequency encoding gradient pulse (Figure
<a 
href="#x3-8000129">5.29<!--tex4ht:ref: fig:GxCartesian --></a>) on GxR sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t1Start (s) : The prephasing gradient pulse starting time
     </li>
     <li class="itemize">t2Middle (s) : The frequency encoding gradient pulse middle time
     </li>
     <li class="itemize">t3Start (s) : The rephasing gradient pulse starting time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">Gx1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gx2Sign : The polarity of the frequency encoding gradient, set 0 for nulling
     </li>
     <li class="itemize">Gx3Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2250--><p class="indent" >   Notice that both the prephasing gradient and rephasing gradient have half of the
area of the frequency encoding gradient.
<!--l. 2252--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-8000129"></a>


<!--l. 2254--><p class="noindent" ><img 
src="Pictures/GxCartesian.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.29: </span><span  
class="content">GxCartesian Waveform</span></div><!--tex4ht:label?: x3-8000129 -->

<!--l. 2257--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-810005.2.5"></a>GxRadial</h5>
<!--l. 2261--><p class="noindent" >Similar to GyRadial (Figure <a 
href="#x3-7100125">5.25<!--tex4ht:ref: fig:GyRadial --></a>), GxRadial creates a phase encoding gradient pulse
for radial K-Space trajectory on GxR sequence line. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">t1Start (s) : The prephasing gradient pulse starting time
     </li>
     <li class="itemize">t2Middle (s) : The phase encoding gradient pulse middle time
     </li>
     <li class="itemize">t3Start (s) : The rephasing gradient pulse starting time
     </li>
     <li class="itemize">tRamp (s) : Gradient pulse ramp time, assume symmetric ramp on both
     side
     </li>
     <li class="itemize">Gx1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gx2Sign : The polarity of the phase encoding gradient, set 0 for nulling
     </li>
     <li class="itemize">Gx3Sign : The polarity of the rephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2275--><p class="indent" >   Notice that both the prephasing gradient and rephasing gradient have half of the
area of the phase encoding gradient that is automatically calculated based on the
imaging parameters in the main control console. MRiLab requires the &#8216;Radial&#8217; special
technique tab to be loaded for properly configuring the &#8216;GyRadial&#8217;, &#8216;GxRadial&#8217; and
&#8216;ADCRadial&#8217; macro. The user can set t2Middle value as &#8216;VCtl.TE&#8217; to acquire the
echo signal.

<!--l. 2277--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-820005.2.5"></a>GxSpiral</h5>
<!--l. 2279--><p class="noindent" >Similar to GySpiral (Figure <a 
href="#x3-7200126">5.26<!--tex4ht:ref: fig:GySpiral --></a>), GxSpiral creates a phase encoding gradient pulse
for spiral K-Space trajectory on GxR sequence line. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The phase encoding gradient pulse starting time
     </li>
     <li class="itemize">dt (s) : The time interval of gradient pulse sample points
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2288--><p class="indent" >   Notice that the area of the phase encoding gradient is automatically calculated
based on the imaging parameters in the main control console. MRiLab requires the
&#8216;Spiral&#8217; special technique tab to be loaded for properly configuring the &#8216;GySpiral&#8217;,
&#8216;GxSpiral&#8217; and &#8216;ADCSpiral&#8217; macro. The user can set tStart value as &#8216;VCtl.TE&#8217; to
acquire the echo signal.
<!--l. 2290--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-830005.2.5"></a>GxFSE</h5>
<!--l. 2292--><p class="noindent" >A GxR macro that creates a FSE frequency encoding gradient pulse train (Figure
<a 
href="#x3-8300130">5.30<!--tex4ht:ref: fig:GxFSE --></a>) on GxR sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t2Middle (s) : The middle time of the gradient pulse train
     </li>
     <li class="itemize">t1Start (s) : The prephasing gradient starting time
     </li>
     <li class="itemize">Gx1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gx2Sign : The polarity of the frequency encoding gradient train, set 0 for
     nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>

<!--l. 2303--><p class="indent" >   Notice that the prephasing gradient has half of the area of the frequency encoding
gradient that is automatically calculated based on the imaging parameters in the
main control console. MRiLab requires the &#8216;FSE&#8217; special technique tab to
be loaded for properly configuring the &#8216;GyFSE&#8217;, &#8216;GxFSE&#8217; and &#8216;ADCFSE&#8217;
macro. To satisfy CPMG condition and acquire echo signal at the center
between two consecutive refocusing RF pulse, the effective TE value must equal
(floor(FSE_ETL/2)+1)*FSE_ESP. The user can set t2Middle value as &#8216;VCtl.TE&#8217;
to acquire the echo signal, where the &#8216;VCtl.TE&#8217; becomes the effective TE
value.
<!--l. 2305--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-8300130"></a>


<!--l. 2307--><p class="noindent" ><img 
src="Pictures/GxFSE.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.30: </span><span  
class="content">GxFSE Waveform</span></div><!--tex4ht:label?: x3-8300130 -->

<!--l. 2310--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-840005.2.5"></a>GxEPI</h5>
<!--l. 2314--><p class="noindent" >A GxR macro that creates an EPI frequency encoding gradient pulse train (Figure
<a 
href="#x3-8400131">5.31<!--tex4ht:ref: fig:GxEPI --></a>) on GxR sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">t2Middle (s) : The middle time of the frequency encoding gradient pulse
     train
     </li>
     <li class="itemize">t1Start (s) : The prephasing gradient starting time
     </li>
     <li class="itemize">Gx1Sign : The polarity of the prephasing gradient, set 0 for nulling
     </li>
     <li class="itemize">Gx2Sign : The polarity of the frequency encoding gradient train, set 0 for
     nulling
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2325--><p class="indent" >   Notice that the area of the prephasing gradient and the frequency encoding
gradient are automatically calculated based on the imaging parameters in the main
control console. MRiLab requires the &#8216;EPI&#8217; special technique tab to be loaded for
properly configuring the &#8216;GyEPI&#8217;, &#8216;GxEPI&#8217; and &#8216;ADCEPI&#8217; macro. The user can set
t2Middle value as &#8216;VCtl.TE&#8217; to acquire the echo signal, where the &#8216;VCtl.TE&#8217; becomes
the effective TE value.
<!--l. 2327--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-8400131"></a>


<!--l. 2329--><p class="noindent" ><img 
src="Pictures/GxEPI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.31: </span><span  
class="content">GxEPI Waveform</span></div><!--tex4ht:label?: x3-8400131 -->

<!--l. 2332--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-850005.2.5"></a>GxUser</h5>
<!--l. 2336--><p class="noindent" >If the user has the gradient pulse data saved in a MAT file, the user can easily import
the gradient file into MRiLab by using &#8216;GxUser&#8217; macro. The gradient pulse MAT file
needs to contain two matrices including &#8216;GTime&#8217; (i.e. gradient time points) and
&#8216;GAmp&#8217; (i.e. gradient amplitude). Both matrices must have the same size
of m-by-n, where m is the number of TR sections and n is the number of
gradient waveform points. In typical MR sequence, the entire sequence is
composed of multiple TR sections. The <span 
class="cmmi-10">i</span>th TR section uses the <span 
class="cmmi-10">i</span>th gradient
pulse stored in the <span 
class="cmmi-10">i</span>th row of these two matrices. If the number of row is
less than the number of TR sections, the last gradient pulse will be used
for all the remaining TR sections. The &#8216;GxUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">GxFile : The path to the file that stores the gradient pulse data, quoted
     using single quotes
     </li>
     <li class="itemize">Switch : The flag for turning on and off gradient pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the gradient pulse duplicates, used for creating
     multiple gradient pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between gradient pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the gradient pulse</li></ul>
<!--l. 2347--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.6   </span> <a 
 id="x3-860005.2.6"></a>ADC Macro Library</h4>
<!--l. 2349--><p class="noindent" >An ADC macro is a predefined module for an ADC flag pulse on the ADC sequence
line. Signal acquisition starts when ADC flag is 1 and stops when ADC
flag is 0. The ADC flag pulse is sampled at certain sampling rate that is
determined by the imaging parameters (default by using &#8216;BandWidth&#8217;) in the
main control console. MRiLab ADC macro library is a collection of ADC
macros covering different pulse types for performing signal acquisition. This
section will give an introduction to each of the ADC macros provided in
MRiLab.

<!--l. 2351--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-870005.2.6"></a>ADCBlock</h5>
<!--l. 2353--><p class="noindent" >An ADC macro that creates an ADC flag pulse with user defined sampling rate on
ADC sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The ADC starting time
     </li>
     <li class="itemize">tEnd (s) : The ADC ending time
     </li>
     <li class="itemize">sSample : The number of linear sample points when ADC flag is 1
     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the ADC pulse duplicates, used for creating
     multiple ADC pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between ADC pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>
<!--l. 2365--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-8700132"></a>


<!--l. 2367--><p class="noindent" ><img 
src="Pictures/ADCBlock.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.32: </span><span  
class="content">ADCBlock Waveform</span></div><!--tex4ht:label?: x3-8700132 -->

<!--l. 2370--><p class="indent" >   </div><hr class="endfigure">
   <h5 class="subsubsectionHead"><a 
 id="x3-880005.2.6"></a>ADCCartesian</h5>
<!--l. 2375--><p class="noindent" >An ADC macro that creates an ADC flag pulse for Cartesian readout on ADC
sequence line. This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tMiddle (s) : The ADC middle time, typically set &#8216;VCtl.TE&#8217; for acquiring
     echo signal
     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the ADC pulse duplicates, used for creating
     multiple ADC pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between ADC pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>
<!--l. 2385--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-890005.2.6"></a>ADCRadial</h5>
<!--l. 2387--><p class="noindent" >An ADC macro that creates an ADC flag pulse for radial readout on ADC sequence
line. This macro needs &#8216;Radial&#8217; tab to be loaded. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tMiddle (s) : The ADC middle time, typically set &#8216;VCtl.TE&#8217; for acquiring
     echo signal
     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>

<!--l. 2395--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-900005.2.6"></a>ADCSpiral</h5>
<!--l. 2397--><p class="noindent" >An ADC macro that creates an ADC flag pulse for spiral readout on ADC sequence
line. This macro needs &#8216;Spiral&#8217; tab to be loaded. This macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The ADC starting time, typically set &#8216;VCtl.TE&#8217; for acquiring
     echo signal
     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>
<!--l. 2406--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-910005.2.6"></a>ADCFSE</h5>
<!--l. 2408--><p class="noindent" >An ADC macro that creates an ADC flag pulse train for FSE readout on ADC
sequence line. This macro needs &#8216;FSE&#8217; tab to be loaded. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">tMiddle (s) : The ADC pulse train middle time, typically set &#8216;VCtl.TE&#8217;
     for acquiring echo signal
     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>
<!--l. 2416--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-920005.2.6"></a>ADCEPI</h5>
<!--l. 2418--><p class="noindent" >An ADC macro that creates an ADC flag pulse train for EPI readout on ADC
sequence line. This macro needs &#8216;EPI&#8217; tab to be loaded. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">tMiddle (s) : The ADC pulse train middle time, typically set &#8216;VCtl.TE&#8217;
     for acquiring echo signal

     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>
<!--l. 2426--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-930005.2.6"></a>ADCUser</h5>
<!--l. 2428--><p class="noindent" >If the user has the ADC pulse data saved in a MAT file, the user can easily import
the ADC file into MRiLab by using &#8216;ADCUser&#8217; macro. The ADC pulse MAT file
needs to contain two matrices including &#8216;GTime&#8217; (i.e. ADC time points) and &#8216;GAmp&#8217;
(i.e. ADC amplitude, use 1 for signal acquisition, 0 for no signal acquisition). Both
matrices must have the same size of m-by-n, where m is the number of TR sections
and n is the number of ADC sample points. In typical MR sequence, the entire
sequence is composed of multiple TR sections. The <span 
class="cmmi-10">i</span>th TR section uses the <span 
class="cmmi-10">i</span>th ADC
pulse stored in the <span 
class="cmmi-10">i</span>th row of these two matrices. If the number of row is
less than the number of TR sections, the last ADC pulse will be used for
all the remaining TR sections. The &#8216;ADCUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">ADCFile : The path to the file that stores the ADC pulse data, quoted
     using single quotes
     </li>
     <li class="itemize">Switch : The flag for turning on and off ADC pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the ADC pulse duplicates, used for creating
     multiple ADC pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between ADC pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the ADC pulse</li></ul>
<!--l. 2438--><p class="indent" >   Notice that &#8216;ADCUser&#8217; macro sets the first and last ADC sample points to 0
regardless of their original value, therefore the signal is not acquired at the first and
last time points.

<!--l. 2440--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.7   </span> <a 
 id="x3-940005.2.7"></a>Ext Macro Library</h4>
<!--l. 2442--><p class="noindent" >An Ext macro is a predefined module for an Ext flag pulse on the Ext sequence line.
MRiLab specifies Ext signal for performing extended real time processes including
calculating remaining scan time, manipulating K-Space location and triggering object
motion etc. Ext macro library only contains &#8216;ExtBit&#8217; macro, however the &#8216;Ext&#8217;
attribute in this macro triggers different processes.
<!--l. 2444--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-950005.2.7"></a>ExtBit</h5>
<!--l. 2446--><p class="noindent" >The &#8216;ExtBit&#8217; macro (Figure <a 
href="#x3-9500133">5.33<!--tex4ht:ref: fig:ExtBit --></a>) creates a triangle blip pulse on Ext sequence line.
This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The Ext starting time
     </li>
     <li class="itemize">Ext : The Ext flag
     </li>
     <li class="itemize">Switch : The flag for turning on and off Ext pulse in the sequence line
     </li>
     <li class="itemize">Duplicates : The number of the Ext pulse duplicates, used for creating
     multiple Ext pulses with the same shape
     </li>
     <li class="itemize">DupSpacing : The time spacing between Ext pulse duplicates
     </li>
     <li class="itemize">Notes : The notes of the Ext pulse</li></ul>
<!--l. 2457--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-9500133"></a>


<!--l. 2459--><p class="noindent" ><img 
src="Pictures/ExtBit.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.33: </span><span  
class="content">ExtBit Waveform</span></div><!--tex4ht:label?: x3-9500133 -->

<!--l. 2462--><p class="indent" >   </div><hr class="endfigure">
<!--l. 2465--><p class="indent" >   Different Ext flags execute different extended real time processes during runtime
scan. These extended processes are implemented using Plugin code in the /Plugin
folder. MRiLab reserved several Ext flags for particular purposes.
     <ul class="itemize1">
     <li class="itemize">1 : Plugin_ResetK, reset Kx, Ky and Kz to zero
     </li>
     <li class="itemize">2 : Plugin_ReverseK, reverse Kx, Ky and Kz
     </li>
     <li class="itemize">3 : Plugin_LockK, buffer current K space location
     </li>
     <li class="itemize">4 : Plugin_ReleaseK, set K space location to the latest buffered one, used
     after Plugin_LockK
     </li>
     <li class="itemize">5 : Plugin_Timer, calculate remaining scan time, display it on the main
     control console
     </li>
     <li class="itemize">6 : Plugin_IdealSpoiler, dephase transverse magnetization of all the spins,
     set them to zero
     </li>
     <li class="itemize">7 : Plugin_rfRef, buffer current rfPhase value and demodulate signal phase
     according to this value
     </li>
     <li class="itemize">8 : Plugin_ExecuteMotion, trigger object motion
     </li>
     <li class="itemize">9 : Plugin_RTRecon, trigger real time image reconstruction with currently
     stored K-Space data</li></ul>
   <h4 class="subsectionHead"><span class="titlemark">5.2.8   </span> <a 
 id="x3-960005.2.8"></a>Make New Ext Plugin</h4>
<!--l. 2481--><p class="noindent" >The user can define Ext flags and use Ext Plugin to create extended real time
process. To make your own Ext flag and Plugin code, you should follow the following
steps :
<!--l. 2483--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-96002x1">Write Ext Plugin code <br 
class="newline" />
     <!--l. 2487--><p class="noindent" >It is strongly recommended to write your Plugin code based on a template
     like :

     <div class="verbatim" id="verbatim-8">
     &#x00A0;<br />function&#x00A0;Plugin_YourPluginName
     &#x00A0;<br />%Create&#x00A0;a&#x00A0;Ext&#x00A0;Plugin&#x00A0;based&#x00A0;on&#x00A0;your&#x00A0;code
     &#x00A0;<br />global&#x00A0;VCtl&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VCtl&#x00A0;structure,&#x00A0;read&#x00A0;only
     &#x00A0;<br />global&#x00A0;VVar&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VVar&#x00A0;structure,&#x00A0;read&#x00A0;only
     &#x00A0;<br />global&#x00A0;VObj&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VObj&#x00A0;structure,&#x00A0;read&#x00A0;and&#x00A0;write
     &#x00A0;<br />global&#x00A0;VMag&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VMag&#x00A0;structure,&#x00A0;read&#x00A0;and&#x00A0;write
     &#x00A0;<br />global&#x00A0;VCoi&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VCoi&#x00A0;structure,&#x00A0;read&#x00A0;and&#x00A0;write
     &#x00A0;<br />
     &#x00A0;<br />...
     &#x00A0;<br />%&#x00A0;The&#x00A0;main&#x00A0;code&#x00A0;for&#x00A0;your&#x00A0;Ext&#x00A0;Plugin
     &#x00A0;<br />...
     &#x00A0;<br />
     &#x00A0;<br />end
     &#x00A0;<br />
     &#x00A0;<br />
</div>
     <!--l. 2506--><p class="nopar" >
     <!--l. 2508--><p class="noindent" >As mentioned before, VCtl encapsules all the simulation setting parameters in
     the main control console. VVar not only encapsules the loop index variables
     that MRiLab uses for generating MR sequence waveform, but also
     contains variables for temporarily buffering instant sequence line values
     during runtime. <span 
class="cmbx-10">Do keep in mind, VCtl and VVar are read only,</span>
     <span 
class="cmbx-10">changing values inside these two structures may cause MRiLab</span>
     <span 
class="cmbx-10">crash.</span>
         <ul class="itemize1">
         <li class="itemize">VVar.rfAmp (T) : A array with the size of <span 
class="cmmi-10">TxCoilNum</span><span 
class="cmsy-10">&#x00D7;</span>1 for storing
         current RF amplitude
         </li>
         <li class="itemize">VVar.rfPhase (rad) : A array with the size of <span 
class="cmmi-10">TxCoilNum </span><span 
class="cmsy-10">&#x00D7; </span>1 for
         storing current RF phase
         </li>
         <li class="itemize">VVar.rfFreq (Hz) : A array with the size of <span 
class="cmmi-10">TxCoilNum </span><span 
class="cmsy-10">&#x00D7; </span>1 for
         storing current RF frequency
         </li>
         <li class="itemize">VVar.rfCoil : The CoilID of current working coil channel, used in
         multiple RF transmitting

         </li>
         <li class="itemize">VVar.rfRef (rad) : The buffered RF phase, used for demodulating
         signal phase at ADC
         </li>
         <li class="itemize">VVar.GzAmp (T/m) : The current GzSS gradient amplitude
         </li>
         <li class="itemize">VVar.GyAmp (T/m) : The current GyPE gradient amplitude
         </li>
         <li class="itemize">VVar.GxAmp (T/m) : The current GXR gradient amplitude
         </li>
         <li class="itemize">VVar.ADC : The current ADC flag
         </li>
         <li class="itemize">VVar.Ext : The current Ext flag
         </li>
         <li class="itemize">VVar.t (s) : The current time
         </li>
         <li class="itemize">VVar.Kz (1/m) : The current Kz value
         </li>
         <li class="itemize">VVar.Ky (1/m) : The current Ky value
         </li>
         <li class="itemize">VVar.Kx (1/m) : The current Kx value
         </li>
         <li class="itemize">VVar.TRCount : The current TR section index</li></ul>
     <!--l. 2529--><p class="noindent" >Notice that there are three new Virtual Structures (VObj, VMag and VCoi) in
     this template, they store the variables about the virtual object, B0 field and
     coil B1 field which are accessible and editable in Plugin code. <span 
class="cmbx-10">Do keep in</span>
     <span 
class="cmbx-10">mind, do not change the size of the matrices inside these three</span>
     <span 
class="cmbx-10">structures.</span>
         <ul class="itemize1">
         <li class="itemize">VObj.Rho : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">TypeNum </span>for describing spin density
         </li>
         <li class="itemize">VObj.T1 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">TypeNum </span>for describing T1 relaxation time
         </li>
         <li class="itemize">VObj.T2 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">TypeNum </span>for describing T2 relaxation time
         </li>
         <li class="itemize">VObj.Mx : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">SpinPerV oxel </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum  </span>for  describing  magnetization  in  <span 
class="cmmi-10">x</span>
         direction

         </li>
         <li class="itemize">VObj.My : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">SpinPerV oxel </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum  </span>for  describing  magnetization  in  <span 
class="cmmi-10">y</span>
         direction
         </li>
         <li class="itemize">VObj.Mz : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">SpinPerV oxel </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum  </span>for  describing  magnetization  in  <span 
class="cmmi-10">z</span>
         direction
         </li>
         <li class="itemize">VMag.dWRnd (rad/s) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">SpinPerV oxel </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum  </span>for  describing  microscopic
         resonance frequency variation caused by T2* effect
         </li>
         <li class="itemize">VMag.dB0 (T) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim</span>
         for describing local B0 field variation
         </li>
         <li class="itemize">VMag.Gxgrid (m) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span>
         for describing spatial grid in X direction
         </li>
         <li class="itemize">VMag.Gygrid (m) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span>
         for describing spatial grid in Y direction
         </li>
         <li class="itemize">VMag.Gzgrid (m) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span>
         for describing spatial grid in Z direction
         </li>
         <li class="itemize">VCoi.TxCoilmg (T) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TxCoilNum </span>for describing the magnitude of transmitting
         B1+ field
         </li>
         <li class="itemize">VCoi.TxCoilpe (rad) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TxCoilNum </span>for describing the phase of transmitting B1+
         field
         </li>
         <li class="itemize">VCoi.RxCoilx (T) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RxCoilNum </span>for describing the <span 
class="cmmi-10">x </span>component of receiving
         B1- field
         </li>
         <li class="itemize">VCoi.RxCoily (T) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RxCoilNum </span>for describing the <span 
class="cmmi-10">y </span>component of receiving
         B1- field</li></ul>
     <!--l. 2549--><p class="noindent" >where &#8216;TxCoilNum&#8217; is the number of transmitting coil channels, &#8216;RxCoilNum&#8217; is
     the number of receiving coil channels.

     </li>
     <li 
  class="enumerate" id="x3-96004x2">Register Ext Plugin <br 
class="newline" />
     <!--l. 2553--><p class="noindent" >The user needs to register customized Plugins before MRiLab can use it. To
     register Plugins and assign Ext flags to them, simply open &#8216;DoExtPlugin.m&#8217;
     under /Src folder.

     <div class="verbatim" id="verbatim-9">
     function&#x00A0;DoExtPlugin
     &#x00A0;<br />%&#x00A0;entry&#x00A0;function&#x00A0;for&#x00A0;extended&#x00A0;plugin&#x00A0;based&#x00A0;on&#x00A0;Ext&#x00A0;flag
     &#x00A0;<br />global&#x00A0;VVar
     &#x00A0;<br />
     &#x00A0;<br />switch&#x00A0;VVar.Ext
     &#x00A0;<br />%%&#x00A0;System&#x00A0;Reserved&#x00A0;Ext&#x00A0;Flags&#x00A0;(Positive)
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;0&#x00A0;%&#x00A0;normal&#x00A0;status
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;do&#x00A0;nothing
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;1&#x00A0;%&#x00A0;reset&#x00A0;K&#x00A0;space&#x00A0;location
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_ResetK;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;2&#x00A0;%&#x00A0;reverse&#x00A0;K&#x00A0;space&#x00A0;location
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_ReverseK;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;3&#x00A0;%&#x00A0;lock&#x00A0;K&#x00A0;space&#x00A0;location
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_LockK;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;4&#x00A0;%&#x00A0;release&#x00A0;K&#x00A0;space&#x00A0;location
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_ReleaseK;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;5&#x00A0;%&#x00A0;calculate&#x00A0;remaining&#x00A0;scan&#x00A0;time
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_Timer;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;6&#x00A0;%&#x00A0;ideal&#x00A0;spoiler,&#x00A0;dephase&#x00A0;Mxy
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_IdealSpoiler;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;7&#x00A0;%&#x00A0;rfRef,&#x00A0;demodulate&#x00A0;signal&#x00A0;phase&#x00A0;referring&#x00A0;to&#x00A0;RF&#x00A0;phase&#x00A0;at&#x00A0;ADC
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_rfRef;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;8&#x00A0;%&#x00A0;trigger&#x00A0;object&#x00A0;motion
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_ExecuteMotion;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;9&#x00A0;%&#x00A0;real&#x00A0;time&#x00A0;image&#x00A0;recon
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_RTRecon;
     &#x00A0;<br />
     &#x00A0;<br />%%&#x00A0;User&#x00A0;Defined&#x00A0;Ext&#x00A0;Flags&#x00A0;(Negative)
     &#x00A0;<br />%&#x00A0;add&#x00A0;user&#x00A0;defined&#x00A0;Ext&#x00A0;flags&#x00A0;here&#x00A0;using&#x00A0;case&#x00A0;syntax
     &#x00A0;<br />%&#x00A0;e.g.&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;-5
     &#x00A0;<br />%&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Plugin_XXX;
     &#x00A0;<br />
     &#x00A0;<br />end
     &#x00A0;<br />end
</div>
     <!--l. 2590--><p class="nopar" >
     <!--l. 2592--><p class="noindent" >Add one more Switch case line, assign a distinct Ext flag, then add user defined
     Plugin function name under the case line. It is recommended to use negative
     Ext flag for user defined Plugin to make differences from system reserved
     plugins.
     </li>

     <li 
  class="enumerate" id="x3-96006x3">Register to refresh GPU device memory <br 
class="newline" />
     <!--l. 2596--><p class="noindent" >If the customized Plugin function modifies any variables in VObj, VMag or
     VCoi, the Plugin function needs to be registered for refreshing GPU device
     memory in case GPU parallel computing method is chosen. Simply open
     &#8216;DoGPUFetch.m&#8217; under /Src folder.

     <div class="verbatim" id="verbatim-10">
     function&#x00A0;DoGPUFetch
     &#x00A0;<br />%&#x00A0;fetch&#x00A0;data&#x00A0;from&#x00A0;GPU?
     &#x00A0;<br />%&#x00A0;VVar.gpuFetch&#x00A0;=&#x00A0;1&#x00A0;&#x00A0;fetch&#x00A0;data&#x00A0;from&#x00A0;GPU&#x00A0;memory&#x00A0;to&#x00A0;CPU&#x00A0;memory
     &#x00A0;<br />%&#x00A0;VVar.gpuFetch&#x00A0;=&#x00A0;0&#x00A0;&#x00A0;no&#x00A0;GPU&#x00A0;data&#x00A0;fetching
     &#x00A0;<br />global&#x00A0;VVar
     &#x00A0;<br />
     &#x00A0;<br />switch&#x00A0;VVar.Ext
     &#x00A0;<br />%%&#x00A0;System&#x00A0;Reserved&#x00A0;Ext&#x00A0;Flags&#x00A0;(Positive)
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;6&#x00A0;%&#x00A0;ideal&#x00A0;spoiler,&#x00A0;dephase&#x00A0;Mxy
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;VVar.gpuFetch&#x00A0;=&#x00A0;1;
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;8&#x00A0;%&#x00A0;trigger&#x00A0;object&#x00A0;motion
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;VVar.gpuFetch&#x00A0;=&#x00A0;1;
     &#x00A0;<br />
     &#x00A0;<br />
     &#x00A0;<br />%%&#x00A0;User&#x00A0;Defined&#x00A0;Ext&#x00A0;Flags&#x00A0;(Negative)
     &#x00A0;<br />%&#x00A0;add&#x00A0;user&#x00A0;defined&#x00A0;Ext&#x00A0;flags&#x00A0;here&#x00A0;using&#x00A0;case&#x00A0;syntax
     &#x00A0;<br />%&#x00A0;e.g.&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;-5
     &#x00A0;<br />%&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;VVar.gpuFetch&#x00A0;=&#x00A0;1;
     &#x00A0;<br />
     &#x00A0;<br />end
     &#x00A0;<br />end
</div>
     <!--l. 2620--><p class="nopar" >
     <!--l. 2622--><p class="noindent" >Add one more Switch case line, assign VVar.gpuFetch equal to 1.
     </li></ol>
<!--l. 2626--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.9   </span> <a 
 id="x3-970005.2.9"></a>Make New Gradient Macro</h4>
<!--l. 2628--><p class="noindent" >The user can make customized gradient macros and use them to create desired
K-Space trajectory. To make your own gradient macro, you should follow the
following steps :
<!--l. 2631--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-97002x1">Write gradient macro code <br 
class="newline" />
     <!--l. 2635--><p class="noindent" >It is strongly recommended to write your own gradient macro code based
     on the closest gradient macros in the MRiLab macro library. One template
     is like :

     <div class="verbatim" id="verbatim-11">
     function&#x00A0;[GAmp,GTime]=GYourGradientMacroName(p)
     &#x00A0;<br />%Create&#x00A0;a&#x00A0;gradient&#x00A0;macro&#x00A0;based&#x00A0;on&#x00A0;your&#x00A0;code
     &#x00A0;<br />
     &#x00A0;<br />global&#x00A0;VCtl&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VCtl&#x00A0;structure,&#x00A0;read&#x00A0;only
     &#x00A0;<br />global&#x00A0;VObj&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VObj&#x00A0;structure,&#x00A0;read&#x00A0;only
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;Create&#x00A0;attribute&#x00A0;list
     &#x00A0;<br />Duplicates=max(1,p.Duplicates);
     &#x00A0;<br />DupSpacing=max(0,p.DupSpacing);
     &#x00A0;<br />...
     &#x00A0;<br />attribute1=p.attribute1;
     &#x00A0;<br />attribute2=p.attribute2;
     &#x00A0;<br />attribute3=p.attribute3;
     &#x00A0;<br />...
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;The&#x00A0;main&#x00A0;code&#x00A0;for&#x00A0;your&#x00A0;macro
     &#x00A0;<br />...
     &#x00A0;<br />GTime&#x00A0;=&#x00A0;...;
     &#x00A0;<br />GAmp&#x00A0;=&#x00A0;...;
     &#x00A0;<br />...
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;Avoid&#x00A0;baseline&#x00A0;offset
     &#x00A0;<br />GAmp(1)=0;
     &#x00A0;<br />GAmp(end)=0;
     &#x00A0;<br />
     &#x00A0;<br />%&#x00A0;Create&#x00A0;Duplicates
     &#x00A0;<br />if&#x00A0;Duplicates~=1&#x00A0;&amp;&#x00A0;DupSpacing&#x00A0;~=0
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GAmp=repmat(GAmp,[1&#x00A0;Duplicates]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;TimeOffset&#x00A0;=&#x00A0;repmat(0:DupSpacing:(Duplicates-1)*DupSpacing,&#x00A0;...
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[length(GTime)&#x00A0;1]);
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GTime=repmat(GTime,[1&#x00A0;Duplicates])&#x00A0;+&#x00A0;(TimeOffset(:))&#8217;;
     &#x00A0;<br />end
     &#x00A0;<br />end
</div>
     <!--l. 2671--><p class="nopar" >
     </li>
     <li 
  class="enumerate" id="x3-97004x2">Register gradient macro <br 
class="newline" />
     <!--l. 2675--><p class="noindent" >The gradient macro file can be located anywhere in the computer as long as the
     file is included in Matlab searching path, however it is recommended to save the
     the file under corresponding gradient folder under /SeqElem folder for

     consistent file organization. The customized gradient macro needs to be
     registered in the macro library before using. To register the macro,
     open file &#8216;SeqElem.xml&#8217; under /SeqElem, then add one entry under
     gradient category with the proper attribute list. One example could
     be

     <div class="verbatim" id="verbatim-12">
     &#x003C;GzGradientMacroName
     &#x00A0;<br />Switch="$1&#8217;on&#8217;,&#8217;off&#8217;"
     &#x00A0;<br />DupSpacing="0"
     &#x00A0;<br />Duplicates="1"
     &#x00A0;<br />Notes="A&#x00A0;new&#x00A0;Gz&#x00A0;gradient&#x00A0;macro"
     &#x00A0;<br />attribute1="$1&#8217;on&#8217;,&#8217;off&#8217;"
     &#x00A0;<br />attribute2="0"
     &#x00A0;<br />attribute3="0"&#x00A0;/&#x003E;
     &#x00A0;<br />
</div>
     <!--l. 2687--><p class="nopar" >
     <!--l. 2689--><p class="noindent" >Notice that in the above example, the first 3 attributes are required
     for MRiLab, The remaining attributes are optional based on user&#8217;s
     choice.
     </li></ol>
<!--l. 2693--><p class="indent" >   Once the gradient macro is coded and registered to the library, the user can use
this customized gradient macro just like those default gradient macros in the
library.
<!--l. 2695--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.10   </span> <a 
 id="x3-980005.2.10"></a>Make New MR Sequence</h4>
<!--l. 2697--><p class="noindent" >To design a sequence in the MR Sequence Design interface, it is recommended to load
the sequence into the main control console first and then click toolbar icon to activate
the MR Sequence Design interface. This is mainly because the associated imaging
parameters that are necessary for configuring current sequence will also be loaded
during the sequence loading process. However, if the interface has already
been activated, the user can also use the sequence loading function to load
another sequence with current imaging parameters. To load a sequence,
click &#8216;Load&#8217; menu then click &#8216;Load Sequence File&#8217;, choose a sequence XML
file.<br 
class="newline" />
<!--l. 2699--><p class="indent" >   The user can create a new MR sequence in the MR Sequence Design interface. To
create a new sequence, click &#8216;New&#8217; then click &#8216;Create Sequence File&#8217;. A sequence
creation window (Figure <a 
href="#x3-9800134">5.34<!--tex4ht:ref: fig:NewPSD --></a>) will show up and ask for new sequence name and
notes. To follow MRiLab naming convention, the user is recommended to use &#8216;PSD_&#8217;
followed by a legal name string that is distinct to the existing sequences in MRiLab.
Then click &#8216;OK&#8217; to select a path for storing the sequence XML file. It&#8217;s strongly
recommended to put the sequence under the MRiLab sequence root folder /PSD
according to the sequence type so that the sequence is visible to MRiLab.

Finally, MRiLab will create a new sequence XML file based on the content of
&#8216;PSD_GRE3D&#8217;.
<!--l. 2701--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-9800134"></a>


<!--l. 2703--><p class="noindent" ><img 
src="Pictures/NewPSD.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.34: </span><span  
class="content">The Sequence Creation Window</span></div><!--tex4ht:label?: x3-9800134 -->

<!--l. 2706--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.2.11   </span> <a 
 id="x3-990005.2.11"></a>Make New Virtual Object</h4>
<!--l. 2711--><p class="noindent" >To design and optimize MR sequence, the user may need virtual objects with specific
geometry and properties according to their experiment purpose. Although
MRiLab provides a few phantoms with tissue properties mimicking several
human tissue types, the user may still need to define customized virtual
object. To make your own virtual object, you should follow the following steps
:
<!--l. 2713--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-99002x1">Make Regular Virtual Object <br 
class="newline" />
     <!--l. 2717--><p class="noindent" >Create  a  Matlab  structure  &#8216;VObj&#8217;.  &#8216;VObj&#8217;  must  contains  variables
     including:
         <ul class="itemize1">
         <li class="itemize">Gyro (rad/s/T) : The gyromagnetic ratio of the spin
         </li>
         <li class="itemize">ChemShift  (Hz/T)  :  A  array  with  the  size  of  1 <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TypeNum </span>for
         describing the chemical shift of the spins
         </li>
         <li class="itemize">XDim : The number of voxels in X direction
         </li>
         <li class="itemize">YDim : The number of voxels in Y direction
         </li>
         <li class="itemize">ZDim : The number of voxels in Z direction
         </li>
         <li class="itemize">XDimRes (m) : The voxel size in X direction
         </li>
         <li class="itemize">YDimRes (m) : The voxel size in Y direction
         </li>
         <li class="itemize">ZDimRes (m) : The voxel size in Z direction
         </li>
         <li class="itemize">Type : A string for describing the type of the spin
         </li>
         <li class="itemize">TypeNum : The number of spin species
         </li>
         <li class="itemize">Rho : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
         for describing spin density

         </li>
         <li class="itemize">T1 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
         for describing T1 relaxation time
         </li>
         <li class="itemize">T2 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
         for describing T2 relaxation time
         </li>
         <li class="itemize">T2Star (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">TypeNum </span>for describing T2* relaxation time</li></ul>
     <!--l. 2736--><p class="noindent" >Then save the &#8216;VObj&#8217; structure as a MAT file.
     </li>
     <li 
  class="enumerate" id="x3-99004x2">Make Virtual Object with Magnetization Transfer (MT) Properties<br 
class="newline" />
     <!--l. 2740--><p class="noindent" >The current MRiLab version only supports two-pool MT model <span class="cite">[<a 
href="#XYarnykh2002">9</a>]</span> with GPU
     acceleration. The &#8216;VObj&#8217; must have the structure like:
         <ul class="itemize1">
         <li class="itemize">Gyro (rad/s/T) : The gyromagnetic ratio of the spin
         </li>
         <li class="itemize">ChemShift (Hz/T) : A array with the size of 1 <span 
class="cmsy-10">&#x00D7; </span>2 for describing the
         chemical shift of the spins, free pool first, bound pool second
         </li>
         <li class="itemize">XDim : The number of voxels in X direction
         </li>
         <li class="itemize">YDim : The number of voxels in Y direction
         </li>
         <li class="itemize">ZDim : The number of voxels in Z direction
         </li>
         <li class="itemize">XDimRes (m) : The voxel size in X direction
         </li>
         <li class="itemize">YDimRes (m) : The voxel size in Y direction
         </li>
         <li class="itemize">ZDimRes (m) : The voxel size in Z direction
         </li>
         <li class="itemize">Type : A string for describing the type of the spin
         </li>
         <li class="itemize">TypeNum : 2
         </li>
         <li class="itemize">Rho : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span>2 for
         describing spin density, <span 
class="cmmi-10">Rho</span><sub><span 
class="cmmi-7">f</span></sub> (free pool) first, <span 
class="cmmi-10">Rho</span><sub><span 
class="cmmi-7">b</span></sub> (bound pool)
         second

         </li>
         <li class="itemize">T1 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span>2 for
         describing T1 relaxation time, free pool first, bound pool second
         </li>
         <li class="itemize">T2 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span>2 for
         describing T2 relaxation time, free pool first, bound pool second
         </li>
         <li class="itemize">T2Star (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span>2
         for describing T2* relaxation time, free pool first, bound pool second
         </li>
         <li class="itemize">K (1/s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7; </span>4
         for describing MT cross-relaxation rate, the <span 
class="cmmi-10">K</span><sub><span 
class="cmmi-7">fb</span></sub> (free pool to bound
         pool) and the <span 
class="cmmi-10">K</span><sub><span 
class="cmmi-7">bf</span></sub> (bound pool to free pool) is the second and third
         volume at the last dimension, respectively. The cross-relaxation rate
         to itself for any pool (i.e. <span 
class="cmmi-10">K</span><sub><span 
class="cmmi-7">ff</span></sub> and <span 
class="cmmi-10">K</span><sub><span 
class="cmmi-7">bb</span></sub>) is assumed to be zero.</li></ul>
     <!--l. 2760--><p class="noindent" >Notice that the two-pool MT model needs to satisfy chemical equilibrium
     described as <span 
class="cmmi-10">Rho</span><sub><span 
class="cmmi-7">f</span></sub> <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">K</span><sub><span 
class="cmmi-7">fb</span></sub> = <span 
class="cmmi-10">Rho</span><sub><span 
class="cmmi-7">b</span></sub> <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">K</span><sub><span 
class="cmmi-7">bf</span></sub>. After making VObj, then save the
     &#8216;VObj&#8217; structure as a MAT file. In MRiLab, the Bloch-equation solving kernel
     is only executed when the value of any sequence line needs to be updated. The
     time point at which this updating is happening is referred to as execution
     point. To accurately model MT exchange during scan, the user needs to create
     execution points on the entire RF sequence line. A typical method is to insert a
     long RF pulse with zero amplitude at the empty portion of the RF sequence
     line. The interested users are referred to PSD_SPGR3DMT for more
     information.
     </li>
     <li 
  class="enumerate" id="x3-99006x3">Make Virtual Object with Multiple pool spin Exchange (ME) Properties<br 
class="newline" />
     <!--l. 2764--><p class="noindent" >The current MRiLab version supports multiple spin exchange model up to any
     number of spin pools with GPU acceleration. The &#8216;VObj&#8217; must have the
     structure like:
         <ul class="itemize1">
         <li class="itemize">Gyro (rad/s/T) : The gyromagnetic ratio of the spin
         </li>
         <li class="itemize">ChemShift (Hz/T) : A array with the size of 1 <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">PoolNumber </span>for
         describing the chemical shift of the spins
         </li>
         <li class="itemize">XDim : The number of voxels in X direction
         </li>
         <li class="itemize">YDim : The number of voxels in Y direction

         </li>
         <li class="itemize">ZDim : The number of voxels in Z direction
         </li>
         <li class="itemize">XDimRes (m) : The voxel size in X direction
         </li>
         <li class="itemize">YDimRes (m) : The voxel size in Y direction
         </li>
         <li class="itemize">ZDimRes (m) : The voxel size in Z direction
         </li>
         <li class="itemize">Type : A string for describing the type of the spin
         </li>
         <li class="itemize">TypeNum : Pool Number
         </li>
         <li class="itemize">Rho : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
         for describing spin density
         </li>
         <li class="itemize">T1 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
         for describing T1 relaxation time
         </li>
         <li class="itemize">T2 (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">XDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">ZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TypeNum</span>
         for describing T2 relaxation time
         </li>
         <li class="itemize">T2Star (s) : A matrix with the size of <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">TypeNum </span>for describing T2* relaxation time
         </li>
         <li class="itemize">K  (1/s)  :  A  matrix  with  the  size  of  <span 
class="cmmi-10">Y Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">XDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">ZDim </span><span 
class="cmsy-10">&#x00D7;</span>
         <span 
class="cmmi-10">TypeNum</span><sup><span 
class="cmr-7">2</span></sup> for describing ME exchange rate. To explain the order of
         the exchange rate at the last dimension, for example, given there are
         three pools, the exchange rate is ordered in the fashion as the first
         pool to itself <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">11</span></sub>, the second pool <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">12</span></sub>, the third pool <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">13</span></sub>, followed
         by the second pool to the first pool <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">21</span></sub>, itself <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">22</span></sub>, the third pool
         <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">23</span></sub>, followed by the third pool to the first pool <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">31</span></sub>, the second
         pool <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">32</span></sub> and itself <span 
class="cmmi-10">K</span><sub><span 
class="cmr-7">33</span></sub>. The exchange rate to itself for any pool is
         assumed to be zero.</li></ul>
     <!--l. 2784--><p class="noindent" >Notice that the multiple-pool ME model also needs to satisfy chemical
     equilibrium analogous to that of MT model. After making VObj, then
     save the &#8216;VObj&#8217; structure as a MAT file. To accurately model ME
     exchange during scan, the user also needs to create execution points on
     the entire RF sequence line. A typical method is to insert a long RF
     pulse with zero amplitude at the empty portion of the RF sequence
     line. The interested users are referred to PSD_SPGR3DME for more
     information.
     </li></ol>

<!--l. 2788--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.3   </span> <a 
 id="x3-1000005.3"></a>Coil B1 Design</h3>
<!--l. 2790--><p class="noindent" >The Coil B1 Design toolbox can be activated by pressing &#8216;Coil Design Panel&#8217; toolbar
icon located at the top of the main simulation console. Depending on the coil mode
(i.e. &#8216;Tx&#8217; or &#8216;Rx&#8217;) highlighted on the &#8216;Coil Selection&#8217; panel, the loaded coil will show
in the Coil B1 Design interface.
<!--l. 2792--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-10000135"></a>


<!--l. 2794--><p class="noindent" ><img 
src="Pictures/CoilDesignPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.35: </span><span  
class="content">Coil Design Panel Toolbar Icon</span></div><!--tex4ht:label?: x3-10000135 -->

<!--l. 2797--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.3.1   </span> <a 
 id="x3-1010005.3.1"></a>Coil Design GUI</h4>
<!--l. 2801--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-10100136"></a>


<!--l. 2803--><p class="noindent" ><img 
src="Pictures/CoilDesignGUI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.36: </span><span  
class="content">Coil B1 Design Panel. An eight channel coil is shown.</span></div><!--tex4ht:label?: x3-10100136 -->

<!--l. 2806--><p class="noindent" ></div><hr class="endfigure">
<!--l. 2808--><p class="indent" >   Figure <a 
href="#x3-10100136">5.36<!--tex4ht:ref: fig:CoilDesignGUI --></a> demonstrates an overview of the Coil B1 Design interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-101003x1">Coil Element Macro Library <br 
class="newline" />
     <!--l. 2813--><p class="noindent" >The  Coil  Element  Macro  Library  contains  coil  element  macros  for
     constructing  coil  structure  in  MRiLab.  The  user  needs  to  click  the
     &#8216;CoilElem&#8217; root to unfold subsequent macros.
     </li>
     <li 
  class="enumerate" id="x3-101005x2">Coil Structure <br 
class="newline" />
     <!--l. 2817--><p class="noindent" >In MRiLab, a coil structure consists of arbitrary number of coil elements
     that are combined to create desired B1 field. The user can construct desired
     B1 field by changing the content within the coil structure. To add a macro
     into the coil structure, the user needs to click one macro in the macro
     library, then click on the coil structure root (i.e. MRiLabCoil) to which
     this macro is inserted, then click &#8216;+&#8217; macro operation button. To delete a
     macro from the coil structure, the user needs to click the unwanted macro,
     then click &#8216;-&#8217; macro operation button. To duplicate an existing macro, the
     user needs to first click the source macro, then click &#8216;C&#8217; macro operation
     button for copying, click on the coil structure root, then click &#8216;P&#8217; macro
     operation button for pasting. MRiLab doesn&#8217;t allow empty coil structure.
     </li>
     <li 
  class="enumerate" id="x3-101007x3">Coil Element Attribute <br 
class="newline" />
     <!--l. 2822--><p class="noindent" >Upon clicking on the coil element macro within the coil structure, the
     corresponding macro attributes will be shown at the coil element attribute
     panel down below the coil structure. The user can edit those attributes
     to modify the coil element so as to generate different B1 field. To make
     any modification effective, the user must press &#8216;Update&#8217; button to update
     the coil file. Pressing &#8216;Execute&#8217; button will update and redraw the B1 field
     map on this interface.
     </li>
     <li 
  class="enumerate" id="x3-101009x4">Coil B1 Field <br 
class="newline" />
     <!--l. 2826--><p class="noindent" >The  coil  configuration  and  B1  field  (T)  generated  based  on  the  coil
     structure is displayed on the &#8216;Coil Sensitivity&#8217; panel on the right side of
     this interface.
     </li>
     <li 
  class="enumerate" id="x3-101011x5">Coil Simulation Control <br 
class="newline" />

     <!--l. 2830--><p class="noindent" >The  &#8216;Display&#8217;  and  &#8216;Grid&#8217;  tab  on  the  &#8216;Coil  Simulation&#8217;  panel  contains
     parameters for controlling B1 field display.
         <ul class="itemize1">
         <li class="itemize">Colormap : The colormap for the B1 field, includes &#8216;Jet&#8217;, &#8216;Gray&#8217; and
         &#8216;Hot&#8217;
         </li>
         <li class="itemize">CLimDown (T) : The lower bound of color limits
         </li>
         <li class="itemize">CLimUp (T) : The upper bound of color limits
         </li>
         <li class="itemize">CoilDisplay : The flag for turning on and off coil display
         </li>
         <li class="itemize">CoilShow : The flag for choosing active coil for B1 field display
         </li>
         <li class="itemize">Mode : The B1 field display mode, includes &#8216;Magnitude&#8217;, &#8216;Phase&#8217;,
         &#8216;Real&#8217; and &#8216;Imaginary&#8217;
         </li>
         <li class="itemize">Plane : The flag for activating B1 field slicing plane, includes &#8216;XY&#8217;,
         &#8216;XZ&#8217; and &#8216;YZ&#8217;
         </li>
         <li class="itemize">XDimRes (m) : The display spatial resolution in X direction
         </li>
         <li class="itemize">YDimRes (m) : The display spatial resolution in Y direction
         </li>
         <li class="itemize">ZDimRes (m) : The display spatial resolution in Z direction</li></ul>
     </li></ol>
<!--l. 2847--><p class="indent" >   MRiLab provides a group of B1 field display button (Figure <a 
href="#x3-10101237">5.37<!--tex4ht:ref: fig:B1DisplayButton --></a>) to help inspect
the B1 field details.
<!--l. 2849--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-10101237"></a>


<!--l. 2851--><p class="noindent" ><img 
src="Pictures/B1DisplayButton.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.37: </span><span  
class="content">The B1 Field Display Button.</span></div><!--tex4ht:label?: x3-10101237 -->

<!--l. 2854--><p class="indent" >   </div><hr class="endfigure">
<!--l. 2856--><p class="indent" >   The B1 field display button group consists of:
     <ul class="itemize1">
     <li class="itemize"><span 
class="cmsy-10">&#x2227; </span>: Undock B1 field on active B1 slicing plane (Figure <a 
href="#x3-10101338">5.38<!--tex4ht:ref: fig:B1Field --></a>)
     </li>
     <li class="itemize">S+ : Move active B1 slicing plane forwards
     </li>
     <li class="itemize">S- : Move active B1 slicing plane backwards</li></ul>
<!--l. 2865--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-10101338"></a>


<!--l. 2867--><p class="noindent" ><img 
src="Pictures/B1Field.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.38: </span><span  
class="content">An Example of B1 Field on XY Plane.</span></div><!--tex4ht:label?: x3-10101338 -->

<!--l. 2870--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.3.2   </span> <a 
 id="x3-1020005.3.2"></a>Coil Element Macro Library</h4>
<!--l. 2875--><p class="noindent" >A coil element macro is a predefined module for creating a coil element that
generates B1 field in three dimensional space. MRiLab coil element macro library is
a collection of coil element macros covering simple coil geometries. This
section will give an introduction to each of the coil element macro provided in
MRiLab.
<!--l. 2877--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1030005.3.2"></a>CoilCircle</h5>
<!--l. 2879--><p class="noindent" >A coil element macro that creates a Biot-Savart coil circle. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">Azimuth (rad) : The azimuth angle of the circle plane
     </li>
     <li class="itemize">Elevation (rad) : The elevation angle of the circle plane
     </li>
     <li class="itemize">Radius (m) : The coil circle radius
     </li>
     <li class="itemize">PosZ (m) : The Z position of coil circle center
     </li>
     <li class="itemize">PosY (m) : The Y position of coil circle center
     </li>
     <li class="itemize">PosX (m) : The X position of coil circle center
     </li>
     <li class="itemize">CurrentDir : The current direction in the coil circle, 1 for clockwise, -1 for
     counterclockwise
     </li>
     <li class="itemize">Scale : The scale factor for the B1 field amplitude
     </li>
     <li class="itemize">Segment : The number of line segments for approximating circle, MRiLab
     requires the same &#8216;Segment&#8217; for each coil circle
     </li>
     <li class="itemize">CoilID : The assigned coil ID, each coil element must have distinct ID</li></ul>

<!--l. 2894--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1040005.3.2"></a>CoilUser</h5>
<!--l. 2896--><p class="noindent" >If the user has the B1 field data saved in a MAT file, the user can easily import
the B1 field into MRiLab coil design interface by using &#8216;CoilUser&#8217; macro.
The B1 field MAT file needs to contain two matrices including &#8216;B1x&#8217; (i.e. <span 
class="cmmi-10">x</span>
component of B1 field) and &#8216;B1y&#8217; (i.e. <span 
class="cmmi-10">y </span>component of B1 field). Both of the two
matrices must have the same size. The &#8216;CoilUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">B1File : The path to the file that stores the B1 field data, quoted using
     single quotes
     </li>
     <li class="itemize">Interp : The interpolation method, includes &#8216;linear&#8217;, &#8216;nearest&#8217; and &#8216;cubic&#8217;
     </li>
     <li class="itemize">PosZ (m) : The Z position of coil center (needed for coil display purpose)
     </li>
     <li class="itemize">PosY (m) : The Y position of coil center (needed for coil display purpose)
     </li>
     <li class="itemize">PosX (m) : The X position of coil center (needed for coil display purpose)
     </li>
     <li class="itemize">CoilID : The assigned coil ID, each coil element must have a distinct ID</li></ul>
<!--l. 2907--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3.3   </span> <a 
 id="x3-1050005.3.3"></a>Make New Coil</h4>
<!--l. 2909--><p class="noindent" >The user can also use the coil loading function to load another coil. To load a coil,
click &#8216;Load&#8217; menu then click &#8216;Load Coil File&#8217;, choose a coil XML file. After the coil is
loaded, press &#8216;Execute&#8217; to display field.<br 
class="newline" />
<!--l. 2911--><p class="indent" >   The user can create a new coil configuration in the Coil Design interface. To
create a new coil, click &#8216;New&#8217; then click &#8216;Create Coil File&#8217;. A coil creation window
(Figure <a 
href="#x3-10500139">5.39<!--tex4ht:ref: fig:NewCoil --></a>) will show up and ask for new coil name and notes. To follow MRiLab
naming convention, the user is recommended to use &#8216;Coil_&#8217; followed by the number of
coil elements and applied anatomy (e.g. Coil_16ChChest), make sure that the new
coil name is distinct to the existing coil names in MRiLab. Then click &#8216;OK&#8217; to select
a path for storing the coil XML file. It&#8217;s strongly recommended to put the coil under
the MRiLab coil root folder /Coil according to the coil type so that the coil is visible
to MRiLab. Finally, MRiLab will create a new coil XML file based on the content of
&#8216;Coil_1ChHead&#8217;.
<!--l. 2913--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-10500139"></a>


<!--l. 2915--><p class="noindent" ><img 
src="Pictures/NewCoil.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.39: </span><span  
class="content">The Coil Creation Window</span></div><!--tex4ht:label?: x3-10500139 -->

<!--l. 2918--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">5.4   </span> <a 
 id="x3-1060005.4"></a>Magnet dB0 Design</h3>
<!--l. 2923--><p class="noindent" >The Magnet dB0 Design toolbox can be activated by pressing &#8216;Magnet Design Panel&#8217;
toolbar icon located at the top of the main simulation console. The loaded magnet
will show in the Magnet dB0 Design interface.
<!--l. 2925--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-10600140"></a>


<!--l. 2927--><p class="noindent" ><img 
src="Pictures/MagnetDesignPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.40: </span><span  
class="content">Magnet Design Panel Toolbar Icon</span></div><!--tex4ht:label?: x3-10600140 -->

<!--l. 2930--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.4.1   </span> <a 
 id="x3-1070005.4.1"></a>Magnet Design GUI</h4>
<!--l. 2934--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-10700141"></a>


<!--l. 2936--><p class="noindent" ><img 
src="Pictures/MagnetDesignGUI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.41: </span><span  
class="content">Magnet dB0 Design Panel</span></div><!--tex4ht:label?: x3-10700141 -->

<!--l. 2939--><p class="noindent" ></div><hr class="endfigure">
<!--l. 2941--><p class="indent" >   Figure <a 
href="#x3-10700141">5.41<!--tex4ht:ref: fig:MagnetDesignGUI --></a> demonstrates an overview of the Magnet dB0 Design interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-107003x1">Magnet Element Macro Library <br 
class="newline" />
     <!--l. 2946--><p class="noindent" >The Magnet Element Macro Library contains magnet element macros for
     constructing magnet structure in MRiLab. The user needs to click the
     &#8216;MagElem&#8217; root to unfold subsequent macros.
     </li>
     <li 
  class="enumerate" id="x3-107005x2">Magnet Structure <br 
class="newline" />
     <!--l. 2950--><p class="noindent" >In MRiLab, a magnet structure consists of arbitrary number of magnet
     elements that are combined to create desired dB0 field. The user can
     construct desired dB0 field by changing the content within the magnet
     structure. To add a macro into the magnet structure, the user needs to
     click one macro in the macro library, then click on the magnet structure
     root (i.e. MRiLabMag) to which this macro is inserted, then click &#8216;+&#8217;
     macro operation button. To delete a macro from the magnet structure,
     the user needs to click the unwanted macro, then click &#8216;-&#8217; macro operation
     button. To duplicate an existing macro, the user needs to first click the
     source macro, then click &#8216;C&#8217; macro operation button for copying, click
     on the magnet structure root, then click &#8216;P&#8217; macro operation button for
     pasting. MRiLab doesn&#8217;t allow empty magnet structure.
     </li>
     <li 
  class="enumerate" id="x3-107007x3">Magnet Element Attribute <br 
class="newline" />
     <!--l. 2954--><p class="noindent" >Upon clicking on the magnet element macro within the magnet structure,
     the corresponding macro attributes will be shown at the magnet element
     attribute panel down below the magnet structure. The user can edit those
     attributes to modify the magnet element so as to generate different dB0
     field. To make any modification effective, the user must press &#8216;Update&#8217;
     button to update the magnet file. Pressing &#8216;Execute&#8217; button will update
     and redraw the dB0 field map on this interface.
     </li>
     <li 
  class="enumerate" id="x3-107009x4">Magnet Field <br 
class="newline" />
     <!--l. 2958--><p class="noindent" >The dB0 field (T) generated based on the magnet structure is displayed
     on the &#8216;Magnet Field&#8217; panel on the right side of this interface.
     </li>
     <li 
  class="enumerate" id="x3-107011x5">Magnet Simulation Control <br 
class="newline" />

     <!--l. 2962--><p class="noindent" >The &#8216;Display&#8217; and &#8216;Grid&#8217; tab on the &#8216;Magnet Simulation&#8217; panel contains
     parameters for controlling dB0 field display.
         <ul class="itemize1">
         <li class="itemize">Colormap : The colormap for the dB0 field, includes &#8216;Jet&#8217;, &#8216;Gray&#8217; and
         &#8216;Hot&#8217;
         </li>
         <li class="itemize">Plane : The flag for activating dB0 field slicing plane, includes &#8216;XY&#8217;,
         &#8216;XZ&#8217; and &#8216;YZ&#8217;
         </li>
         <li class="itemize">XDimRes (m) : The display spatial resolution in X direction
         </li>
         <li class="itemize">YDimRes (m) : The display spatial resolution in Y direction
         </li>
         <li class="itemize">ZDimRes (m) : The display spatial resolution in Z direction</li></ul>
     </li></ol>
<!--l. 2974--><p class="indent" >   MRiLab provides a group of dB0 field display button to help inspect the dB0 field
details. The dB0 field display button group consists of:
     <ul class="itemize1">
     <li class="itemize">S+ : Move active dB0 field slicing plane forwards
     </li>
     <li class="itemize">S- : Move active dB0 field slicing plane backwards</li></ul>
   <h4 class="subsectionHead"><span class="titlemark">5.4.2   </span> <a 
 id="x3-1080005.4.2"></a>Magnet Element Macro Library</h4>
<!--l. 2983--><p class="noindent" >A magnet element macro is a predefined module for creating a magnet element that
generates dB0 field in three dimensional space. MRiLab magnet element macro
library is a collection of magnet element macros. This section will give an
introduction to each of the magnet element macro provided in MRiLab.
<!--l. 2985--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1090005.4.2"></a>MagLinear</h5>
<!--l. 2987--><p class="noindent" >A magnet element macro that creates a linear dB0 field. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">GradZ (T/m) : The linear gradient of dB0 field in Z direction
     </li>
     <li class="itemize">GradY (T/m) : The linear gradient of dB0 field in Y direction

     </li>
     <li class="itemize">GradX (T/m) : The linear gradient of dB0 field in X direction
     </li>
     <li class="itemize">Scale : The scale factor for the dB0 field</li></ul>
<!--l. 2996--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1100005.4.2"></a>MagGaussian</h5>
<!--l. 2998--><p class="noindent" >A magnet element macro that creates a 3D Gaussian dB0 field. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">PosZ (m) : The Z position of the center
     </li>
     <li class="itemize">PosY (m) : The Y position of the center
     </li>
     <li class="itemize">PosX (m) : The X position of the center
     </li>
     <li class="itemize">DeltaZ (m) : The width of Gaussian function in Z direction
     </li>
     <li class="itemize">DeltaY (m) : The width of Gaussian function in Y direction
     </li>
     <li class="itemize">DeltaX (m) : The width of Gaussian function in X direction
     </li>
     <li class="itemize">Scale : The scale factor for the dB0 field</li></ul>
<!--l. 3011--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1110005.4.2"></a>MagSymbolic</h5>
<!--l. 3013--><p class="noindent" >A magnet element macro that creates a dB0 field based on symbolic equation. This
macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">Equation : An dB0 field equation</li></ul>
<!--l. 3019--><p class="indent" >   The symbolic equation could be any legal Matlab equation using variables &#8216;X&#8217;, &#8216;Y&#8217;
and &#8216;Z&#8217;. For example, &#8216;X+Y&#8217;, &#8216;2*X.*Y&#8217; and &#8216;2*sin(X)&#8217; etc. Notice that use element
operations for variables in the equation. The user needs to fill the equation between a
pair of single quotes.

<!--l. 3021--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1120005.4.2"></a>MagUser</h5>
<!--l. 3023--><p class="noindent" >If the user has the dB0 field data saved in a MAT file, the user can easily import the
dB0 field into MRiLab magnet design interface by using &#8216;MagUser&#8217; macro. The dB0
field MAT file needs to contain one matrix &#8216;dB0&#8217;. The &#8216;MagUser&#8217; macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">MagFile : The path to the file that stores the dB0 field data, quoted using
     single quotes
     </li>
     <li class="itemize">Interp : The interpolation method, includes &#8216;linear&#8217;, &#8216;nearest&#8217; and &#8216;cubic&#8217;</li></ul>
<!--l. 3030--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.4.3   </span> <a 
 id="x3-1130005.4.3"></a>Make New Magnet</h4>
<!--l. 3032--><p class="noindent" >The user can also use the magnet loading function to load another magnet. To load a
magnet, click &#8216;Load&#8217; menu then click &#8216;Load Magnet File&#8217;, choose a magnet XML
file.<br 
class="newline" />
<!--l. 3034--><p class="indent" >   The user can create a new magnet in the Magnet Design interface. To create a
new magnet, click &#8216;New&#8217; then click &#8216;Create Magnet File&#8217;. A magnet creation window
will show up and ask for new magnet name and notes. To follow MRiLab
naming convention, the user is recommended to use &#8216;Mag_&#8217; followed by a legal
string and applied anatomy (e.g. Mag_CustomHead), make sure that the new
magnet name is distinct to the remaining magnet names in MRiLab. Then
click &#8216;OK&#8217; to select a path for storing the magnet XML file. It&#8217;s strongly
recommended to put the magnet under the MRiLab magnet root folder
/Mag according to the magnet type so that the magnet is visible to MRiLab.
Finally, MRiLab will create a new magnet XML file based on the content of
&#8216;Mag_LinearHead&#8217;.
<!--l. 3036--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.5   </span> <a 
 id="x3-1140005.5"></a>Gradient Design</h3>
<!--l. 3038--><p class="noindent" >The Gradient Design toolbox can be activated by pressing &#8216;Gradient Design Panel&#8217;
toolbar icon located at the top of the main simulation console. The loaded gradient
will show in the Gradient Design interface.
<!--l. 3040--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-11400142"></a>


<!--l. 3042--><p class="noindent" ><img 
src="Pictures/GradientDesignPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.42: </span><span  
class="content">Gradient Design Panel Toolbar Icon</span></div><!--tex4ht:label?: x3-11400142 -->

<!--l. 3045--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.5.1   </span> <a 
 id="x3-1150005.5.1"></a>Gradient Design GUI</h4>
<!--l. 3049--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-11500143"></a>


<!--l. 3051--><p class="noindent" ><img 
src="Pictures/GradientDesignGUI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.43: </span><span  
class="content">Gradient Design Panel</span></div><!--tex4ht:label?: x3-11500143 -->

<!--l. 3054--><p class="noindent" ></div><hr class="endfigure">
<!--l. 3056--><p class="indent" >   Figure <a 
href="#x3-11500143">5.43<!--tex4ht:ref: fig:GradientDesignGUI --></a> demonstrates an overview of the Gradient Design interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-115003x1">Gradient Element Macro Library <br 
class="newline" />
     <!--l. 3062--><p class="noindent" >The Gradient Element Macro Library contains gradient element macros
     for constructing gradient structure in MRiLab. The user needs to click the
     &#8216;GradElem&#8217; root to unfold subsequent macros.
     </li>
     <li 
  class="enumerate" id="x3-115005x2">Gradient Structure <br 
class="newline" />
     <!--l. 3066--><p class="noindent" >In MRiLab, a gradient structure consists of three gradient elements that
     are combined to create gradient field for GzSS, GyPE and GxR. The user
     can construct desired gradient field by changing the content within the
     gradient structure. To add a macro into the gradient structure, the user
     needs to click one macro in the macro library, then click on the gradient
     structure root (i.e. MRiLabGrad) to which this macro is inserted, then
     click &#8216;+&#8217; macro operation button. To delete a macro from the gradient
     structure, the user needs to click the unwanted macro, then click &#8216;-&#8217; macro
     operation button. To duplicate an existing macro, the user needs to first
     click the source macro, then click &#8216;C&#8217; macro operation button for copying,
     click on the gradient structure root, then click &#8216;P&#8217; macro operation button
     for  pasting.  MRiLab  doesn&#8217;t  allow  empty  gradient  structure,  and  also
     requires each of the three gradient sequence lines must have an individual
     gradient field.
     </li>
     <li 
  class="enumerate" id="x3-115007x3">Gradient Element Attribute <br 
class="newline" />
     <!--l. 3070--><p class="noindent" >Upon clicking on the gradient element macro within the gradient structure,
     the corresponding macro attributes will be shown at the gradient element
     attribute  panel  down  below  the  gradient  structure.  The  user  can  edit
     those attributes to modify the gradient element so as to generate different
     gradient field. To make any modification effective, the user must press
     &#8216;Update&#8217; button to update the gradient file. Pressing &#8216;Execute&#8217; button will
     update and redraw the gradient field map on this interface.
     </li>
     <li 
  class="enumerate" id="x3-115009x4">Gradient Field <br 
class="newline" />
     <!--l. 3074--><p class="noindent" >The gradient field is represented using a three-dimensional quiver plot on
     the &#8216;Gradient Field&#8217; panel. If a constant unit gradient is used, the regular
     linear spatial location is applied. However, if non-unit gradient is used, the

     spatial location could be non-linear with spatial grid deformation. This
     means the original spatial location will be mapped to a new location in the
     spatial grid. The transformed spatial grid is represented as three slicing
     planes on the &#8216;Gradient Field&#8217; panel. The value (color) of the spatial grid
     equals to the spatial location in the direction indicated by &#8216;GradLine&#8217; in
     &#8216;Gradient Simulation&#8217; panel.
     </li>
     <li 
  class="enumerate" id="x3-115011x5">Gradient Simulation Control <br 
class="newline" />
     <!--l. 3078--><p class="noindent" >The &#8216;Display&#8217; and &#8216;Grid&#8217; tab on the &#8216;Gradient Simulation&#8217; panel contains
     parameters for controlling gradient field display.
         <ul class="itemize1">
         <li class="itemize">Colormap : The colormap for the spatial grid, includes &#8216;Jet&#8217;, &#8216;Gray&#8217;
         and &#8216;Hot&#8217;
         </li>
         <li class="itemize">Plane : The flag for activating grid slicing plane, includes &#8216;XY&#8217;, &#8216;XZ&#8217;
         and &#8216;YZ&#8217;
         </li>
         <li class="itemize">GradLine : The flag for activating gradient sequence line, includes
         &#8216;GzSS&#8217;, &#8216;GyPE&#8217; and &#8216;GxR&#8217;
         </li>
         <li class="itemize">DispMode : The display mode, includes &#8216;Gradient&#8217;, &#8216;Grid&#8217; and &#8216;Both&#8217;
         </li>
         <li class="itemize">XDimRes (m) : The display spatial resolution in X direction
         </li>
         <li class="itemize">YDimRes (m) : The display spatial resolution in Y direction
         </li>
         <li class="itemize">ZDimRes (m) : The display spatial resolution in Z direction</li></ul>
     </li></ol>
<!--l. 3092--><p class="indent" >   MRiLab provides a group of grid display button to help inspect the grid details.
The grid display button group consists of:
     <ul class="itemize1">
     <li class="itemize">S+ : Move active grid slicing plane forwards
     </li>
     <li class="itemize">S- : Move active grid slicing plane backwards</li></ul>

   <h4 class="subsectionHead"><span class="titlemark">5.5.2   </span> <a 
 id="x3-1160005.5.2"></a>Gradient Element Macro Library</h4>
<!--l. 3102--><p class="noindent" >A gradient element macro is a predefined module for creating a gradient element
that generates gradient field in three dimensional space. MRiLab gradient
element macro library is a collection of gradient element macros. This section
will give an introduction to each of the gradient element macro provided in
MRiLab.
<!--l. 3104--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1170005.5.2"></a>GradLinear</h5>
<!--l. 3106--><p class="noindent" >A gradient element macro that creates a linear gradient field. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">GradZ :  A constant  of  gradient  field  vector  in  Z direction,  1  for  unit
     gradient
     </li>
     <li class="itemize">GradY : A constant of gradient field vector in Y direction, 1 for unit
     gradient
     </li>
     <li class="itemize">GradX : A constant of gradient field vector in X direction, 1 for unit
     gradient
     </li>
     <li class="itemize">GradLine : A gradient sequence line assigned to this gradient field</li></ul>
<!--l. 3116--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1180005.5.2"></a>GradSymbolic</h5>
<!--l. 3118--><p class="noindent" >A gradient element macro that creates a gradient field based on symbolic equation.
This macro contains attributes including:
     <ul class="itemize1">
     <li class="itemize">GradZEqu : An equation for gradient field vector in Z direction
     </li>
     <li class="itemize">GradYEqu : An equation for gradient field vector in Y direction
     </li>
     <li class="itemize">GradXEqu : An equation for gradient field vector in X direction
     </li>
     <li class="itemize">GradLine : A gradient sequence line assigned to this gradient field</li></ul>

<!--l. 3127--><p class="indent" >   The symbolic equation could be any legal Matlab equation using variables &#8216;X&#8217;, &#8216;Y&#8217;
and &#8216;Z&#8217;. For example, &#8216;X+Y&#8217;, &#8216;2*X.*Y&#8217; and &#8216;2*sin(X)&#8217; etc. Notice that use element
operations for variables in the equation. The user needs to fill the equation between a
pair of single quotes.
<!--l. 3129--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1190005.5.2"></a>GradUser</h5>
<!--l. 3131--><p class="noindent" >If the user has the gradient field data saved in a MAT file, the user can easily import
the gradient field into MRiLab gradient design interface by using &#8216;GradUser&#8217; macro.
The gradient field MAT file needs to contain one four dimensional matrix &#8216;G&#8217; with
the size of the fourth dimension equal to 3. G(:,:,:,1) is the <span 
class="cmmi-10">x </span>component of the
gradient vector, G(:,:,:,2) is the <span 
class="cmmi-10">y </span>component of the gradient vector and G(:,:,:,3) is
the <span 
class="cmmi-10">z </span>component of the gradient vector. The &#8216;GradUser&#8217; macro contains attributes
including:
     <ul class="itemize1">
     <li class="itemize">GradFile : The path to the file that stores the gradient field data, quoted
     using single quotes
     </li>
     <li class="itemize">Interp : The interpolation method, includes &#8216;linear&#8217;, &#8216;nearest&#8217; and &#8216;cubic&#8217;
     </li>
     <li class="itemize">GradLine : A gradient sequence line assigned to this gradient field</li></ul>
<!--l. 3140--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.5.3   </span> <a 
 id="x3-1200005.5.3"></a>Make New Gradient</h4>
<!--l. 3142--><p class="noindent" >The user can also use the gradient loading function to load another gradient. To load
a gradient, click &#8216;Load&#8217; menu then click &#8216;Load Gradient File&#8217;, choose a gradient XML
file.<br 
class="newline" />
<!--l. 3144--><p class="indent" >   The user can create a new gradient in the Gradient Design interface. To create a
new gradient, click &#8216;New&#8217; then click &#8216;Create Gradient File&#8217;. A gradient creation
window will show up and ask for new gradient name and notes. To follow MRiLab
naming convention, the user is recommended to use &#8216;Grad_&#8217; followed by a legal string
and applied anatomy (e.g. Grad_CustomHead), make sure that the new
gradient name is distinct to the existing gradient names in MRiLab. Then
click &#8216;OK&#8217; to select a path for storing the gradient XML file. It&#8217;s strongly
recommended to put the gradient under the MRiLab gradient root folder /Grad
according to the gradient type so that the gradient is visible to MRiLab.
Finally, MRiLab will create a new gradient XML file based on the content of
&#8216;Grad_LinearHead&#8217;.

<!--l. 3147--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.6   </span> <a 
 id="x3-1210005.6"></a>Motion Design</h3>
<!--l. 3149--><p class="noindent" >The Motion Design toolbox can be activated by pressing &#8216;Motion Design Panel&#8217;
toolbar icon located at the top of the main simulation console.
<!--l. 3151--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-12100144"></a>


<!--l. 3153--><p class="noindent" ><img 
src="Pictures/MotionDesignPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.44: </span><span  
class="content">Motion Design Panel Toolbar Icon</span></div><!--tex4ht:label?: x3-12100144 -->

<!--l. 3156--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">5.6.1   </span> <a 
 id="x3-1220005.6.1"></a>Motion Design Panel</h4>
<!--l. 3160--><p class="noindent" ><hr class="figure"><div class="figure" 
>

<a 
 id="x3-12200145"></a>


<!--l. 3162--><p class="noindent" ><img 
src="Pictures/MotionDesignGUI.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.45: </span><span  
class="content">Motion Design Panel</span></div><!--tex4ht:label?: x3-12200145 -->

<!--l. 3165--><p class="noindent" ></div><hr class="endfigure">
<!--l. 3167--><p class="indent" >   Figure <a 
href="#x3-12200145">5.45<!--tex4ht:ref: fig:MotionDesignGUI --></a> demonstrates an overview of the Motion Design interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-122003x1">Motion Element Macro Library <br 
class="newline" />
     <!--l. 3172--><p class="noindent" >The Motion Element Macro Library contains motion element macros for
     constructing motion structure in MRiLab. The user needs to click the
     &#8216;MotElem&#8217; root to unfold subsequent macros.
     </li>
     <li 
  class="enumerate" id="x3-122005x2">Motion Structure <br 
class="newline" />
     <!--l. 3177--><p class="noindent" >In MRiLab, a motion structure consists of arbitrary number of motion
     elements that are combined to create desired motion pattern. The user
     can construct desired motion pattern by changing the content within the
     motion structure. To add a macro into the motion structure, the user
     needs to click one macro in the macro library, then click on the motion
     structure root (i.e. MRiLabMot) to which this macro is inserted, then click
     &#8216;+&#8217; macro operation button. To delete a macro from the motion structure,
     the user needs to click the unwanted macro, then click &#8216;-&#8217; macro operation
     button. To duplicate an existing macro, the user needs to first click the
     source macro, then click &#8216;C&#8217; macro operation button for copying, click
     on the motion structure root, then click &#8216;P&#8217; macro operation button for
     pasting. MRiLab doesn&#8217;t allow empty motion structure.
     </li>
     <li 
  class="enumerate" id="x3-122007x3">Motion Element Attribute <br 
class="newline" />
     <!--l. 3182--><p class="noindent" >Upon clicking on the motion element macro within the motion structure,
     the corresponding macro attributes will be shown at the motion element
     attribute panel down below the motion structure. The user can edit those
     attributes to modify the motion element so as to generate different motion
     pattern. To make any modification effective, the user must press &#8216;Update&#8217;
     button to update the motion file. Pressing &#8216;Execute&#8217; button will update
     and recalculate the motion track.
     </li>
     <li 
  class="enumerate" id="x3-122009x4">Motion Tracker <br 
class="newline" />
     <!--l. 3186--><p class="noindent" >MRiLab uses Matlab Simulink 3D Animation to monitor the movement
     track of an imaging object in a motion tracker window. To open this
     window, the user needs to press &#8216;3D Play&#8217; button. In the 3D animation,
     the imaging object is represented as a sphere or ellipsoid attached with
     three small spheres indicating axis directions (red for <span 
class="cmmi-10">x </span>axis, green for <span 
class="cmmi-10">y</span>
     axis and blue for <span 
class="cmmi-10">z </span>axis).

     </li>
     <li 
  class="enumerate" id="x3-122011x5">Motion Simulation Control <br 
class="newline" />
     <!--l. 3190--><p class="noindent" >The &#8216;Display&#8217; and &#8216;Replay&#8217; tab on the &#8216;Motion Simulation&#8217; panel contains
     parameters for controlling 3D animation.
         <ul class="itemize1">
         <li class="itemize">Object : The object model, currently only supports &#8216;Sphere&#8217;
         </li>
         <li class="itemize">ViewPoint : A default view point, includes &#8216;ZPos&#8217;, &#8216;YPos&#8217; and &#8216;XPos&#8217;
         </li>
         <li class="itemize">ZoomOut : A factor of view zoom out
         </li>
         <li class="itemize">Sample : The sample steps between two adjacent positions during
         movement
         </li>
         <li class="itemize">Repeat : The repeat time of playback</li></ul>
     </li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.6.2   </span> <a 
 id="x3-1230005.6.2"></a>Motion Element Macro Library</h4>
<!--l. 3205--><p class="noindent" >A motion element macro is a predefined module for creating a motion element that
generates a movement track in three dimensional space. MRiLab motion
element macro library is a collection of motion element macros. This section
will give an introduction to each of the motion element macro provided in
MRiLab.
<!--l. 3207--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1240005.6.2"></a>MotTranslate</h5>
<!--l. 3209--><p class="noindent" >A motion element macro that creates translation motion. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The motion starting time
     </li>
     <li class="itemize">tEnd (s) : The motion ending time
     </li>
     <li class="itemize">dt (s) : The time interval of the motion track sample steps
     </li>
     <li class="itemize">Direction : A vector describing translation direction in 3D space

     </li>
     <li class="itemize">Displacement (m) : An equation of translation displacement pattern with
     respect to time</li></ul>
<!--l. 3219--><p class="indent" >   The displacement equation could be any legal Matlab equation using variables &#8216;t&#8217;.
For example, &#8216;2*t&#8217;, &#8216;t+200e-3&#8217; and &#8216;0.05*sin(0.1*t)&#8217; etc. Notice that the user needs to
fill the equation between a pair of single quotes.
<!--l. 3222--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1250005.6.2"></a>MotRotate</h5>
<!--l. 3224--><p class="noindent" >A motion element macro that creates rotation motion. This macro contains
attributes including:
     <ul class="itemize1">
     <li class="itemize">tStart (s) : The motion starting time
     </li>
     <li class="itemize">tEnd (s) : The motion ending time
     </li>
     <li class="itemize">dt (s) : The time interval of the motion track sample steps
     </li>
     <li class="itemize">Axis : A vector describing rotation axis in 3D space
     </li>
     <li class="itemize">Angle (rad) : An equation of rotation angle with respect to time</li></ul>
<!--l. 3234--><p class="indent" >   The rotation angle equation could be any legal Matlab equation using variables
&#8216;t&#8217;. For example, &#8216;2*t&#8217;, &#8216;t+200e-3&#8217; and &#8216;sin(0.1*t)&#8217; etc. Notice that the user needs to
fill the equation between a pair of single quotes.
<!--l. 3237--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.6.3   </span> <a 
 id="x3-1260005.6.3"></a>Make New Motion</h4>
<!--l. 3239--><p class="noindent" >The user can also use the motion loading function to load another motion. To load a
motion, click &#8216;Load&#8217; menu then click &#8216;Load Motion File&#8217;, choose a motion XML
file.<br 
class="newline" />
<!--l. 3241--><p class="indent" >   The user can create a new motion in the Motion Design interface. To create a new
motion, click &#8216;New&#8217; then click &#8216;Create Motion File&#8217;. A motion creation window will
show up and ask for new motion name and notes. To follow MRiLab naming
convention, the user is recommended to use &#8216;Mot_&#8217; followed by a legal string and
applied anatomy (e.g. Mot_CustomHead), make sure that the new motion name is
distinct to the existing motion names in MRiLab. Then click &#8216;OK&#8217; to select a
path for storing the motion XML file. It&#8217;s strongly recommended to put

the motion under the MRiLab motion root folder /Mot according to the
motion type so that the motion is visible to MRiLab. Finally, MRiLab will
create a new motion XML file based on the content of &#8216;Mot_ShiftHead&#8217;.
<br 
class="newline" />
<!--l. 3243--><p class="indent" >   Note that adding a motion pattern is not guaranteed to stimulate motion, the
user also needs to use extended real time process to trigger motion at the Ext
sequence line. To trigger motion, one or more Ext flag 8 needs to be inserted into Ext
line. An accurate motion tracking can be achieved using both small time interval of
the motion track sample steps and frequent motion triggering, which typically
requires more simulation computing. The interested users are referred to
PSD_GRE3D for more information.
<!--l. 3245--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.7   </span> <a 
 id="x3-1270005.7"></a>Image Reconstruction</h3>
<!--l. 3247--><p class="noindent" >MRiLab provides default image reconstruction code for a few types of Cartesian and
Non-Cartesian K-Space reconstruction. External reconstruction code is also
acceptable.
<!--l. 3249--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.7.1   </span> <a 
 id="x3-1280005.7.1"></a>Default Engine</h4>
<!--l. 3251--><p class="noindent" >To choose default reconstruction for Cartesian readout, the user needs to choose
&#8216;Cartesian&#8217; for &#8216;ReconType&#8217; under the &#8216;Recon&#8217; tab. The Cartesian reconstruction can
be applied to typical Cartesian readout, FSE readout and EPI readout using default
gradient macros. To choose default reconstruction for Non-Cartesian readout, the
user needs to choose &#8216;NonCart&#8217; for &#8216;ReconType&#8217;. The corresponding Non-Cartesian
reconstruction code can be applied to radial readout and spiral readout. Notice
that the Non-Cartesian reconstruction performs 2D gridding process for the
Non-Cartesian K-Space trajectory using a Kaiser-Bessel kernel, followed by a regular
iFFT. The 2D gridding process should also in theory be applicable to other
Non-Cartesian readout. Also the &#8216;gridding&#8217; tab is required to perform Non-Cartesian
reconstruction.
<!--l. 3254--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.7.2   </span> <a 
 id="x3-1290005.7.2"></a>External Engine</h4>
<!--l. 3256--><p class="noindent" >If the user designed a special K-Space trajectory that requires particular
reconstruction code, the user needs to indicate using external reconstruction by
changing &#8216;ReconEng&#8217; to &#8216;External&#8217;, and then provides a reconstruction function
quoted with a pair of single quotes for &#8216;ExternalEng&#8217;. It is recommended to put the
external code under /Recon/External, if not, make sure the reconstruction code is in
Matlab searching path. This setting will simply ignore default reconstruction code

and apply external code. It is strongly recommended to write your own
reconstruction code based on the template :

   <div class="verbatim" id="verbatim-13">
function&#x00A0;DoCustomRecon
&#x00A0;<br />%Create&#x00A0;an&#x00A0;external&#x00A0;reconstruction&#x00A0;based&#x00A0;on&#x00A0;your&#x00A0;code
&#x00A0;<br />global&#x00A0;VCtl&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VCtl&#x00A0;structure,&#x00A0;read&#x00A0;only
&#x00A0;<br />global&#x00A0;VSig&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VSig&#x00A0;structure,&#x00A0;read&#x00A0;only
&#x00A0;<br />global&#x00A0;VImg&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;use&#x00A0;VImg&#x00A0;structure,&#x00A0;read&#x00A0;and&#x00A0;write
&#x00A0;<br />
&#x00A0;<br />%&#x00A0;The&#x00A0;main&#x00A0;code&#x00A0;for&#x00A0;your&#x00A0;reconstruction
&#x00A0;<br />...
&#x00A0;<br />
&#x00A0;<br />%&#x00A0;Store&#x00A0;recon&#x00A0;image&#x00A0;into&#x00A0;VImg&#x00A0;structure
&#x00A0;<br />VImg.Real&#x00A0;=&#x00A0;...;
&#x00A0;<br />VImg.Imag&#x00A0;=&#x00A0;...;
&#x00A0;<br />VImg.Mag&#x00A0;=&#x00A0;...;
&#x00A0;<br />VImg.Phase&#x00A0;=&#x00A0;...;
&#x00A0;<br />VImg.Sx&#x00A0;=&#x00A0;...;
&#x00A0;<br />VImg.Sy&#x00A0;=&#x00A0;...;
&#x00A0;<br />...
&#x00A0;<br />
&#x00A0;<br />end
</div>
<!--l. 3278--><p class="nopar" >
<!--l. 3280--><p class="indent" >   Notice that there are two new Virtual Structures (VSig and VImg) in this
template, VSig encapsules acquired MR signal. VImg is declared to store
reconstructed images. For the structure &#8216;VSig&#8217;, MRiLab provides :
     <ul class="itemize1">
     <li class="itemize">VSig.Sx : A array storing <span 
class="cmmi-10">x </span>(real) component of acquired MR signal
     </li>
     <li class="itemize">VSig.Sy : A array storing <span 
class="cmmi-10">y </span>(imaginary) component of acquired MR signal
     </li>
     <li class="itemize">VSig.Kz (1/m) : A array storing Kz location of K-Space trajectory
     </li>
     <li class="itemize">VSig.Ky (1/m) : A array storing Ky location of K-Space trajectory
     </li>
     <li class="itemize">VSig.Kx (1/m) : A array storing Kx location of K-Space trajectory</li></ul>
<!--l. 3290--><p class="indent" >   The sample points in these arrays are organized in the order of <br 
class="newline" />

<!--l. 3292--><p class="indent" >   Sample points in one readout <span 
class="cmmi-10">&#x003C; </span>Multiple echos <span 
class="cmmi-10">&#x003C; </span>First phase encoding <span 
class="cmmi-10">&#x003C; </span>Second
phase encoding <span 
class="cmmi-10">&#x003C; </span>Coil channel <span 
class="cmmi-10">&#x003C; </span>Spin species <br 
class="newline" />
<!--l. 3294--><p class="indent" >   For the structure &#8216;VImg&#8217;, MRiLab provides :
     <ul class="itemize1">
     <li class="itemize">VImg.Real : A matrix for real component of reconstructed complex image
     with a size of <span 
class="cmmi-10">RY Dim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">RXDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">RZDim</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">RxCoilNum</span><span 
class="cmsy-10">&#x00D7;</span><span 
class="cmmi-10">TEPerTR</span>
     </li>
     <li class="itemize">VImg.Imag : A matrix for imaginary component of reconstructed complex
     image  with  a  size  of  <span 
class="cmmi-10">RY Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RXDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RxCoilNum </span><span 
class="cmsy-10">&#x00D7;</span>
     <span 
class="cmmi-10">TEPerTR</span>
     </li>
     <li class="itemize">VImg.Mag : A matrix for magnitude of reconstructed complex image with
     a size of <span 
class="cmmi-10">RY Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RXDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RxCoilNum </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TEPerTR</span>
     </li>
     <li class="itemize">VImg.Phase : A matrix for phase of reconstructed complex image with a
     size of <span 
class="cmmi-10">RY Dim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RXDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RZDim </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">RxCoilNum </span><span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">TEPerTR</span>
     </li>
     <li class="itemize">VImg.Sx : A matrix for <span 
class="cmmi-10">x </span>(real) component of sorted complex MR signal
     in Cartesian grid
     </li>
     <li class="itemize">VImg.Sy : A matrix for <span 
class="cmmi-10">y </span>(imaginary) component of sorted complex MR
     signal in Cartesian grid</li></ul>
<!--l. 3304--><p class="indent" >   where <span 
class="cmmi-10">RXDim</span>, <span 
class="cmmi-10">RY Dim </span>and <span 
class="cmmi-10">RZDim </span>are reconstructed image resolution in three
spatial directions.
<!--l. 3306--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x3-1300005.7.2"></a>Gadgetron</h5>
<!--l. 3308--><p class="noindent" >If the user are interested in using Gadgetron for image reconstruction, MRiLab also
provides a simple MEX code to convert the acquired data into ISMRMRD file which
can be used in Gadgetron process. To activate this function, the user needs to install
ISMRMRD dependency packages to properly run compiled interface MEX. I am
currently working on improving MRiLab support to Gadgetron recon framework.
And I will be very pleased to talk with any MRiLab users who are willing to
contribute to improving MRiLab Gadgetron support. Please don&#8217;t hesitate to
contact me. The ISMRMRD relevant code is &#8216;DoToHDF5.m&#8217; under /Src and
&#8216;DoMatToHDF5&#8217; under /Lib/src/interface.

<!--l. 3310--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5.8   </span> <a 
 id="x3-1310005.8"></a>Simulation Output</h3>
<!--l. 3312--><p class="noindent" >MRiLab can save simulation output into two file formats including &#8216;MAT&#8217; and
&#8216;ISMRMRD&#8217;. The user can choose &#8216;OutputType&#8217; under &#8216;Recon&#8217; tab. If the user
choose &#8216;ISMRMRD&#8217; format, the &#8216;DoMatToHDF5&#8217; MEX has to be functional, if not,
MAT file will be saved instead. MRiLab saves simulation output for each series into a
folder named by MRiLab&#8217;s startup time under /Output folder. For MAT file,
MRiLab saves:
     <ul class="itemize1">
     <li class="itemize">SeqXMLFile : Applied sequence XML file
     </li>
     <li class="itemize">SeriesName : Series name on the main control console
     </li>
     <li class="itemize">VCtl : Virtual Control structure
     </li>
     <li class="itemize">VImg : Virtual Image structure
     </li>
     <li class="itemize">VSig : Virtual Signal structure</li></ul>

<!--l. 3322--><p class="indent" >

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;6</span><br /><a 
 id="x3-1320006"></a>Image Display and Analysis</h2>
<!--l. 3324--><p class="noindent" >MRiLab incorporated a set of image display and analysis tools which are designed
using Matlab GUIDE, and carefully tuned for manipulating MRiLab generated
multi-dimensional image data.
   <h3 class="sectionHead"><span class="titlemark">6.1   </span> <a 
 id="x3-1330006.1"></a>MagicRightClick</h3>
<!--l. 3327--><p class="noindent" >The user can right click on any MRiLab graphical axes to create an individual figure
with the identical graphical content.
<!--l. 3329--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x3-1340006.2"></a>MatrixUser</h3>
<!--l. 3330--><p class="noindent" >MRiLab incorporated a toolbox called &#8216;MatrixUser&#8217; for performing image display and
analysis. This toolbox can be activated by pressing &#8216;MatrixUser&#8217; toolbar icon located
at the top of the main simulation console.
<!--l. 3332--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1340011"></a>


<!--l. 3334--><p class="noindent" ><img 
src="Pictures/MatrixUserPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.1: </span><span  
class="content">MatrixUser Toolbar Icon</span></div><!--tex4ht:label?: x3-1340011 -->

<!--l. 3337--><p class="indent" >   </div><hr class="endfigure">
<!--l. 3339--><p class="indent" >   MatrixUser will search through the current output folder and load all image series
from this folder into Matlab base workspace. The MatrixUser main window (Figure
<a 
href="#x3-1340022">6.2<!--tex4ht:ref: fig:MatrixUser --></a>) works as a matrix manager for loaded images. The user can choose to display
image series by using the pop-up menu. The matrix size, type and value range are
calculated and provided on the right side. The user can press &#8216;MatrixUser&#8217; button to
activate MatrixUser display window. Current MatrixUser version supports
displaying any valid Matlab multi-dimensional matrix and Matlab structure
variable.
<!--l. 3341--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1340022"></a>


<!--l. 3343--><p class="noindent" ><img 
src="Pictures/MatrixUser.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.2: </span><span  
class="content">MatrixUser Main Window</span></div><!--tex4ht:label?: x3-1340022 -->

<!--l. 3346--><p class="indent" >   </div><hr class="endfigure">
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
 id="x3-1350006.2.1"></a>Data Import</h4>
<!--l. 3351--><p class="noindent" >By default, MatrixUser reads Matlab base workspace, scans existing matrices in the
Matlab session, then creates a matrix list for tracking matrix content. Once those
matrices are updated by the user, MatrixUser will also update the matrix
list. Moreover, there are several different approaches to import data from
outside Matlab into MatrixUser. The imported matrices will be saved into
Matlab base workspace. The import functions are located under &#8216;Load&#8217; menu,
including:
     <ul class="itemize1">
     <li class="itemize">Load MAT file
     <!--l. 3357--><p class="noindent" >The default Matlab .mat file is natively supported by MatrixUser.
     </li>
     <li class="itemize">Load System Clipboard
     <!--l. 3361--><p class="noindent" >If image content exists in the system clipboard, it can be converted into a
     RGB image which contains a three slice matrix with each slice corresponds
     to an individual Red, Green and Blue channel.
     </li>
     <li class="itemize">Load ScreenShot
     <!--l. 3365--><p class="noindent" >MatrixUser takes a full screenshot for current monitor and saves it into a
     RGB image as described above.
     </li>
     <li class="itemize">Load from Binary file
     <!--l. 3369--><p class="noindent" >Binary data file is supported by MatrixUser. The user needs to properly
     configure loading parameters (Figure <a 
href="#x3-1350013">6.3<!--tex4ht:ref: fig:LoadFromBinary --></a>) according to the matrix size and
     data type information.
     <!--l. 3371--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-1350013"></a>   <img 
src="Pictures/LoadFromBinary.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.3: </span><span  
class="content">MatrixUser Binary File Loading Interface</span></div><!--tex4ht:label?: x3-1350013 -->
     <!--l. 3376--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li class="itemize">Load DICOM file(s)
     <!--l. 3380--><p class="noindent" >MatrixUser supports loading multiple DICOM files by using a file filter
     interface (Figure <a 
href="#x3-1350024">6.4<!--tex4ht:ref: fig:LoadFromDICOM --></a>). The user needs to load DICOM files into the
     loading interface by selecting desired DICOM files (multiple selection
     supported). The selected files are listed in the DICOM file list. The user can
     click any single DICOM file to read associated DICOM header and
     image preview. To manually create a matrix using DICOM files, choose

     files from the DICOM file list, press &#8216;<span 
class="cmmi-10">&#x003E;&#x003E;&#x003E;&#x003E;&#x003E;&#x003E;</span>&#8217; to push the files into
     selected DICOM file list, provide a matrix name, press &#8216;Convert&#8217; button
     to create a matrix based on chosen DICOM files. The user can load
     those created matrices into base workspace by pressing &#8216;Load matrix&#8217;
     button.
     <!--l. 3382--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-1350024"></a>   <img 
src="Pictures/LoadFromDICOM.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.4: </span><span  
class="content">MatrixUser DICOM File Loading Interface</span></div><!--tex4ht:label?: x3-1350024 -->
     <!--l. 3387--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li class="itemize">Load DICOM file(s) in Batch
     <!--l. 3391--><p class="noindent" >MatrixUser supports loading DICOM files in a batch mode. This function
     requires the path of the folder containing DICOM files is provided. MatrixUser
     will try to create separate matrices for DICOM files coming from different
     image series. A matrix selection interface will provide converted matrices with
     loading functions.
     </li>
     <li class="itemize">Load from NIfTI file
     <!--l. 3395--><p class="noindent" >NIfTI file with .nii suffix is supported by MatrixUser.
     </li></ul>
<!--l. 3400--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
 id="x3-1360006.2.2"></a>Window Layout</h4>
<!--l. 3402--><p class="noindent" >To activate MatrixUser display window, press &#8216;MatrixUser&#8217; button. If the selected
matrix contains complex value, four options are available for displaying magnitude,
phase, real and imaginary of the matrix. Figure <a 
href="#x3-1360015">6.5<!--tex4ht:ref: fig:MatrixUserDisplayPanel --></a> demonstrates an overview of
the window layout of the MatrixUser display window. The window consists
of
<!--l. 3405--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1360015"></a>


<!--l. 3407--><p class="noindent" ><img 
src="Pictures/MatrixUserDisplayPanel.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.5: </span><span  
class="content">MatrixUser Display Window</span></div><!--tex4ht:label?: x3-1360015 -->

<!--l. 3410--><p class="indent" >   </div><hr class="endfigure">
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-136003x1">Matlab Default Toolbar <br 
class="newline" />
     <!--l. 3417--><p class="noindent" >Matlab toolbar provides basic interactive functions for displaying matrix.
     These functions include:
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/SaveFig.png" alt="pict"  
>  : Save current image axes into an image file
         </li>
         <li class="itemize">   <img 
src="Pictures/ZoomIn.png" alt="pict"  
>  : Zoom in matrix area
         </li>
         <li class="itemize">   <img 
src="Pictures/ZoomOut.png" alt="pict"  
>  : Zoom out matrix area
         </li>
         <li class="itemize">   <img 
src="Pictures/Pan.png" alt="pict"  
>  : Manually move matrix position
         </li>
         <li class="itemize">   <img 
src="Pictures/DataCursor.png" alt="pict"  
>  : Check individual voxel value and index
         </li>
         <li class="itemize">   <img 
src="Pictures/Print.png" alt="pict"  
>  : Print current figure
         </li>
         <li class="itemize">   <img 
src="Pictures/Colorbar.png" alt="pict"  
>  : Turn on/off color bar</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-136005x2">MatrixUser Function Library <br 
class="newline" />
     <!--l. 3431--><p class="noindent" >Most of the matrix analysis functions are represented on function bench panel.
     MatrixUser groups these functions into categories and dynamically loads them
     according to the dimension size and compatibility of current display matrix. A
     multi-tab is used to contain individual function button associated with each
     function. The tabs under the multi-tab are used to switch between function
     categories, which include
         <ul class="itemize1">
         <li class="itemize">Display : Multi-dimensional matrix display functions
         </li>
         <li class="itemize">QuickMath : Perform math calculation for current matrix
         </li>
         <li class="itemize">Transform : Transform current matrix
         </li>
         <li class="itemize">Process : Basic matrix processing functions
         </li>
         <li class="itemize">ROI : Region-of-Interest functions

         </li>
         <li class="itemize">Segment : Segmentation functions
         </li>
         <li class="itemize">Surface : Generate surface or mesh plot for current image
         </li>
         <li class="itemize">Matlab : Matlab default image tools
         </li>
         <li class="itemize">More : Uncategorized functions</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-136007x3">Matrix Calculator <br 
class="newline" />
     <!--l. 3449--><p class="noindent" >The matrix calculator consists of three control items, including a matrix
     expression editbox, an execution button (    <img 
src="Pictures/MatrixCalc.png" alt="pict"  
> ) and a matrix saving button (
      <img 
src="Pictures/Upload.png" alt="pict"  
> ). Valid matrix calculation expression can be executed in the calculator
     and updated in the display window, serving as a convenient way to analyze
     matrix calculation result. Matrix concatenation and recombination can also be
     done in the calculator, for example, to side-by-side compare multiple 3D
     matrices (Figure <a 
href="#x3-1360086">6.6<!--tex4ht:ref: fig:MatrixCalcExample --></a>). Some valid calculation examples are, but not limited
     to:
         <ul class="itemize1">
         <li class="itemize">A,B Combines A and B in one row
         </li>
         <li class="itemize">A,B;C,D Combines A and B in the first row, C and D in the second
         row
         </li>
         <li class="itemize">A,B;C,zeros(size(C)) Combines A and B in the first row, C in the
         second row, pad with zero value
         </li>
         <li class="itemize">sin(A),cos(B) Calculates voxel-wise sin for A and cos for B, then
         combine them in one row
         </li>
         <li class="itemize">A(:,1:10,:) Extracts submatrix from A and display it</li></ul>
     <!--l. 3458--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-1360086"></a>   <img 
src="Pictures/MatrixCalcExample.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.6: </span><span  
class="content">MatrixUser Concatenation Example</span></div><!--tex4ht:label?: x3-1360086 -->
     <!--l. 3463--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 3465--><p class="noindent" >where A, B, C and D are multi-dimensional matrices with proper matrix size.
     Also note that the source matrices have to stay in the base workspace
     for being referenced. Pressing the execution button will perform the
     calculation and save the result as a temporary matrix. The user can
     also save the temporary matrix into workspace by pressing matrix
     saving button. The saved temporary matrix will have a &#8216;_tmp&#8217; suffix by
     default.

     </li>
     <li 
  class="enumerate" id="x3-136010x4">Matrix Display Axes <br 
class="newline" />
     <!--l. 3469--><p class="noindent" >The display axes renders an image for one slice of current matrix. The user can
     use mouse cursor to inspect the coordinate and value of any voxel. Moving
     mouse wheel back and forth moves the slice location along current dimension
     and updates the display axes.
     </li>
     <li 
  class="enumerate" id="x3-136012x5">Matrix Color Control Group <br 
class="newline" />
     <!--l. 3473--><p class="noindent" >The matrix color control group provides a set of sliders, editboxes and popup
     menu which help control image color scheme and contrast. This group consists
     of
         <ul class="itemize1">
         <li class="itemize">Colormap Popup Menu: Choose different colormap scheme
         </li>
         <li class="itemize">Upper Color Bound Slider (right slider): Slide to control the upper
         bound of color limits
         </li>
         <li class="itemize">Upper Color Bound EditText (right editbox): Edit to control the
         upper bound of color limits
         </li>
         <li class="itemize">Lower Color Bound Slider (left slider): Slide to control the lower
         bound of color limits
         </li>
         <li class="itemize">Lower Color Bound EditText (left editbox): Edit to control the lower
         bound of color limits</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-136014x6">Matrix Dimension Control Group <br 
class="newline" />
     <!--l. 3485--><p class="noindent" >MatrixUser measures the dimension size of the display matrix and assigns one
     slider and editbox for each dimension that is above 2 (i.e. no slider and editbox
     for the first and second dimension). These control items are located in
     individual dimension tab and can be used to switch among slices in current
     active dimension.
     </li></ol>
   <h4 class="subsectionHead"><span class="titlemark">6.2.3   </span> <a 
 id="x3-1370006.2.3"></a>Function Library</h4>
<!--l. 3491--><p class="noindent" >

     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-137002x1">Display <br 
class="newline" />
     <!--l. 3495--><p class="noindent" >Matrix display functions are listed under this tab.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/Release.png" alt="pict"  
>  : Reset matrix display and erase additional display effect
         </li>
         <li class="itemize">   <img 
src="Pictures/Grid.png" alt="pict"  
>  : Turn on and off black grid line on the image display axes
         </li>
         <li class="itemize">   <img 
src="Pictures/Magnifier.png" alt="pict"  
>  : Open an instant magnifier which zooms in specific image
         area
         </li>
         <li class="itemize">   <img 
src="Pictures/LineProfile.png" alt="pict"  
>  : Plot and update a profile curve along a resizable checking
         line (Figure <a 
href="#x3-1370037">6.7<!--tex4ht:ref: fig:BrainProfile --></a>)
         <!--l. 3503--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-1370037"></a>   <img 
src="Pictures/BrainProfile.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.7: </span><span  
class="content">An Example of 1D Profile. The user can relocate and resize the
profile checking line on the image for inspecting live 1D profile. The buttons on
the profile window can list profile data, save the data as &#8216;data_plt&#8217; array into
workspace or copy the data into clipboard.</span></div><!--tex4ht:label?: x3-1370037 -->
         <!--l. 3509--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/DimProfile.png" alt="pict"  
>  : Plot and update a profile curve along a matrix dimension (Figure
         <a 
href="#x3-1370048">6.8<!--tex4ht:ref: fig:DimProfileWindow --></a>)
         <!--l. 3514--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-1370048"></a>   <img 
src="Pictures/DimProfileWindow.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.8: </span><span  
class="content">An Example of Plotting the First (Column) and Second (Row)
Matrix Dimension Profile. The user needs to specify which matrix dimension to
plot. The profile curve will update according to current mouse cursor position.
The user can pause or resume live updating by right click on main display
window.</span></div><!--tex4ht:label?: x3-1370048 -->
         <!--l. 3519--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/3DSlicer.png" alt="pict"  
>  : Open a separate window with two matrix display axes (Figure
         <a 
href="#x3-1370059">6.9<!--tex4ht:ref: fig:3DSlice --></a>) displaying another two orthogonal images. The operation buttons on
         the second window consists of
             <ul class="itemize2">
             <li class="itemize">   <img 
src="Pictures/RedBar.png" alt="pict"  
>  : Activate or deactivate localizer line on main display
             </li>
             <li class="itemize">   <img 
src="Pictures/YellowBar.png" alt="pict"  
>  : Activate or deactivate localizer line on main display

             </li>
             <li class="itemize">    <img 
src="Pictures/Switch.png" alt="pict"  
>   :  Switch  matrices  between  main  display  and  second
             display. This operation simply permutes current matrix into its
             orthogonal version. The user can save the transformed matrix
             using (    <img 
src="Pictures/Upload.png" alt="pict"  
> ).</li></ul>
         <!--l. 3529--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-1370059"></a>   <img 
src="Pictures/3DSlice.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.9: </span><span  
class="content">3D Slicer. To change view slice, the user needs to activate localizer
line and then click on desired coordinate on the main display window.</span></div><!--tex4ht:label?: x3-1370059 -->
         <!--l. 3534--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/RGBImage.png" alt="pict"  
>  : Create a RGB image, assign current slice and following two slices
         to Red, Green and Blue channel, respectively
         </li>
         <li class="itemize">   <img 
src="Pictures/Montage.png" alt="pict"  
>  : Create a montage image using multiple slices (Figure
         <a 
href="#x3-13700610">6.10<!--tex4ht:ref: fig:MontageImage --></a>)
         <!--l. 3539--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13700610"></a>   <img 
src="Pictures/MontageImage.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.10: </span><span  
class="content">Montage Image. An example of creating a 4-by-5 montage image
using multiple matrix slices starting from the first slice.</span></div><!--tex4ht:label?: x3-13700610 -->
         <!--l. 3544--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/Fuse.png" alt="pict"  
>  : Overlap two matrices with the same matrix size (Figure <a 
href="#x3-13700711">6.11<!--tex4ht:ref: fig:ImageFuse --></a>),
         notice that the user can press     <img 
src="Pictures/Release.png" alt="pict"  
>  to remove foreground matrix from
         overlapping with background matrix.
         <!--l. 3548--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13700711"></a>   <img 
src="Pictures/ImageFuse.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.11: </span><span  
class="content">An Example of Overlapping Two Matrices. A second window is
provided for adjusting overlapping effect. The user can choose to overlap any size
compatible matrices from the matrix list. There exist control items to change
foreground colormap scheme, to modify image intensity fraction, or to change
foreground color limits.</span></div><!--tex4ht:label?: x3-13700711 -->
         <!--l. 3553--><p class="noindent" ></div><hr class="endfigure">
         </li></ul>
     </li>
     <li 
  class="enumerate" id="x3-137009x2">QuickMath <br 
class="newline" />
     <!--l. 3559--><p class="noindent" >This function category performs quick math calculation for current matrix. A
     few commonly used math calculation are provided under this tab. Instead,
     complex calculation can be performed using matrix calculator as mentioned
     above.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/Abs.png" alt="pict"  
>  : Calculate absolute value

         </li>
         <li class="itemize">   <img 
src="Pictures/Negnate.png" alt="pict"  
>  : Calculate negative value
         </li>
         <li class="itemize">   <img 
src="Pictures/Ln.png" alt="pict"  
>  : Calculate natural logarithm
         </li>
         <li class="itemize">   <img 
src="Pictures/Log.png" alt="pict"  
>  : Calculate base 10 logarithm
         </li>
         <li class="itemize">   <img 
src="Pictures/Exp.png" alt="pict"  
>  : Calculate exponential
         </li>
         <li class="itemize">   <img 
src="Pictures/10n.png" alt="pict"  
>  : Calculate the power of 10
         </li>
         <li class="itemize">   <img 
src="Pictures/Sin.png" alt="pict"  
>  : Calculate sine
         </li>
         <li class="itemize">   <img 
src="Pictures/Cos.png" alt="pict"  
>  : Calculate cosine
         </li>
         <li class="itemize">   <img 
src="Pictures/Tan.png" alt="pict"  
>  : Calculate tangent
         </li>
         <li class="itemize">   <img 
src="Pictures/ASin.png" alt="pict"  
>  : Calculate inverse sine
         </li>
         <li class="itemize">   <img 
src="Pictures/ACos.png" alt="pict"  
>  : Calculate inverse cosine
         </li>
         <li class="itemize">   <img 
src="Pictures/ATan.png" alt="pict"  
>  : Calculate inverse tangent
         </li></ul>
     </li>
     <li 
  class="enumerate" id="x3-137011x3">Transform <br 
class="newline" />
     <!--l. 3579--><p class="noindent" >This function category performs spatial transformation or fast Fourier
     transform (FFT) to current matrix.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/FlipLR.png" alt="pict"  
>  : Flip matrix horizontally (along the first dimension)
         </li>
         <li class="itemize">   <img 
src="Pictures/FlipUD.png" alt="pict"  
>  : Flip matrix vertically (along the second dimension)
         </li>
         <li class="itemize">   <img 
src="Pictures/FlipZ.png" alt="pict"  
>  : Flip matrix along slice direction (the third dimension)
         </li>
         <li class="itemize">   <img 
src="Pictures/Rot90L.png" alt="pict"  
>  : Rotate matrix 90 degree in the counter clockwise direction
         </li>
         <li class="itemize">   <img 
src="Pictures/Rot90R.png" alt="pict"  
>  : Rotate matrix 90 degree in the clockwise direction

         </li>
         <li class="itemize">   <img 
src="Pictures/Rotate.png" alt="pict"  
>  : Rotate matrix certain degree along an axis specified using
         the rotation axis origin and direction in the 3D space
         </li>
         <li class="itemize">   <img 
src="Pictures/Translate.png" alt="pict"  
>  : Translate matrix along certain direction
         </li>
         <li class="itemize">   <img 
src="Pictures/FFT.png" alt="pict"  
>  : Perform multi-dimensional FFT for current matrix, the user
         needs to specify up to which dimension to perform FFT.</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-137013x4">Process <br 
class="newline" />
     <!--l. 3594--><p class="noindent" >This function category performs basic matrix processing functions.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/Mask.png" alt="pict"  
>  : Create binary mask based on given threshold
         </li>
         <li class="itemize">   <img 
src="Pictures/Smooth.png" alt="pict"  
>  : Perform smoothing operation to current matrix
         </li>
         <li class="itemize">   <img 
src="Pictures/Sharpen.png" alt="pict"  
>  : Perform sharpening operation to current matrix
         </li>
         <li class="itemize">   <img 
src="Pictures/Edge.png" alt="pict"  
>  : Perform edge detection to current matrix
         </li>
         <li class="itemize">   <img 
src="Pictures/Filter.png" alt="pict"  
>  : Provides various image filters (Figure <a 
href="#x3-13701412">6.12<!--tex4ht:ref: fig:FilterResult --></a>)
         <!--l. 3603--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13701412"></a>   <img 
src="Pictures/FilterResult.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.12: </span><span  
class="content">Image Filters. An example is shown for applying various image
filters.</span></div><!--tex4ht:label?: x3-13701412 -->
         <!--l. 3608--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/Noise.png" alt="pict"  
>  : Add noise to matrix (Figure <a 
href="#x3-13701513">6.13<!--tex4ht:ref: fig:NoiseResult --></a>)
         <!--l. 3613--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13701513"></a>   <img 
src="Pictures/NoiseResult.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.13: </span><span  
class="content">Image Noise. An example is shown for applying various image
noise.</span></div><!--tex4ht:label?: x3-13701513 -->
         <!--l. 3618--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/FillOut.png" alt="pict"  
>  : Replace voxel value for the voxels within certain value range and
         outside a polygon area. The user needs to draw a polygon first (double
         click to confirm the polygon).
         </li>
         <li class="itemize">   <img 
src="Pictures/FillIn.png" alt="pict"  
>  : Replace voxel value for the voxels within certain value range and
         inside a polygon area. The user needs to draw a polygon first (double click
         to confirm the polygon).

         </li>
         <li class="itemize">   <img 
src="Pictures/Fill.png" alt="pict"  
>  : Replace voxel value for the voxels inside a polygon area. The
         user needs to draw a polygon first (double click to confirm the
         polygon).
         </li>
         <li class="itemize">   <img 
src="Pictures/Replace.png" alt="pict"  
>  : Replace matrix area with a selected matrix source region. The
         user needs to draw a free-hand area (source region), drag the free-hand
         region to target matrix area, then double click to confirm the
         operation.
         </li>
         <li class="itemize">   <img 
src="Pictures/Crop.png" alt="pict"  
>  : Crop current matrix using a rectangle box (double click to
         confirm the cropping)
         </li>
         <li class="itemize">   <img 
src="Pictures/Extract.png" alt="pict"  
>  : Extract parts of current matrix using irregular shape (double
         click to confirm the extracting)
         </li>
         <li class="itemize">   <img 
src="Pictures/Resolution.png" alt="pict"  
>  : Resample current matrix by using chosen interpolation method
         (Figure <a 
href="#x3-13701614">6.14<!--tex4ht:ref: fig:ChangeResolution --></a>). The user can specify sampling factors in x, y and z direction
         for 3D matrix.
         <!--l. 3629--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13701614"></a>   <img 
src="Pictures/ChangeResolution.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.14: </span><span  
class="content">Interpolation Window. An example is shown to double spatial
resolution in x and y direction by using a linear interpolation.</span></div><!--tex4ht:label?: x3-13701614 -->
         <!--l. 3634--><p class="noindent" ></div><hr class="endfigure">
         </li></ul>
     </li>
     <li 
  class="enumerate" id="x3-137018x5">ROI <br 
class="newline" />
     <!--l. 3641--><p class="noindent" >MatrixUser provides a set of function buttons for performing Region-of-Interest
     (ROI) analysis (Figure <a 
href="#x3-13701915">6.15<!--tex4ht:ref: fig:ROIs --></a>). To create a ROI, the user needs to click ROI
     button first, then draw a ROI on the image axes. The statistical measures
     (i.e. mean, standard deviation and relative standard deviation) for
     voxels in delineated ROI is calculated and updated with moving ROI
     position or changing ROI shape. The ROI function buttons consists
     of
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/FreeROI.png" alt="pict"  
>  : Draw a free hand ROI
         </li>
         <li class="itemize">   <img 
src="Pictures/RectangleROI.png" alt="pict"  
>  : Draw a rectangle or square ROI
         </li>
         <li class="itemize">   <img 
src="Pictures/CircleROI.png" alt="pict"  
>  : Draw a circle or ellipse ROI

         </li>
         <li class="itemize">   <img 
src="Pictures/PolygonROI.png" alt="pict"  
>  : Draw a polygon ROI
         </li>
         <li class="itemize">   <img 
src="Pictures/LineROI.png" alt="pict"  
>  : Draw a straight line for measuring distance in units of pixels
         </li>
         <li class="itemize">   <img 
src="Pictures/AngleROI.png" alt="pict"  
>  : Draw a polygon for measuring the interior angles in degrees
         </li>
         <li class="itemize">   <img 
src="Pictures/ROIManager.png" alt="pict"  
>  : Record existing ROI shape and location into a ROI list,
         allow to redraw selected ROI in multiple image axes. To redraw a
         existing ROI, the user needs to select a ROI in the list, then press
         &#8216;Show&#8217; button. Note that the copied ROI is no longer resizable and
         movable.
         </li>
         <li class="itemize">   <img 
src="Pictures/Histogram.png" alt="pict"  
>  : Plot histogram for current slice (Figure <a 
href="#x3-13702016">6.16<!--tex4ht:ref: fig:Hist --></a>); if ROIs exist,
         plot histogram for latest activated ROI</li></ul>
     <!--l. 3654--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13701915"></a>   <img 
src="Pictures/ROIs.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.15: </span><span  
class="content">Draw Multiple ROIs and Redraw on A Second Image. The source
ROIs are in green, copied ROIs are in red.</span></div><!--tex4ht:label?: x3-13701915 -->
     <!--l. 3659--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 3662--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13702016"></a>   <img 
src="Pictures/Hist.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.16: </span><span  
class="content">Histogram for One Image Slice</span></div><!--tex4ht:label?: x3-13702016 -->
     <!--l. 3667--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-137022x6">Segment <br 
class="newline" />
     <!--l. 3671--><p class="noindent" >MatrixUser supports functions for performing multi-slice manual segmentation.
     To create a segmentation, click segmentation button, then draw a region on the
     image axes. The user can modify the region location and shape prior to
     confirming segmentation with double click. The segmentation buttons consists
     of
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/FreeSeg.png" alt="pict"  
>  : Do a free-hand segmentation
         </li>
         <li class="itemize">   <img 
src="Pictures/CircleSeg.png" alt="pict"  
>  : Do a circle or ellipse segmentation
         </li>
         <li class="itemize">   <img 
src="Pictures/PolygonSeg.png" alt="pict"  
>  : Do a polygon segmentation
         </li>
         <li class="itemize">   <img 
src="Pictures/EditSeg.png" alt="pict"  
>  : Edit segmentation

         </li>
         <li class="itemize">   <img 
src="Pictures/SaveSeg.png" alt="pict"  
>  : Save segmentation into a MAT file
         </li>
         <li class="itemize">   <img 
src="Pictures/LoadSeg.png" alt="pict"  
>  : Load segmentation from a MAT file</li></ul>
     <!--l. 3683--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13702317"></a>   <img 
src="Pictures/Segs.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.17: </span><span  
class="content">Editing Segmentation</span></div><!--tex4ht:label?: x3-13702317 -->
     <!--l. 3688--><p class="noindent" ></div><hr class="endfigure">
     <!--l. 3690--><p class="noindent" >To edit segmented region (Figure <a 
href="#x3-13702317">6.17<!--tex4ht:ref: fig:Segs --></a>), press     <img 
src="Pictures/EditSeg.png" alt="pict"  
>  to open a segmentation
     manager. The manager records the type and location for existing segmented
     regions. The user can click any region item to inspect the location of the region.
     To edit chosen region, click &#8216;Edit&#8217; button to activate the region outline. Both
     the shape and mask flag are editable for segmented region. After editing, click
     &#8216;Update&#8217; to conform modification. The user can press     <img 
src="Pictures/SaveSeg.png" alt="pict"  
>  to save current
     segmentation into a MAT file which contains a mask matrix and a cell array
     storing segmentation location information. The user can also press     <img 
src="Pictures/Upload.png" alt="pict"  
>  to
     save the mask matrix into workspace. Pressing     <img 
src="Pictures/LoadSeg.png" alt="pict"  
>  can load previous
     segmented regions from a saved MAT file. Notice that the user can
     press     <img 
src="Pictures/Release.png" alt="pict"  
>  to remove segmentation from overlapping with background
     matrix.
     </li>
     <li 
  class="enumerate" id="x3-137025x7">Surface <br 
class="newline" />
     <!--l. 3694--><p class="noindent" >This function category generates surface or mesh plot for current image.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/Contour.png" alt="pict"  
>  : Create contour plot of current matrix
         </li>
         <li class="itemize">   <img 
src="Pictures/Contour3.png" alt="pict"  
>  : Create 3D contour plot of current matrix
         </li>
         <li class="itemize">   <img 
src="Pictures/ContourFill.png" alt="pict"  
>  : Create filled 2D contour plot
         </li>
         <li class="itemize">   <img 
src="Pictures/Surface.png" alt="pict"  
>  : Create 3D shaded surface plot
         </li>
         <li class="itemize">   <img 
src="Pictures/SurfaceCon.png" alt="pict"  
>  : Create surface plot and contour
         </li>
         <li class="itemize">   <img 
src="Pictures/SurfaceCol.png" alt="pict"  
>  : Create surface plot with colormap based lighting
         </li>
         <li class="itemize">   <img 
src="Pictures/Mesh.png" alt="pict"  
>  : Create mesh plot
         </li>
         <li class="itemize">   <img 
src="Pictures/MeshCon.png" alt="pict"  
>  : Create mesh plot and contour

         </li>
         <li class="itemize">   <img 
src="Pictures/MeshC.png" alt="pict"  
>  : Create a curtain around a mesh plot
         </li>
         <li class="itemize">   <img 
src="Pictures/Reb.png" alt="pict"  
>  : Create a ribbon plot
         </li>
         <li class="itemize">   <img 
src="Pictures/Waterfall.png" alt="pict"  
>  : Create a waterfall plot
         </li>
         <li class="itemize">   <img 
src="Pictures/Pcolor.png" alt="pict"  
>  : Create pcolor (checkerboard) plot</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-137027x8">Matlab <br 
class="newline" />
     <!--l. 3714--><p class="noindent" >Matlab default image tools (Figure <a 
href="#x3-13702818">6.18<!--tex4ht:ref: fig:matlabIM --></a>) are tailored for MatrixUser and
     included in this category.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/imtool.png" alt="pict"  
>  : Perform imtool for current image
         </li>
         <li class="itemize">   <img 
src="Pictures/immovie.png" alt="pict"  
>  : Perform immovie for playback current 3D matrix
         </li>
         <li class="itemize">   <img 
src="Pictures/imcontrast.png" alt="pict"  
>  : Perform imcontrast for adjusting image contrast</li></ul>
     <!--l. 3722--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13702818"></a>   <img 
src="Pictures/matlabIM.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.18: </span><span  
class="content">Matlab Tools</span></div><!--tex4ht:label?: x3-13702818 -->
     <!--l. 3727--><p class="noindent" ></div><hr class="endfigure">
     </li>
     <li 
  class="enumerate" id="x3-137030x9">More <br 
class="newline" />
     <!--l. 3731--><p class="noindent" >Uncategorized functions are categorized under this tab.
         <ul class="itemize1">
         <li class="itemize">   <img 
src="Pictures/3DRender.png" alt="pict"  
>  : Create a 3D graph for rendering current matrix (Figure
         <a 
href="#x3-13703119">6.19<!--tex4ht:ref: fig:BrainRender --></a>)
         <!--l. 3736--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13703119"></a>   <img 
src="Pictures/BrainRender.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.19: </span><span  
class="content">An Example of 3D Human Brain Rendering. Control units on the
rendering window are provided for fine tuning the renderer. The user can select
isosurface threshold, cutoff connectivity threshold (i.e. object with total voxels
less than the threshold will be removed from the rendering. &#8216;@&#8217; is followed by the
voxel number of current largest object) and object opacity. A set of pushbuttons
are also available for changing surface color, display box and patches. The default
Matlab camera toolbar are provided for adjusting the lighting effect.</span></div><!--tex4ht:label?: x3-13703119 -->
         <!--l. 3741--><p class="noindent" ></div><hr class="endfigure">

         </li>
         <li class="itemize">   <img 
src="Pictures/MIP.png" alt="pict"  
>  : Perform projection along a given matrix dimension. Support
         multi-dimensional matrix projection
         </li>
         <li class="itemize">   <img 
src="Pictures/MIP3D.png" alt="pict"  
>  : Perform 3D projection along x, y or z axis with certain angle
         increment (Figure <a 
href="#x3-13703220">6.20<!--tex4ht:ref: fig:3DMIP --></a>)
         <!--l. 3747--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13703220"></a>   <img 
src="Pictures/3DMIP.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.20: </span><span  
class="content">3D Maximum Intensity Projection (MIP). An example of 3D MIP
around axial axis of a human knee MRI image stack shows the vascular system
of the knee joint.</span></div><!--tex4ht:label?: x3-13703220 -->
         <!--l. 3752--><p class="noindent" ></div><hr class="endfigure">
         </li>
         <li class="itemize">   <img 
src="Pictures/3DReslice.png" alt="pict"  
>  : Reslice 3D matrix at given direction. The user needs to draw a
         line for indicating the slicing direction with double click for confirmation
         (Figure <a 
href="#x3-13703321">6.21<!--tex4ht:ref: fig:Reslice --></a>)
         </li>
         <li class="itemize">   <img 
src="Pictures/Moive.png" alt="pict"  
>  : Create a movie using current matrix display. Support making
         movie for overlapped matrices.</li></ul>
     <!--l. 3758--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x3-13703321"></a>   <img 
src="Pictures/Reslice.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.21: </span><span  
class="content">Reslice 3D Matrix. An example of 3D reslicing generates a new
stack of images in the oblique plane from an axial human knee MRI image stack.
Note that the resliced images are extracted from the plane perpendicular to the
indicating line on the left window.</span></div><!--tex4ht:label?: x3-13703321 -->
     <!--l. 3763--><p class="noindent" ></div><hr class="endfigure">
     </li></ol>
<!--l. 3769--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x3-1380006.3"></a>arrayShow</h3>
<!--l. 3771--><p class="noindent" >The arrayShow tool is a Matlab image viewer which has been designed for the evaluation
of multidimensional complex images. arrayShow is originally designed by Tilman Johannes
Sumpf at Biomedizinische NMR Forschungs GmbH. The user can press &#8216;arrayShow&#8217;
button to activate this viewer. Detailed information about arrayShow can be found at
<a 
href="http://www.biomednmr.mpg.de/index.php?option=com_content&task=view&id=137&Itemid=43" class="url" ><span 
class="cmtt-10">http://www.biomednmr.mpg.de/index.php?option=com_content&amp;task=view&amp;id=137&amp;Itemid=43</span></a>;
<!--l. 3773--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
 id="x3-1390006.4"></a>SpinWatcher</h3>
<!--l. 3775--><p class="noindent" >The SpinWatcher is designed for monitoring spin evolution behavior within a single
voxel at given MR sequence and field environment. This function can be activated by
pressing &#8216;SpinWatcher&#8217; toolbar icon located at the top of the main simulation
console.

<!--l. 3777--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-13900122"></a>


<!--l. 3779--><p class="noindent" ><img 
src="Pictures/SpinWatcherPanelIcon.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.22: </span><span  
class="content">SpinWatcher Toolbar Icon</span></div><!--tex4ht:label?: x3-13900122 -->

<!--l. 3782--><p class="indent" >   </div><hr class="endfigure">
<!--l. 3785--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-13900223"></a>


<!--l. 3787--><p class="noindent" ><img 
src="Pictures/SpinWatcher.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.23: </span><span  
class="content">SpinWatcher Main Interface</span></div><!--tex4ht:label?: x3-13900223 -->

<!--l. 3790--><p class="indent" >   </div><hr class="endfigure">
<!--l. 3792--><p class="indent" >   Figure <a 
href="#x3-13900223">6.23<!--tex4ht:ref: fig:SpinWatcher --></a> demonstrates an overview of the SpinWatcher main interface. This
interface consists of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-139004x1">Voxel Locator <br 
class="newline" />The default voxel is chosen as the one at the isocenter indicated by a red
     isocenter marker. However, the user can select any voxel within the virtual
     object by using      <img 
src="Pictures/Cursor.png" alt="pict"  
> . The slider beside the image can help change
     image slices.
     </li>
     <li 
  class="enumerate" id="x3-139006x2">Spin Property and Environment <br 
class="newline" />
     <!--l. 3800--><p class="noindent" >The spin properties will be automatically updated with a selected voxel.
     The user can modify the spin properties and environment to meet their
     own needs. The editable properties provided in this interface include:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x3-139008x1">Spin <br 
class="newline" />
             <ul class="itemize1">
             <li class="itemize">ChemShift (Hz/T): The chemical shift of the spin
             </li>
             <li class="itemize">Gyro (rad/s/T): The gyromagnetic ratio of the spin
             </li>
             <li class="itemize">Rho : The density of the spin
             </li>
             <li class="itemize">T1 (s): The longitudinal relaxation time
             </li>
             <li class="itemize">T2 (s): The transverse relaxation time
             </li>
             <li class="itemize">T2Star (s): The T2* relaxation time
             </li>
             <li class="itemize">SpinPerVoxel : The number of spins in each voxel, default one
             spin per voxel will treat T2* equal to T2, use a number above
             one for simulating T2* effect
             </li>
             <li class="itemize">TypeNum : The number of spin species
             </li>
             <li class="itemize">LocZ : The Z location of the selected voxel
             </li>
             <li class="itemize">LocY : The Y location of the selected voxel
             </li>
             <li class="itemize">LocX : The X location of the selected voxel</li></ul>

         </li>
         <li 
  class="enumerate" id="x3-139010x2">Display <br 
class="newline" />
             <ul class="itemize1">
             <li class="itemize">WindowSize : The window width of the spin evolution plot
             </li>
             <li class="itemize">ISOHighlight : The flag for turning on and off isocenter mark
             </li>
             <li class="itemize">Grid : The flag for turning on and off grid line
             </li>
             <li class="itemize">Axes : The flag for turning on and off axes label</li></ul>
         </li></ol>
     <!--l. 3828--><p class="noindent" >The SpinWatcher supports monitoring multiple spin species. The user needs to
     provide an array of multiple values for T1, T2, T2*, Rho and ChemShift, and
     give the correct number of spin species. The values must be separated with
     space. For example
         <ul class="itemize1">
         <li class="itemize">ChemShift = 0 -210
         </li>
         <li class="itemize">Rho = 1.0 0.5
         </li>
         <li class="itemize">T1 = 1.2 1.0
         </li>
         <li class="itemize">T2 = 0.02 0.03
         </li>
         <li class="itemize">T2Star = 0.002 0.003
         </li>
         <li class="itemize">TypeNum = 2</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-139012x3">Spin Watcher Window <br 
class="newline" />A 3D spin evolution animation is displayed in the spin watcher window.
     The 3D animation is controllable using a set of control buttons and
     sliders
         <ul class="itemize1">
         <li class="itemize">Scroll  Bar  :  Drag  the  scroll  bar  to  any  intermediate  time  point
         between beginning and end
         </li>
         <li class="itemize"><span 
class="cmsy-10">| </span><span 
class="cmmi-10">&#x003C; </span>: Move to the beginning

         </li>
         <li class="itemize">X : Pause animation, notice that the interface can only be closed
         while animation is paused
         </li>
         <li class="itemize">O : Resume animation
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E; </span>: Play at normal speed
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E;&#x003E; </span>: Play at double normal speed
         </li>
         <li class="itemize"><span 
class="cmmi-10">&#x003E; </span><span 
class="cmsy-10">| </span>: Move to the end</li></ul>
     </li>
     <li 
  class="enumerate" id="x3-139014x4">Spin Evolution Plot <br 
class="newline" />
     <!--l. 3855--><p class="noindent" >SpinWatcher provides two plots for capturing the spin evolution (i.e. <span 
class="cmsy-10">|</span>Mxy<span 
class="cmsy-10">| </span>and
     Mz) regarding time. Press &#8216;Execute&#8217; button to recalculate the spin evolution
     plot if changes to spin property and environment was made. The settings can
     be saved into a file by pressing &#8216;Update&#8217;. To export temporary variables of spin
     evolution into Matlab base workspace, press &#8216;Export&#8217;, the exported variables
     include :
         <ul class="itemize1">
         <li class="itemize">Muts : A array for time points
         </li>
         <li class="itemize">MxySum : A array for <span 
class="cmsy-10">|</span>Mxy<span 
class="cmsy-10">|</span>
         </li>
         <li class="itemize">MzSum : A array for Mz
         </li>
         <li class="itemize">Mx : <span 
class="cmmi-10">x </span>component of magnetization
         </li>
         <li class="itemize">My : <span 
class="cmmi-10">y </span>component of magnetization
         </li>
         <li class="itemize">Mz : <span 
class="cmmi-10">z </span>component of magnetization</li></ul>
     <!--l. 3866--><p class="noindent" >The user can also undock the spin evolution plot by pressing &#8216;<span 
class="cmsy-10">&#x2227;</span>&#8217; button.</li></ol>
   <h3 class="sectionHead"><span class="titlemark">6.5   </span> <a 
 id="x3-1400006.5"></a>SARWatcher</h3>
<!--l. 3870--><p class="noindent" >(:TODO) SARWatcher is a graphical toolbox for monitoring real time spatial Specific
Absorption Rate (SAR) of the virtual object under given experimental design. This
toolbox is still under developing.

<!--l. 3872--><p class="indent" >

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;7</span><br /><a 
 id="x3-1410007"></a>MRiLab Applications</h2>
<!--l. 3874--><p class="noindent" >This chapter shows a few examples for demonstrating the applications of MRiLab
simulation
   <h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
 id="x3-1420007.1"></a>bSSFP with Non-uniform B0</h3>
<!--l. 3878--><p class="noindent" >This example (Figure <a 
href="#x3-1420071">7.1<!--tex4ht:ref: fig:bSSFP --></a>) simulates the dark banding artifact in bSSFP images
arisen from non-uniform B0 field. To perform this simulation, the following steps are
needed:
<!--l. 3880--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-142002x1">Load Brain (Standard Resolution 108 <span 
class="cmsy-10">&#x00D7; </span>90 <span 
class="cmsy-10">&#x00D7; </span>90)
     </li>
     <li 
  class="enumerate" id="x3-142004x2">Load PSD_FIESTA3D
     </li>
     <li 
  class="enumerate" id="x3-142006x3">Load Mag_GaussianHead</li></ol>
<!--l. 3886--><p class="indent" >   The user can adjust the &#8216;FlipAng&#8217;, &#8216;TR&#8217; and &#8216;TE&#8217; to modify the pattern of the
banding artifact.
<!--l. 3888--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1420071"></a>


<!--l. 3890--><p class="noindent" ><img 
src="Pictures/bSSFP.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.1: </span><span  
class="content">Simulated 3D bSSFP brain image of matrix size of 100 <span 
class="cmsy-10">&#x00D7; </span>80 <span 
class="cmsy-10">&#x00D7; </span>20.
The circular banding artifact is due to added Gaussian field simulating the
main  magnet  field  inhomogeneity.  Left:  TR/TE=16/8ms,  FA=40<sup><span 
class="cmsy-7">&#x2218;</span></sup>;  Middle:
TR/TE=16/8ms,  FA=40<sup><span 
class="cmsy-7">&#x2218;</span></sup>,  Gaussian  B0  applied;  Right:  TR/TE=32/16ms,
FA=40<sup><span 
class="cmsy-7">&#x2218;</span></sup>, Gaussian B0 applied</span></div><!--tex4ht:label?: x3-1420071 -->

<!--l. 3893--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">7.2   </span> <a 
 id="x3-1430007.2"></a>Fat Chemical Shift</h3>
<!--l. 3898--><p class="noindent" >This example (Figure <a 
href="#x3-1430052">7.2<!--tex4ht:ref: fig:FatWater --></a>) simulates chemical shift artifact at the interface of water
and fat in a GRE sequence. To perform this simulation, the following steps are
needed:
<!--l. 3900--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-143002x1">Load Water Fat Phantom (256 <span 
class="cmsy-10">&#x00D7; </span>256 <span 
class="cmsy-10">&#x00D7; </span>32 <span 
class="cmsy-10">&#x00D7; </span>2)
     </li>
     <li 
  class="enumerate" id="x3-143004x2">Load PSD_GRE3D</li></ol>
<!--l. 3905--><p class="indent" >   The user can adjust the &#8216;BandWidth&#8217; and &#8216;FreqDir&#8217; to modify the appearance of
the chemical shift.
<!--l. 3907--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1430052"></a>


<!--l. 3909--><p class="noindent" ><img 
src="Pictures/FatWater.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.2:  </span><span  
class="content">Simulated  3D  gradient  echo  image  at  3.0T  using  cartilage-fat
phantom showing water fat chemical shift at different readout bandwidth. The
simulated in-plane matrix size is 100 <span 
class="cmsy-10">&#x00D7; </span>100, TR/TE = 10s/50ms, Axial plane,
A/P readout. Left: BW=400Hz/pixel; Right: BW=100Hz/pixel.</span></div><!--tex4ht:label?: x3-1430052 -->

<!--l. 3912--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">7.3   </span> <a 
 id="x3-1440007.3"></a>Multi RF Transmitting</h3>
<!--l. 3916--><p class="noindent" >This example (Figure <a 
href="#x3-1440093">7.3<!--tex4ht:ref: fig:MultiTransmit --></a>) simulates multiple RF transmitting using a bSSFP
sequence. To perform this simulation, the following steps are needed:
<!--l. 3918--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-144002x1">Load Brain (Standard Resolution 108 <span 
class="cmsy-10">&#x00D7; </span>90 <span 
class="cmsy-10">&#x00D7; </span>90)
     </li>
     <li 
  class="enumerate" id="x3-144004x2">Load PSD_FIESTA3D
     </li>
     <li 
  class="enumerate" id="x3-144006x3">Load Coil_8ChHead to Tx
     </li>
     <li 
  class="enumerate" id="x3-144008x4">Set &#8216;MultiTransmit&#8217; to &#8216;on&#8217;</li></ol>
<!--l. 3925--><p class="indent" >   The user can adjust the &#8216;B1Level&#8217; to modify the actual flip angle, modify the RF
pulse using MR sequence Design Toolbox for individual RF source, or modify the coil
configuration for generating desired B1+ field.
<!--l. 3927--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1440093"></a>


<!--l. 3929--><p class="noindent" ><img 
src="Pictures/MultiTransmit.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.3: </span><span  
class="content">Simulated 3D bSSFP brain image of matrix size of 100 <span 
class="cmsy-10">&#x00D7; </span>80 <span 
class="cmsy-10">&#x00D7;</span>
4  with  different  Tx  coil  configuration.  The  simulated  image  uses  FA=40<sup><span 
class="cmsy-7">&#x2218;</span></sup>,
TR/TE  =  16/8ms.  Left:  uniform  unit  B1+  field,  RF  transmitting  from
&#8216;MasterTxCoil&#8217;; Middle: multi RF transmitting from Coil1 and Coil3; Right:
multi RF transmitting from all coil channels</span></div><!--tex4ht:label?: x3-1440093 -->

<!--l. 3932--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">7.4   </span> <a 
 id="x3-1450007.4"></a>Multi Receiving Coil</h3>
<!--l. 3936--><p class="noindent" >This example (Figure <a 
href="#x3-1450074">7.4<!--tex4ht:ref: fig:MultiReceive --></a>) simulates multiple receiving using a SE sequence. To
perform this simulation, the following steps are needed:
<!--l. 3938--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-145002x1">Load Brain (Standard Resolution 108 <span 
class="cmsy-10">&#x00D7; </span>90 <span 
class="cmsy-10">&#x00D7; </span>90)
     </li>
     <li 
  class="enumerate" id="x3-145004x2">Load PSD_SE3D
     </li>
     <li 
  class="enumerate" id="x3-145006x3">Load Coil_8ChHead to Rx</li></ol>
<!--l. 3944--><p class="indent" >   The user can adjust the coil configuration for generating desired B1-
field. All eight channels will be receiving MR signal from the virtual object
individually.
<!--l. 3946--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1450074"></a>


<!--l. 3948--><p class="noindent" ><img 
src="Pictures/MultiReceive.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.4: </span><span  
class="content">Simulated brain spin echo image of matrix size of 100 <span 
class="cmsy-10">&#x00D7; </span>80 with
multi receiving Rx coil. The simulated image uses FA=90<sup><span 
class="cmsy-7">&#x2218;</span></sup>, TR/TE = 10s/10ms.
Left: the combined image using &#8216;SumofMagn&#8217;; Right: individual image for each
coil channel, notice that Coil2 and Coil4 receive no signal due to zero B1- field.</span></div><!--tex4ht:label?: x3-1450074 -->

<!--l. 3951--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">7.5   </span> <a 
 id="x3-1460007.5"></a>Image Gradient</h3>
<!--l. 3956--><p class="noindent" >This example (Figure <a 
href="#x3-1460075">7.5<!--tex4ht:ref: fig:ImageGrad --></a>) simulates applying non-unit gradient with a 3D SPGR
sequence. To perform this simulation, the following steps are needed:
<!--l. 3958--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-146002x1">Load Brain (Standard Resolution 108 <span 
class="cmsy-10">&#x00D7; </span>90 <span 
class="cmsy-10">&#x00D7; </span>90)
     </li>
     <li 
  class="enumerate" id="x3-146004x2">Load PSD_SPGR3D
     </li>
     <li 
  class="enumerate" id="x3-146006x3">Load Grad_LinearHead</li></ol>
<!--l. 3964--><p class="indent" >   The user can adjust the gradient structure for generating desired gradient field.
Notice that this applied gradient in GyPE GradLine has a factor of 0.5 in the Y
direction. This will cause image contraction in the Y direction.
<!--l. 3966--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1460075"></a>


<!--l. 3968--><p class="noindent" ><img 
src="Pictures/ImageGrad.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.5: </span><span  
class="content">Simulated brain 3D SPGR image of matrix size of 100<span 
class="cmsy-10">&#x00D7;</span>80<span 
class="cmsy-10">&#x00D7;</span>2 with
non-unit gradient. The simulated image uses FA=20<sup><span 
class="cmsy-7">&#x2218;</span></sup>, TR/TE = 60/8ms. Left:
unit gradient applied; Right: non-unit gradient applied in Y direction.</span></div><!--tex4ht:label?: x3-1460075 -->

<!--l. 3971--><p class="indent" >   </div><hr class="endfigure">
   <h3 class="sectionHead"><span class="titlemark">7.6   </span> <a 
 id="x3-1470007.6"></a>Motion Artifact</h3>
<!--l. 3975--><p class="noindent" >This example (Figure <a 
href="#x3-1470076">7.6<!--tex4ht:ref: fig:MotionBrain --></a>) simulates motion artifact with a 3D GRE sequence. To
perform this simulation, the following steps are needed:
<!--l. 3977--><p class="indent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-147002x1">Load Brain (Standard Resolution 108 <span 
class="cmsy-10">&#x00D7; </span>90 <span 
class="cmsy-10">&#x00D7; </span>90)
     </li>
     <li 
  class="enumerate" id="x3-147004x2">Load PSD_GRE3D
     </li>
     <li 
  class="enumerate" id="x3-147006x3">Load Mot_ShiftHead</li></ol>
<!--l. 3983--><p class="indent" >   The user can adjust the motion structure to generate different motion track
patterns, and/or modify motion triggering in the Ext sequence line to sample object
movement.
<!--l. 3985--><p class="indent" >   <hr class="figure"><div class="figure" 
>

<a 
 id="x3-1470076"></a>


<!--l. 3987--><p class="noindent" ><img 
src="Pictures/MotionBrain.png" alt="pict"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.6:  </span><span  
class="content">Simulated  brain  GRE  image  of  matrix  size  of  100 <span 
class="cmsy-10">&#x00D7; </span>80  with
translation motion. The simulated image uses FA=90<sup><span 
class="cmsy-7">&#x2218;</span></sup>, TR/TE = 10s/50ms,
Axial plane, A/P readout. Motion triggering happens one time per TR, and
motion lasts for 400s. Left: no motion; Right: translation motion applied.</span></div><!--tex4ht:label?: x3-1470076 -->

<!--l. 3990--><p class="indent" >   </div><hr class="endfigure">

<!--l. 3992--><p class="indent" >

   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;8</span><br /><a 
 id="x3-1480008"></a>FAQs</h2> Waiting for questions...

<!--l. 3995--><p class="indent" >

   <h2 class="likechapterHead"><a 
 id="x3-1490008"></a>Bibliography</h2>
   <div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XYarnykh2007"></a><span 
class="cmcsc-10">V.L. Y<span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">n</span><span 
class="small-caps">y</span><span 
class="small-caps">k</span><span 
class="small-caps">h</span></span>:&#x00A0;<span 
class="cmti-10">Actual Flip-Angle Imaging in the Pulsed Steady State:</span>
   <span 
class="cmti-10">A  Method  for  Rapid  Three-Dimensional  Mapping  of  the  Transmitted</span>
   <span 
class="cmti-10">Radiofrequency Field </span>, Magn. Reson. Med., <span 
class="cmbx-10">57</span>, (2007), 192-200.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [2]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XJackson1991"></a><span 
class="cmcsc-10">J.I.           J<span 
class="small-caps">a</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">s</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span>,           C.H.           M<span 
class="small-caps">e</span><span 
class="small-caps">y</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span>,           D.G.</span>
   <span 
class="cmcsc-10">N<span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">h</span><span 
class="small-caps">i</span><span 
class="small-caps">m</span><span 
class="small-caps">u</span><span 
class="small-caps">r</span><span 
class="small-caps">a</span>, <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> A. M<span 
class="small-caps">a</span><span 
class="small-caps">c</span><span 
class="small-caps">o</span><span 
class="small-caps">v</span><span 
class="small-caps">s</span><span 
class="small-caps">k</span><span 
class="small-caps">i</span></span>:&#x00A0;<span 
class="cmti-10">Selection of a Convolution Function for</span>
   <span 
class="cmti-10">Fourier Inversion Using Gridding </span>, IEEE Trans. Med. Imag., vol. 10, no. 3,
   pp 473-478, 1991.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [3]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XVRasche1999"></a><span 
class="cmcsc-10">V.  R<span 
class="small-caps">a</span><span 
class="small-caps">s</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span>,  R.  P<span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">s</span><span 
class="small-caps">k</span><span 
class="small-caps">a</span>,  R.  S<span 
class="small-caps">i</span><span 
class="small-caps">n</span><span 
class="small-caps">k</span><span 
class="small-caps">u</span><span 
class="small-caps">s</span>,  P.  B<span 
class="small-caps">o</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">n</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span>,  <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>  H.</span>
   <span 
class="cmcsc-10">E<span 
class="small-caps">g</span><span 
class="small-caps">g</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">s</span></span>:&#x00A0;<span 
class="cmti-10">Resampling of Data Between Arbitrary Grids Using Convolution</span>
   <span 
class="cmti-10">Interpolation </span>, IEEE Trans. Med. Imag., vol. 18, no. 5, pp 385-392, 1999.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [4]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XBeatty2005"></a><span 
class="cmcsc-10">P.J. B<span 
class="small-caps">e</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span><span 
class="small-caps">y</span>, D.G. N<span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">h</span><span 
class="small-caps">i</span><span 
class="small-caps">m</span><span 
class="small-caps">u</span><span 
class="small-caps">r</span><span 
class="small-caps">a</span>, <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> J.M. P<span 
class="small-caps">a</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span><span 
class="small-caps">y</span></span>:&#x00A0;<span 
class="cmti-10">Rapid gridding</span>
   <span 
class="cmti-10">reconstruction with a minimal oversampling ratio </span>, IEEE Trans. Med. Imag.,
   vol. 24, no. 6, pp 799-808, 2005.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [5]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XGlover2005"></a><span 
class="cmcsc-10">G.H.  G<span 
class="small-caps">l</span><span 
class="small-caps">o</span><span 
class="small-caps">v</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span>:&#x00A0;<span 
class="cmti-10">Simple  Analytic  Spiral  K-Space  Algorithm  </span>,  Magn.
   Reson. Med., <span 
class="cmbx-10">42</span>, (2005), 412-415.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [6]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XHandbook2004"></a><span 
class="cmcsc-10">M.A. B<span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">n</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">e</span><span 
class="small-caps">i</span><span 
class="small-caps">n</span>, K.F. K<span 
class="small-caps">i</span><span 
class="small-caps">n</span><span 
class="small-caps">g</span>, X.J. Z<span 
class="small-caps">h</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span></span>:&#x00A0;<span 
class="cmti-10">Handbook of MRI Pulse</span>
   <span 
class="cmti-10">Sequences </span>, Elsevier Academic Press, 2004.
   </p>

   <p class="bibitem" ><span class="biblabel">
 [7]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XPauly1991"></a><span 
class="cmcsc-10">J.      P<span 
class="small-caps">a</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span><span 
class="small-caps">y</span>,      P.      L<span 
class="small-caps">e</span>      R<span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">x</span>,      D.G.      N<span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">h</span><span 
class="small-caps">i</span><span 
class="small-caps">m</span><span 
class="small-caps">u</span><span 
class="small-caps">r</span><span 
class="small-caps">a</span>,</span>
   <span 
class="cmcsc-10"><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> A. M<span 
class="small-caps">a</span><span 
class="small-caps">c</span><span 
class="small-caps">o</span><span 
class="small-caps">v</span><span 
class="small-caps">s</span><span 
class="small-caps">k</span><span 
class="small-caps">i</span></span>:&#x00A0;<span 
class="cmti-10">Parameter relations for the Shinnar-Le Roux selective</span>
   <span 
class="cmti-10">excitation pulse design algorithm </span>, IEEE Trans. Med. Imag., vol. 10, no. 1,
   pp 53-65, 1991.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [8]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XHwang1998"></a><span 
class="cmcsc-10">T. H<span 
class="small-caps">w</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">g</span>, P.C.M. <span 
class="small-caps">v</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> Z<span 
class="small-caps">i</span><span 
class="small-caps">j</span><span 
class="small-caps">l</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> M. G<span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">w</span><span 
class="small-caps">o</span><span 
class="small-caps">o</span><span 
class="small-caps">d</span></span>:&#x00A0;<span 
class="cmti-10">Fast Broadband</span>
   <span 
class="cmti-10">Inversion by Adiabatic Pulses </span>, J. Magn. Reson., 133, pp 200-203, 1998.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [9]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XYarnykh2002"></a><span 
class="cmcsc-10">V.L.  Y<span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">n</span><span 
class="small-caps">y</span><span 
class="small-caps">k</span><span 
class="small-caps">h</span></span>:&#x00A0;<span 
class="cmti-10">Pulsed  Z-Spectroscopic  Imaging  of  Cross-Relaxation</span>
   <span 
class="cmti-10">Parameters in Tissues for Human MRI: Theory and Clinical Applications </span>,
   Magn. Reson. Med., <span 
class="cmbx-10">47</span>, (2002), 929-939.
</p>
   </div>


<!--l. 4038--><p class="indent" >

   <h2 class="chapterHead"><a 
 id="x3-1500008"></a>Acknowledgment</h2>
<!--l. 4040--><p class="noindent" >I am indebted to all my teachers and mentors. I would like to thank Dr. Neil
Gelman at The Western University (Canada) for introducing me into the MRI
field and inspiring me for developing the MatrixUser project. I would also
like to thank Drs. Wally Block and Richard Kijowski at The University
of Wisconsin-Madison (USA) who guide me to acquire knowledge of MR
sequence design and medical image application. My gratitude is owed to
Dr. Alexey Samsonov at The University of Wisconsin-Madison (USA) for
inspiring me developing MT relevant functions. Many people also contribute
significantly to the MRiLab project through publishing free code online which
largely extends MRiLab functionality, in particular, Dr. Tilman Johannes
Sumpf at Biomedizinische NMR Forschungs GmbH (Germany), Dr. John
Pauly and Dr. Brian Hargreaves at Stanford University (USA). Finally, my
appreciation goes to my wife Zhaoye Zhou who supports me for finishing the whole
project.

<!--l. 4042--><p class="indent" >

   <h2 class="chapterHead"><a 
 id="x3-1510008"></a>Afterword</h2>
<!--l. 4044--><p class="noindent" >While MRiLab has been carefully designed and tuned for performing high quality
MRI simulation, bugs and misfunctions may still exist. Moreover, several important
parts are still missing in MRiLab, including MR spectrum simulation, water diffusion
and Eddy-Current simulation etc. I am also working to further optimize
solving kernel for better performance and to enhance the compatibility with
Gadgetron. The MRiLab project is open to the whole MRI community, any user
who are interested to improve MRiLab is very welcome to do so. I will be
very pleased if you can leave me feedback and ideas for better enhancing
MRiLab functionality. I will also be very happy to talk about any kinds of
collaboration for future MRiLab development. Please don&#8217;t hesitate to contact me
(leoliuf@gmail.com).

    
</body></html> 
